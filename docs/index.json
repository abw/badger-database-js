[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Builder/After.js",
    "content": "import Builder from '../Builder.js';\n\nexport class After extends Builder {\n  initBuilder() {\n    this.key = 'after';\n  }\n}\n\nexport default After",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/After.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "After",
    "memberof": "src/Builder/After.js",
    "static": true,
    "longname": "src/Builder/After.js~After",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{After}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 50,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/After.js~After",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/After.js~After#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/After.js~After",
    "static": false,
    "longname": "src/Builder/After.js~After#key",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "file",
    "name": "src/Builder/Before.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Before extends Builder {\n  initBuilder() {\n    this.key = 'before';\n  }\n}\n\nexport default Before",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Before.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 53,
    "kind": "class",
    "name": "Before",
    "memberof": "src/Builder/Before.js",
    "static": true,
    "longname": "src/Builder/Before.js~Before",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Before}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Before.js~Before",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Before.js~Before#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Before.js~Before",
    "static": false,
    "longname": "src/Builder/Before.js~Before#key",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/Builder/Columns.js",
    "content": "import { QueryBuilderError, thrower } from '../Utils/Error.js';\nimport Select from './Select.js';\n\nexport const throwColumnsError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"columns\" component. Expected [column, alias] or [table, column, alias].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"columns\" component.  Valid properties are \"columns\", \"column\", \"table\", \"prefix\" and \"as\".',\n  },\n  QueryBuilderError\n)\n\nexport class Columns extends Select {\n  initBuilder() {\n    this.key = 'select';\n  }\n\n  resolveLinkString(columns, table=this.lookupTable(), prefix=this.context.prefix) {\n    // this is the same as Select, but with table defaulting to last defined\n    // table and prefix defaulting to last defined prefix\n    return super.resolveLinkString(columns, table, prefix);\n  }\n\n  resolveLinkArray(columns) {\n    const table = this.lookupTable()\n\n    if (columns.length === 2) {\n      // two-element array is [column, alias]\n      return this.quoteTableColumnAs(table, ...columns);\n      // table, columns[0], prefix ? `${prefix}${columns[1]}` : columns[1]);\n    }\n    else if (columns.length === 3) {\n      // three-element array is [table, column, alias]\n      return this.quoteTableColumnAs(...columns)\n    }\n    throwColumnsError('array', { n: columns.length });\n  }\n\n  resolveLinkObject(column) {\n    const table = this.lookupTable()\n\n    if (column.column && column.as) {\n      // object can contain \"column\" and \"as\" with optional \"table\"\n      return this.quoteTableColumnAs(\n        column.table || table,\n        column.column,\n        column.as\n      )\n    }\n    // or it must have \"column\" or \"columns\"\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table || table, column.prefix || this.context.prefix)\n    }\n    throwColumnsError('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Columns",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Columns.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "throwColumnsError",
    "memberof": "src/Builder/Columns.js",
    "static": true,
    "longname": "src/Builder/Columns.js~throwColumnsError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwColumnsError}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "class",
    "name": "Columns",
    "memberof": "src/Builder/Columns.js",
    "static": true,
    "longname": "src/Builder/Columns.js~Columns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Columns}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Select.js~Select"
    ]
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Columns.js~Columns",
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#key",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/Builder/Database.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Database extends Builder {\n  initBuilder(database) {\n    this.database = database;\n  }\n  resolve(context) {\n    return {\n      database: this.database,\n      ...context,\n    }\n  }\n}\n\nexport default Database",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "Database",
    "memberof": "src/Builder/Database.js",
    "static": true,
    "longname": "src/Builder/Database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Database}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Database.js~Database#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "database",
    "memberof": "src/Builder/Database.js~Database",
    "static": false,
    "longname": "src/Builder/Database.js~Database#database",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Database.js~Database#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"database\": *, ...context: Object}"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/Builder/From.js",
    "content": "import Builder from '../Builder.js';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\nimport { isArray, isObject, isString, splitList } from '@abw/badger-utils';\n\nconst throwFromError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"from\" component. Expected [table, alias].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"from\" component.  Valid properties are \"tables\", \"table\" and \"as\".',\n  },\n  QueryBuilderError\n)\n\nexport class From extends Builder {\n  initBuilder(...tables) {\n    this.key = 'from';\n    // store the table name for subsequent columns() calls to use, but\n    // we need to be careful to only handle the valid cases, e.g. where\n    // it's a string (which might contain multiple table names), an\n    // array of [table, alias], or an object containing 'table'\n    const table = tables.at(-1);\n    if (isString(table)) {\n      this.table = splitList(table).at(-1);\n    }\n    else if (isArray(table) && table.length === 2) {\n      this.table = table[1];\n    }\n    else if (isObject(table) && table.as) {\n      this.table = table.as;\n    }\n  }\n\n  resolve(context) {\n    return super.resolve(\n      context,\n      // if we've got a table defined then add it to the context\n      this.table\n        ? { table: this.table }\n        : undefined\n    )\n  }\n\n  resolveLinkString(tables) {\n    // split a string of table names and quote each one\n    return splitList(tables).map(\n      table => this.quote(table)\n    );\n  }\n\n  resolveLinkArray(table) {\n    // a two-element array is [table, alias]\n    return table.length === 2\n      ? this.quoteTableAs(...table)\n      : throwFromError('array', { n: table.length });\n  }\n\n  resolveLinkObject(table) {\n    if (table.table) {\n      // if it's an object then it should have a table and optionally an 'as' for an alias\n      return table.as\n        ? this.quoteTableAs(table.table, table.as)\n        : this.quote(table.table)\n    }\n    else if (table.tables) {\n      // or it can have tables\n      return this.resolveLinkString(table.tables);\n    }\n    throwFromError('object', { keys: Object.keys(table).sort().join(', ') });\n  }\n}\n\nexport default From",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/From.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "name": "throwFromError",
    "memberof": "src/Builder/From.js",
    "static": true,
    "longname": "src/Builder/From.js~throwFromError",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "class",
    "name": "From",
    "memberof": "src/Builder/From.js",
    "static": true,
    "longname": "src/Builder/From.js~From",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{From}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "tables",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/From.js~From",
    "static": false,
    "longname": "src/Builder/From.js~From#key",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "table",
    "memberof": "src/Builder/From.js~From",
    "static": false,
    "longname": "src/Builder/From.js~From#table",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "tables",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "file",
    "name": "src/Builder/Group.js",
    "content": "import Builder from '../Builder.js';\nimport { splitList } from '@abw/badger-utils';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\n\nexport const throwGroupError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"group\" component. Expected [column].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"group\" component.  Valid properties are \"columns\" and \"column\".',\n  },\n  QueryBuilderError\n)\n\nexport class Group extends Builder {\n  initBuilder() {\n    this.key = 'group';\n  }\n  resolveLinkString(group) {\n    return splitList(group).map(\n      column => this.quote(column)\n    )\n  }\n  resolveLinkArray(group) {\n    if (group.length === 1) {\n      return this.quote(group[0]);\n    }\n    throwGroupError('array', { n: group.length });\n  }\n\n  resolveLinkObject(group) {\n    if (group.column) {\n      return this.quote(group.column);\n    }\n    else if (group.columns) {\n      return this.resolveLinkString(group.columns)\n    }\n    throwGroupError('object', { keys: Object.keys(group).sort().join(', ') });\n  }\n}\n\nexport default Group",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Group.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 82,
    "kind": "variable",
    "name": "throwGroupError",
    "memberof": "src/Builder/Group.js",
    "static": true,
    "longname": "src/Builder/Group.js~throwGroupError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwGroupError}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "class",
    "name": "Group",
    "memberof": "src/Builder/Group.js",
    "static": true,
    "longname": "src/Builder/Group.js~Group",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Group}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Group.js~Group",
    "static": false,
    "longname": "src/Builder/Group.js~Group#key",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "file",
    "name": "src/Builder/Having.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Having extends Builder {\n  initBuilder() {\n    this.key = 'having';\n  }\n}\n\nexport default Having",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Having.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "class",
    "name": "Having",
    "memberof": "src/Builder/Having.js",
    "static": true,
    "longname": "src/Builder/Having.js~Having",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Having}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Having.js~Having",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Having.js~Having#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Having.js~Having",
    "static": false,
    "longname": "src/Builder/Having.js~Having#key",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "src/Builder/Join.js",
    "content": "import Builder from '../Builder.js';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\n\nconst tableColumnRegex = /^(\\w+)\\.(\\w+)$/;\nconst joinRegex = /^(.*?)=(\\w+)\\.(\\w+)$/;\nconst joinElements = {\n  from:  1,\n  table: 2,\n  to:    3,\n};\nconst joinTypes = {\n  left:    'LEFT JOIN ',\n  right:   'RIGHT JOIN ',\n  inner:   'INNER JOIN ',\n  full:    'FULL JOIN ',\n  default: 'JOIN ',\n};\n\nexport const throwJoinError = thrower(\n  {\n    type:   'Invalid join type \"<type>\" specified for query builder \"join\" component.  Valid types are \"left\", \"right\", \"inner\" and \"full\".',\n    string: 'Invalid join string \"<join>\" specified for query builder \"join\" component.  Expected \"from=table.to\".',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"join\" component.  Valid properties are \"type\", \"table\", \"from\" and \"to\".',\n    array:  'Invalid array with <n> items specified for query builder \"join\" component. Expected [type, from, table, to], [from, table, to] or [from, table.to].',\n  },\n  QueryBuilderError\n)\n\nexport class Join extends Builder {\n  initBuilder() {\n    this.key = 'join';\n    // TODO: grok the table for columns() to use\n    // const join = joins.at(-1);\n  }\n\n  resolveLinkString(join) {\n    // join('a=b.c')\n    // join('a.b=c.d')\n    let match = join.match(joinRegex);\n    let config = { };\n    if (match) {\n      Object.entries(joinElements).map(\n        ([key, index]) => config[key] = match[index]\n      );\n      // console.log('parsed join string [%s]:', config);\n      return this.resolveLinkObject(config);\n    }\n    throwJoinError('string', { join });\n    // return this.resolveLinkArray(splitList(columns), context);\n  }\n\n  resolveLinkArray(join) {\n    if (join.length === 4) {\n      const [type, from, table, to] = join;\n      return this.resolveLinkObject({ type, from, table, to });\n    }\n    else if (join.length === 3) {\n      const [from, table, to] = join;\n      return this.resolveLinkObject({ from, table, to });\n    }\n    else if (join.length === 2) {\n      const match = join[1].match(tableColumnRegex);\n      if (match) {\n        const from = join[0];\n        const [ , table, to] = match;\n        return this.resolveLinkObject({ from, table, to });\n      }\n    }\n    throwJoinError('array', { n: join.length });\n  }\n\n  resolveLinkObject(join) {\n    const type = joinTypes[join.type || 'default']\n      || throwJoinError('type', { type: join.type });\n\n    if (join.table && join.from && join.to) {\n      return this.constructJoin(\n        type, join.from, join.table, this.tableColumn(join.table, join.to)\n      );\n    }\n    else if (join.from && join.to) {\n      const match = join.to.match(tableColumnRegex);\n      if (match) {\n        return this.constructJoin(\n          type, join.from, match[1], this.tableColumn(match[1], match[2])\n        )\n      }\n    }\n    throwJoinError('object', { keys: Object.keys(join).sort().join(', ') });\n  }\n\n  constructJoin(type, from, table, to) {\n    return type\n      + this.quote(table)\n      + ' ON '\n      + this.quote(from)\n      + ' = '\n      + this.quote(to);\n  }\n}\n\nexport default Join",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Join.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "variable",
    "name": "tableColumnRegex",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~tableColumnRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "joinRegex",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "name": "joinElements",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinElements",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{\"from\": number, \"table\": number, \"to\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "joinTypes",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinTypes",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{\"left\": string, \"right\": string, \"inner\": string, \"full\": string, \"default\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "name": "throwJoinError",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~throwJoinError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwJoinError}",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "class",
    "name": "Join",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~Join",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Join}",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Join.js~Join",
    "static": false,
    "longname": "src/Builder/Join.js~Join#key",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "constructJoin",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#constructJoin",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "from",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "to",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "src/Builder/Order.js",
    "content": "import { splitList } from '@abw/badger-utils';\nimport Builder from '../Builder.js';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\n\nconst ASC  = 'ASC';\nconst DESC = 'DESC';\n\nexport const throwOrderError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"order\" component. Expected [column, direction] or [column].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"order\" component.  Valid properties are \"columns\", \"column\", \"direction\", \"dir\", \"asc\" and \"desc\".',\n  },\n  QueryBuilderError\n)\n\nexport class Order extends Builder {\n  initBuilder() {\n    this.key = 'order';\n  }\n\n  resolveLinkString(order, dir) {\n    return splitList(order).map(\n      column => this.constructOrder(column)\n    ).join(', ') + (dir ? ` ${dir}` : '');\n  }\n\n  resolveLinkArray(order) {\n    if (order.length === 2 || order.length === 1) {\n      return this.constructOrder(...order);\n    }\n    throwOrderError('array', { n: order.length });\n  }\n\n  resolveLinkObject(order) {\n    const dir = order.direction || order.dir\n      || (order.desc && DESC)\n      || (order.asc  && ASC);\n\n    if (order.column) {\n      return this.constructOrder(order.column, dir);\n    }\n    else if (order.columns) {\n      return this.resolveLinkString(order.columns, dir)\n    }\n    throwOrderError('object', { keys: Object.keys(order).sort().join(', ') });\n  }\n  constructOrder(column, dir) {\n    return this.quote(column) + (dir ? ` ${dir}` : '');\n  }\n}\n\nexport default Order",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Order.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "name": "ASC",
    "memberof": "src/Builder/Order.js",
    "static": true,
    "longname": "src/Builder/Order.js~ASC",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "DESC",
    "memberof": "src/Builder/Order.js",
    "static": true,
    "longname": "src/Builder/Order.js~DESC",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "variable",
    "name": "throwOrderError",
    "memberof": "src/Builder/Order.js",
    "static": true,
    "longname": "src/Builder/Order.js~throwOrderError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwOrderError}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "class",
    "name": "Order",
    "memberof": "src/Builder/Order.js",
    "static": true,
    "longname": "src/Builder/Order.js~Order",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Order}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Order.js~Order",
    "static": false,
    "longname": "src/Builder/Order.js~Order#key",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      },
      {
        "name": "dir",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "constructOrder",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#constructOrder",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "dir",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "file",
    "name": "src/Builder/Prefix.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Prefix extends Builder {\n  initBuilder(prefix) {\n    this.key    = 'prefix';\n    this.prefix = prefix;\n  }\n  resolve(context) {\n    this.context = {\n      ...context,\n      prefix: this.prefix\n    }\n    return this.context;\n  }\n}\n\nexport default Prefix\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Prefix.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 118,
    "kind": "class",
    "name": "Prefix",
    "memberof": "src/Builder/Prefix.js",
    "static": true,
    "longname": "src/Builder/Prefix.js~Prefix",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Prefix}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#key",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "prefix",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#prefix",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#context",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, \"prefix\": *}"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "file",
    "name": "src/Builder/Select.js",
    "content": "import Builder from '../Builder.js';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\nimport { splitList } from '@abw/badger-utils';\n\nexport const throwSelectError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"select\" component. Expected [column, alias] or [table, column, alias].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"select\" component.  Valid properties are \"columns\", \"column\", \"table\", \"prefix\" and \"as\".',\n  },\n  QueryBuilderError\n)\n\nexport class Select extends Builder {\n  initBuilder() {\n    this.key = 'select';\n  }\n\n  resolveLinkString(columns, table, prefix) {\n    // function to map columns to depends on table and/or prefix being defined\n    const func = table\n      ? prefix\n        ? column => this.quoteTableColumnAs(table, column, `${prefix}${column}`)\n        : column => this.quoteTableColumn(table, column)\n      : prefix\n        ? column => this.quoteColumnAs(column, `${prefix}${column}`)\n        : column => this.quote(column)\n    ;\n    // split string into items and apply function\n    return splitList(columns).map(func);\n  }\n\n  resolveLinkArray(columns) {\n    if (columns.length === 2) {\n      // a two-element array is [column, alias]\n      return this.quoteColumnAs(...columns);\n    }\n    else if (columns.length === 3) {\n      // a three-element array is [table, column, alias]\n      return this.quoteTableColumnAs(...columns)\n    }\n    throwSelectError('array', { n: columns.length });\n  }\n\n  resolveLinkObject(column) {\n    if (column.column && column.as) {\n      // object can contain \"column\", \"as\" and optional \"table\"\n      return column.table\n        ? this.quoteTableColumnAs(\n          column.table,\n          column.column,\n          column.as\n        )\n        : this.quoteColumnAs(\n          column.column,\n          column.as\n        )\n    }\n    // otherwise it should define \"column\" or \"columns\"\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table, column.prefix)\n    }\n    throwSelectError('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Select",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Select.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 125,
    "kind": "variable",
    "name": "throwSelectError",
    "memberof": "src/Builder/Select.js",
    "static": true,
    "longname": "src/Builder/Select.js~throwSelectError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwSelectError}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "class",
    "name": "Select",
    "memberof": "src/Builder/Select.js",
    "static": true,
    "longname": "src/Builder/Select.js~Select",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Select}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Select.js~Select",
    "static": false,
    "longname": "src/Builder/Select.js~Select#key",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "file",
    "name": "src/Builder/Table.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Table extends Builder {\n  initBuilder(table) {\n    this.key   = 'table';\n    this.table = table;\n  }\n  resolve(context) {\n    this.context = {\n      ...context,\n      table: this.table\n    }\n    return this.context;\n  }\n}\n\nexport default Table\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Table.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 133,
    "kind": "class",
    "name": "Table",
    "memberof": "src/Builder/Table.js",
    "static": true,
    "longname": "src/Builder/Table.js~Table",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Table}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Table.js~Table#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Table.js~Table",
    "static": false,
    "longname": "src/Builder/Table.js~Table#key",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "table",
    "memberof": "src/Builder/Table.js~Table",
    "static": false,
    "longname": "src/Builder/Table.js~Table#table",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Table.js~Table#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Table.js~Table",
    "static": false,
    "longname": "src/Builder/Table.js~Table#context",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, \"table\": *}"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/Builder/Where.js",
    "content": "import Builder from '../Builder.js';\nimport { isArray, splitList } from '@abw/badger-utils';\nimport { QueryBuilderError, thrower } from '../Utils/Error.js';\n\nexport const throwWhereError = thrower(\n  {\n    array:  'Invalid array with <n> items specified for query builder \"where\" component. Expected [column, value] or [column, operator, value].',\n    object: 'Invalid value array with <n> items specified for query builder \"where\" component. Expected [value] or [operator, value].',\n  },\n  QueryBuilderError\n)\n\nexport class Where extends Builder {\n  initBuilder() {\n    this.key = 'where';\n  }\n\n  // TODO: check that placeholders are being counted correctly\n  resolveLinkString(columns) {\n    const database = this.lookupDatabase();\n    // split columns into a list and generate criteria with placeholders\n    return splitList(columns).map(\n      column => database.engine.formatWherePlaceholder(\n        column,\n        undefined,\n        this.context.placeholder++\n      )\n    )\n  }\n\n  resolveLinkArray(criteria) {\n    const database = this.lookupDatabase();\n    if (criteria.length === 2) {\n      // a two-element array is [column, value]\n      this.addValues(criteria[1]);\n      return database.engine.formatWherePlaceholder(\n        criteria[0],\n        undefined,\n        this.context.placeholder++\n      )\n    }\n    else if (criteria.length === 3) {\n      // a two-element array is [column, operator, value]\n      this.addValues(criteria[2]);\n      return database.engine.formatWherePlaceholder(\n        criteria[0],\n        [criteria[1], undefined],\n        this.context.placeholder++\n      )\n    }\n    else {\n      throwWhereError('array', { n: criteria.length });\n    }\n  }\n\n  resolveLinkObject(criteria) {\n    const database = this.lookupDatabase();\n    return Object.entries(criteria).map(\n      ([column, value]) => {\n        if (isArray(value)) {\n          // the value can be a two element array: [operator, value]\n          // or a single element array: [operator]\n          if (value.length === 2) {\n            this.addValues(value[1]);\n          }\n          else if (value.length !== 1) {\n            throwWhereError('object', { n: value.length });\n          }\n        }\n        else {\n          // otherwise we assume it's just a value\n          this.addValues(value);\n        }\n        // generate the criteria with a placeholder\n        return database.engine.formatWherePlaceholder(\n          column,\n          value,\n          this.context.placeholder++\n        )\n      }\n    )\n  }\n}\n\nexport default Where",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Where.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "throwWhereError",
    "memberof": "src/Builder/Where.js",
    "static": true,
    "longname": "src/Builder/Where.js~throwWhereError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwWhereError}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "class",
    "name": "Where",
    "memberof": "src/Builder/Where.js",
    "static": true,
    "longname": "src/Builder/Where.js~Where",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Where}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "key",
    "memberof": "src/Builder/Where.js~Where",
    "static": false,
    "longname": "src/Builder/Where.js~Where#key",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "file",
    "name": "src/Builder.js",
    "content": "// work in progress / experiment\nimport { fail, hasValue, isArray, isFunction, isObject, isString, objMap } from \"@abw/badger-utils\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\nimport { notImplementedInBaseClass } from \"./Utils/Error.js\";\n\nconst defaultContext = () => ({\n  after:   [ ],\n  before:  [ ],\n  from:    [ ],\n  group:   [ ],\n  having:  [ ],\n  join:    [ ],\n  order:   [ ],\n  select:  [ ],\n  where:   [ ],\n  values:  [ ],\n  placeholder: 1,\n});\n\n// Each of the parts of a select query in order.  The first entry\n// is the opening keyword, the second is the text used to join\n// multiple values, e.g. { where: ['a=1', 'b=2'] } is expanded to\n// WHERE a=1 AND b=2.  Note that the entries must have whitespace\n// where applicable, e.g. after the opening keyword, e.g. 'WHERE ',\n// and around joining keywords/syntax, e.g. ' AND '\nconst parts = {\n  before:  ['',          \"\\n\"     ],\n  select:  ['SELECT ',   ', '     ],\n  from:    ['FROM ',     ', '     ],\n  join:    ['',          \"\\n\"     ],\n  where:   ['WHERE ',    ' AND '  ],\n  group:   ['GROUP BY ', ', '     ],\n  having:  ['HAVING ',   ' AND '  ],\n  order:   ['ORDER BY ', ', '     ],\n  after:   ['',          \"\\n\"     ],\n};\n\nconst notImplemented = notImplementedInBaseClass('Builder');\n\nexport class Builder {\n  constructor(factory, parent, ...args) {\n    this.factory = factory;\n    this.parent  = parent;\n    this.args    = args;\n    // this.key     = 'unknown';\n    this.initBuilder(...args);\n    addDebugMethod(this, 'builder', { debugPrefix: this.key && `Builder:${this.key}` });\n  }\n  initBuilder() {\n    // stub for subclasses\n  }\n\n  async one(args) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.values(args);\n    this.debugData(\"one()\", { sql, values });\n    return db.one(sql, values);\n  }\n  async any(args) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.values(args);\n    this.debugData(\"any()\", { sql, values });\n    return db.any(sql, values);\n  }\n  async all(args) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.values(args);\n    this.debugData(\"all()\", { sql, values });\n    return db.all(sql, values);\n  }\n\n  values(extra=[]) {\n    const context = this.resolveChain();\n    const values  = context.values;\n    // console.log('context values: ', values);\n    // console.log('extra values: ', extra);\n    // TODO: havingValues\n    return [\n      ...values, ...extra\n    ]\n  }\n  addValues(...values) {\n    this.context.values.push(...values)\n  }\n\n  // generate SQL\n  sql() {\n    const frags = this.sqlFragments();\n    return Object.keys(parts)\n      .map( part => frags[part] )\n      .filter( i => hasValue(i) )\n      .join(\"\\n\");\n  }\n\n  // generate and collect SQL fragments for each item in the chain\n  sqlFragments(context=this.resolveChain()) {\n    return objMap(\n      context,\n      (value, key) => {\n        const part = parts[key];\n        return part && value.length\n          ? part[0] + value.join(part[1])\n          : null;\n      }\n    )\n  }\n\n  // resolve the complete chain from top to bottom\n  resolveChain() {\n    return this.context || this.resolve(\n      this.parent\n        ? this.parent.resolveChain()\n        : defaultContext()\n    );\n  }\n\n  // resolve a link in the chain and merge into parent context\n  resolve(context, args={}) {\n    const key = this.key;\n    this.context = {\n      ...context,\n      ...args\n    }\n    const values = this.resolveLink();\n    this.context[key] = [...(this.context[key] || []), ...values];\n    return this.context;\n    /*\n    return {\n      ...context,\n      [key]: [...(context[key] || []), ...this.resolveLink(context)],\n      ...args\n    }\n    */\n  }\n\n  // resolve a link in the chain\n  resolveLink() {\n    return this.args.map(\n      item => (isObject(item) && item.sql)\n        ? item.sql\n        : this.resolveLinkItem(item)\n    ).flat()\n  }\n\n  // resolve an individual argument for a link in the chain\n  resolveLinkItem(item) {\n    if (isString(item)) {\n      return this.resolveLinkString(item);\n    }\n    else if (isArray(item)) {\n      return this.resolveLinkArray(item);\n    }\n    else if (isFunction(item)) {\n      return item(this);\n    }\n    else if (isObject(item)) {\n      return this.resolveLinkObject(item);\n    }\n    fail(\"Invalid link item: \", item);\n  }\n\n  resolveLinkString() {\n    notImplemented(\"resolveLinkString()\");\n  }\n  resolveLinkArray() {\n    notImplemented(\"resolveLinkArray()\");\n  }\n  resolveLinkObject() {\n    notImplemented(\"resolveLinkObject()\");\n  }\n\n  // utility methods\n  lookup(key, error) {\n    return this[key] ||\n      (this.parent\n        ? this.parent.lookup(key)\n        : fail(error || `Missing item in query chain: ${key}`))\n  }\n  lookupDatabase() {\n    return this.context.database || this.lookup('database');\n  }\n  lookupTable() {\n    return this.context.table || this.lookup('table');\n  }\n  quote(item) {\n    return this.lookupDatabase().quote(item)\n  }\n  tableColumn(table, column) {\n    return column.match(/\\./)\n      ? column\n      : `${table}.${column}`;\n  }\n  quoteTableColumn(table, column) {\n    return this.quote(\n      this.tableColumn(table, column)\n    )\n  }\n  quoteTableAs(table, as) {\n    return [\n      this.quote(table),\n      this.quote(as)\n    ].join(' AS ');\n  }\n  quoteTableColumnAs(table, column, as) {\n    return [\n      this.quoteTableColumn(table, column),\n      this.quote(as)\n    ].join(' AS ')\n  }\n  quoteColumnAs(column, as) {\n    return [\n      this.quote(column),\n      this.quote(as)\n    ].join(' AS ')\n  }\n}\n\nexport default Builder",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "defaultContext",
    "memberof": "src/Builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder.js~defaultContext",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 149,
    "kind": "variable",
    "name": "parts",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~parts",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "{\"before\": *, \"select\": *, \"from\": *, \"join\": *, \"where\": *, \"group\": *, \"having\": *, \"order\": *, \"after\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "variable",
    "name": "notImplemented",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~notImplemented",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 151,
    "kind": "class",
    "name": "Builder",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~Builder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Builder}",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 152,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "factory",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#factory",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "parent",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#parent",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "args",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#args",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "one",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#one",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "any",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#any",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "all",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#all",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "values",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#values",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "extra",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "addValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#addValues",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "sql",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#sql",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "sqlFragments",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#sqlFragments",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "resolveChain",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveChain",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#context",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, ...args: Object}"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "resolveLink",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLink",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "resolveLinkItem",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkItem",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "lookup",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookup",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "lookupDatabase",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookupDatabase",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "lookupTable",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookupTable",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quote",
    "access": "public",
    "description": null,
    "lineNumber": 188,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "tableColumn",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#tableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "quoteTableColumn",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "quoteTableAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableAs",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "quoteTableColumnAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableColumnAs",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "quoteColumnAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteColumnAs",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "file",
    "name": "src/Builders.js",
    "content": "import After    from './Builder/After.js';\nimport Before   from './Builder/Before.js';\nimport Columns  from './Builder/Columns.js';\nimport Database from './Builder/Database.js';\nimport From     from './Builder/From.js';\nimport Group    from './Builder/Group.js';\nimport Having   from './Builder/Having.js';\nimport Join     from './Builder/Join.js';\nimport Order    from './Builder/Order.js';\nimport Prefix   from './Builder/Prefix.js';\nimport Select   from './Builder/Select.js';\nimport Table    from './Builder/Table.js';\nimport Where    from './Builder/Where.js';\nimport Proxy    from './Proxy/Builder.js';\n\nexport const builders = {\n  after:     After,\n  before:    Before,\n  columns:   Columns,\n  from:      From,\n  group:     Group,\n  groupBy:   Group,\n  having:    Having,\n  join:      Join,\n  order:     Order,\n  orderBy:   Order,\n  prefix:    Prefix,\n  select:    Select,\n  table:     Table,\n  where:     Where,\n}\n\nexport const factory = (parent, type, ...args) => {\n  return new builders[type](factory, parent, ...args);\n}\n\nexport const databaseBuilder = database =>\n  Proxy(new Database(factory, undefined, database))\n\nexport const tableBuilder = table =>\n  Proxy(new Table(factory, undefined, table))\n\nexport default factory;",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builders.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 182,
    "kind": "variable",
    "name": "builders",
    "memberof": "src/Builders.js",
    "static": true,
    "longname": "src/Builders.js~builders",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{builders}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "{\"after\": *, \"before\": *, \"columns\": *, \"from\": *, \"group\": *, \"groupBy\": *, \"having\": *, \"join\": *, \"order\": *, \"orderBy\": *, \"prefix\": *, \"select\": *, \"table\": *, \"where\": *}"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "factory",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~factory",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{factory}",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "databaseBuilder",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~databaseBuilder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseBuilder}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "tableBuilder",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~tableBuilder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{tableBuilder}",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "src/Constants.js",
    "content": "// table column configuration/validation\nexport const defaultIdColumn  = 'id';\nexport const bitSplitter      = /:/;\nexport const allColumns       = '*';\nexport const whereTrue        = 'true';\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "variable",
    "name": "defaultIdColumn",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~defaultIdColumn",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{defaultIdColumn}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "variable",
    "name": "bitSplitter",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~bitSplitter",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{bitSplitter}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "variable",
    "name": "allColumns",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~allColumns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{allColumns}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "variable",
    "name": "whereTrue",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~whereTrue",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{whereTrue}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "file",
    "name": "src/Database.js",
    "content": "import Table from './Table.js';\nimport Tables from './Tables.js';\nimport Queries from './Queries.js';\nimport proxymise from 'proxymise';\nimport modelProxy from './Proxy/Model.js';\nimport { engine } from './Engines.js';\nimport { invalid, missing } from './Utils/Error.js';\nimport { addDebugMethod } from './Utils/Debug.js';\nimport { databaseBuilder } from './Builders.js';\n\nconst defaults = {\n  tablesClass: Tables\n};\n\nexport class Database {\n  constructor(engine, params={ }) {\n    const config = { ...defaults, ...params };\n    this.engine  = engine || missing('engine');\n    this.queries = new Queries(config);\n    this.tables  = config.tablesObject || new config.tablesClass(config.tables);\n    this.model   = modelProxy(this);\n    this.waiter  = proxymise(this);\n    this.state   = {\n      table: { },\n    };\n    addDebugMethod(this, 'database', config);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Engine methods\n  //-----------------------------------------------------------------------------\n  acquire() {\n    return this.engine.acquire();\n  }\n  release(connection) {\n    this.engine.release(connection);\n  }\n  query(name) {\n    this.debugData(\"query()\", { name });\n    return this.queries.query(name);\n  }\n  run(query, params, options) {\n    this.debugData(\"run()\", { query, params, options });\n    return this.engine.run(this.query(query), params, options)\n  }\n  any(query, params, options) {\n    this.debugData(\"any()\", { query, params, options });\n    return this.engine.any(this.query(query), params, options)\n  }\n  all(query, params, options) {\n    this.debugData(\"all()\", { query, params, options });\n    return this.engine.all(this.query(query), params, options)\n  }\n  one(query, params, options) {\n    this.debugData(\"one()\", { query, params, options });\n    return this.engine.one(this.query(query), params, options)\n  }\n  async table(name) {\n    return this.state.table[name]\n      ||=  this.initTable(name);\n  }\n  hasTable(name) {\n    return this.tables.table(name);\n  }\n  initTable(name) {\n    const schema = this.hasTable(name) || invalid('table', name);\n    const tclass = schema.tableClass   || Table;\n    const topts  = schema.tableOptions || { };\n    schema.table ||= name;\n    return new tclass(this, { ...schema, ...topts });\n  }\n  quote(name) {\n    return this.engine.quote(name);\n  }\n  builder() {\n    return databaseBuilder(this);\n  }\n  select(...args) {\n    return this.builder().select(...args);\n  }\n  from(...args) {\n    return this.builder().from(...args);\n  }\n  disconnect() {\n    return this.engine.destroy();\n  }\n  destroy() {\n    console.log('destroy() is deprecated, use disconnect() instead');\n    return this.disconnect();\n  }\n}\n\nexport const connect = async config => {\n  const e = await engine(config);\n  return new Database(e, config)\n}\n\nexport default Database\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 192,
    "kind": "variable",
    "name": "defaults",
    "memberof": "src/Database.js",
    "static": true,
    "longname": "src/Database.js~defaults",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{\"tablesClass\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "class",
    "name": "Database",
    "memberof": "src/Database.js",
    "static": true,
    "longname": "src/Database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Database}",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 194,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#engine",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "queries",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#queries",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "tables",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#tables",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "model",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#model",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "waiter",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#waiter",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "state",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#state",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"table\": *}"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "acquire",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#acquire",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "release",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#release",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "query",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#query",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "run",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#run",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "any",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#any",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "all",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#all",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "one",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#one",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "table",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Database.js~Database#table",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "hasTable",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#hasTable",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "initTable",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#initTable",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#quote",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "builder",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#builder",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "select",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#select",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "from",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#from",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "destroy",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#destroy",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "function",
    "name": "connect",
    "memberof": "src/Database.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Database.js~connect",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{connect}",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "file",
    "name": "src/Engine/Mysql.js",
    "content": "import mysql from 'mysql2/promise';\nimport Engine from '../Engine.js';\nimport { defaultIdColumn } from '../Constants.js';\n\nexport class MysqlEngine extends Engine {\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { database: this.database });\n    return mysql.createConnection(this.database);\n  }\n  async connected() {\n    return true;\n  }\n  async disconnect(connection) {\n    this.debug(\"disconnect()\");\n    connection.destroy();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async run(sql, params, options) {\n    this.debugData(\"run()\", { sql, params, options });\n    [params, options] = this.optionalParams(params, options);\n    return this\n      .execute(sql, query => query.execute(params), options)\n      .then( ([result]) => result );\n  }\n  async any(sql, params, options) {\n    this.debugData(\"any()\", { sql, params, options });\n    return this\n      .execute(sql, query => query.execute(params), options)\n      .then( ([rows]) => rows[0] );\n  }\n  async all(sql, params, options) {\n    this.debugData(\"all()\", { sql, params, options });\n    return this\n      .execute(sql, query => query.execute(params), options)\n      .then( ([rows]) => rows );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result, options={}) {\n    const keys = options.keys || [defaultIdColumn];\n    const id = keys[0];\n    result[0].changes ||= result[0].affectedRows || 0;\n    result[0].id      ||= result[0].insertId || null;\n    result[0][id]     ||= result[0].insertId || null;\n    return result;\n  }\n}\n\nexport default MysqlEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Mysql.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 219,
    "kind": "class",
    "name": "MysqlEngine",
    "memberof": "src/Engine/Mysql.js",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{MysqlEngine}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "file",
    "name": "src/Engine/Postgres.js",
    "content": "import pg from 'pg';\nimport Engine from '../Engine.js';\nimport { defaultIdColumn } from '../Constants.js';\n\nexport class PostgresEngine extends Engine {\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { database: this.database });\n    const client = new pg.Client(this.database);\n    await client.connect();\n    return client;\n  }\n  async connected() {\n    return true;\n  }\n  async disconnect(client) {\n    this.debug(\"disconnect()\");\n    client.end();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async execute(sql, params, options={}) {\n    this.debugData(\"execute()\", { sql, params, options });\n    const client = await this.acquire();\n    const result = await client.query(sql, params);\n    this.release(client);\n    return options.sanitizeResult\n      ? this.sanitizeResult(result, options)\n      : result;\n  }\n  async run(sql, params, options) {\n    this.debugData(\"run()\", { sql, params, options });\n    [params, options] = this.optionalParams(params, options);\n    return this\n      .execute(sql, params, options)\n  }\n  async any(sql, params, options) {\n    this.debugData(\"any()\", { sql, params, options });\n    return this\n      .execute(sql, params, options)\n      .then( ({rows}) => rows[0] );\n  }\n  async all(sql, params, options) {\n    this.debugData(\"all()\", { sql, params, options });\n    return this\n      .execute(sql, params, options)\n      .then( ({rows}) => rows );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result, options={}) {\n    // console.log('sanitizeResult() result: ', result);\n    // console.log('sanitizeResult() options: ', options);\n    result.changes ||= result.rowCount || 0;\n    if (result.command === 'INSERT' && result.rows?.length) {\n      const keys = options.keys || [defaultIdColumn];\n      keys.forEach(\n        key => result[key] ||= result.rows[0][key]\n      )\n      result.id ||= result[keys[0]];\n    }\n    return result;\n  }\n  formatPlaceholder(n) {\n    return '$' + n;\n  }\n  formatReturning(keys) {\n    return ' RETURNING ' + this.formatColumns(keys);\n  }\n}\n\nexport default PostgresEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Postgres.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 228,
    "kind": "class",
    "name": "PostgresEngine",
    "memberof": "src/Engine/Postgres.js",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{PostgresEngine}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "client",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "execute",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#execute",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "formatPlaceholder",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#formatPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "formatReturning",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#formatReturning",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "keys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "file",
    "name": "src/Engine/Sqlite.js",
    "content": "import Database from 'better-sqlite3';\nimport Engine from '../Engine.js';\nimport { missing } from '../Utils/Error.js';\nimport { defaultIdColumn } from '../Constants.js';\n\nexport class SqliteEngine extends Engine {\n  configure(config) {\n    this.filename = config.database.filename || missing('filename');\n    this.options  = config.database.options  || { };\n\n    // better-sqlite3 is synchronous (because Sqlite serialises all\n    // requests anyway), so there's no need/benefit in using a pool\n    config.pool     ||= { };\n    config.pool.min ||= 1;\n    config.pool.max ||= 1;\n\n    return config;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { filename: this.filename, options: this.options });\n    return new Database(this.filename, this.options);\n  }\n  async connected(db) {\n    return db.open;\n  }\n  async disconnect(db) {\n    this.debug(\"disconnect()\");\n    db.close();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async run(sql, params=[], options) {\n    this.debugData(\"run()\", { sql, params, options });\n    [params, options] = this.optionalParams(params, options);\n    return this.execute(sql, query => query.run(...params), options);\n  }\n  async any(sql, params=[], options) {\n    this.debugData(\"any()\", { sql, params, options });\n    return this.execute(sql, query => query.get(...params), options);\n  }\n  async all(sql, params=[], options) {\n    this.debugData(\"all()\", { sql, params, options });\n    return this.execute(sql, query => query.all(...params), options);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result, options={}) {\n    result.changes ||= result.rowCount || 0;\n    const keys = options.keys || [defaultIdColumn];\n    const id = keys[0];\n    result[id] ||= result.lastInsertRowid;\n    result.id  ||= result.lastInsertRowid;\n    return result;\n  }\n}\n\nexport default SqliteEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Sqlite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 240,
    "kind": "class",
    "name": "SqliteEngine",
    "memberof": "src/Engine/Sqlite.js",
    "static": true,
    "longname": "src/Engine/Sqlite.js~SqliteEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{SqliteEngine}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#configure",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "member",
    "name": "filename",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#filename",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "options",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#options",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "db",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "db",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "file",
    "name": "src/Engine.js",
    "content": "import { Pool } from 'tarn';\nimport { missing, notImplementedInBaseClass, unexpectedRowCount } from \"./Utils/Error.js\";\nimport { format } from './Utils/Format.js';\nimport { hasValue, isArray, isObject, splitList } from '@abw/badger-utils';\nimport { addDebugMethod } from './Utils/Debug.js';\nimport { allColumns, whereTrue } from './Constants.js';\n\nconst notImplemented = notImplementedInBaseClass('Engine');\n\nconst poolDefaults = {\n  min: 2,\n  max: 10,\n  propagateCreateError: true\n}\n\nconst quoteChars = {\n  mysql:   '`',\n  default: '\"',\n};\n\nconst queries = {\n  insert: 'INSERT INTO <table> (<columns>) VALUES (<placeholders>) <returning>',\n  update: 'UPDATE <table> SET <set> WHERE <where>',\n  delete: 'DELETE FROM <table> WHERE <where>',\n  select: 'SELECT <columns> FROM <table> WHERE <where> <order>',\n}\n\nexport class Engine {\n  constructor(config={}) {\n    this.engine    = config.engine   || missing('engine');\n    this.database  = config.database || missing('database');\n    this.config    = this.configure(config);\n    this.pool      = this.initPool(config.pool);\n    this.quoteChar = quoteChars[this.engine||'default'] || quoteChars.default;\n    this.escQuote  = `\\\\${this.quoteChar}`;\n    addDebugMethod(this, 'engine', config);\n  }\n  configure(config) {\n    return config;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool configuration\n  //-----------------------------------------------------------------------------\n  initPool(options={}) {\n    return new Pool({\n      create: () => {\n        this.debug(\"connecting to pool\");\n        return this.connect();\n      },\n      validate: connection => {\n        return this.connected(connection);\n      },\n      destroy: connection => {\n        this.debug(\"disconnecting from pool\");\n        return this.disconnect(connection);\n      },\n      ...poolDefaults,\n      ...options\n    });\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods - must be implemented by subclasses\n  //-----------------------------------------------------------------------------\n  async connect() {\n    notImplemented(\"connect()\")\n  }\n  async connected() {\n    notImplemented(\"connected()\")\n  }\n  async disconnect() {\n    notImplemented(\"disconnect()\")\n  }\n\n  //-----------------------------------------------------------------------------\n  // Methods to acquire and release connections from the pool\n  //-----------------------------------------------------------------------------\n  async acquire() {\n    this.debug(\"acquire()\");\n    return this.pool.acquire().promise;\n  }\n  async release(connection) {\n    this.debug(\"release()\");\n    await this.pool.release(connection);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Generic query methods\n  //-----------------------------------------------------------------------------\n  async execute(sql, action, options={}) {\n    this.debugData(\"execute()\", { sql, options });\n    const connection = await this.acquire();\n    const query      = await this.prepare(connection, sql);\n    const result     = await action(query);\n    this.release(connection);\n    return options.sanitizeResult\n      ? this.sanitizeResult(result, options)\n      : result;\n  }\n  async prepare(connection, sql) {\n    this.debugData(\"prepare()\", { sql });\n    return connection.prepare(sql);\n  }\n  optionalParams(params, options) {\n    if (isObject(params)) {\n      options = params;\n      params = [ ];\n    }\n    return [params, options];\n  }\n  async run() {\n    notImplemented('run()');\n  }\n  async any() {\n    notImplemented('any()');\n  }\n  async all() {\n    notImplemented('all()');\n  }\n  async one(sql, params, options) {\n    this.debugData(\"one()\", { sql, params, options });\n    const rows = await this.all(sql, params, options);\n    if (rows.length === 1) {\n      return rows[0];\n    }\n    else {\n      unexpectedRowCount(rows.length);\n    }\n  }\n\n  //-----------------------------------------------------------------------------\n  // Specific queries: insert, update and delete\n  //-----------------------------------------------------------------------------\n  async insert(table, colnames, values, keys) {\n    const columns      = this.formatColumns(colnames);\n    const placeholders = this.formatPlaceholders(values);\n    const returning    = this.formatReturning(keys);\n    const sql          = format(queries.insert, { table, columns, placeholders, returning});\n    this.debugData(\"insert()\", { table, colnames, values, keys, sql });\n    return this.run(sql, values, { keys, sanitizeResult: true });\n  }\n  async update(table, datacols, datavals, wherecols, wherevals) {\n    const set    = this.formatColumnPlaceholders(datacols);\n    const where  = this.formatWherePlaceholders(wherecols, wherevals, datacols.length + 1);\n    const values = this.prepareValues(wherevals);\n    const sql    = format(queries.update, { table, set, where });\n    this.debugData(\"update()\", { table, datacols, datavals, wherecols, wherevals, sql });\n    return this.run(sql, [...datavals, ...values], { sanitizeResult: true });\n  }\n  async delete(table, wherecols, wherevals) {\n    const where  = this.formatWherePlaceholders(wherecols, wherevals);\n    const values = this.prepareValues(wherevals);\n    const sql    = format(queries.delete, { table, where });\n    this.debugData(\"delete()\", { table, wherecols, wherevals, sql });\n    return this.run(sql, values, { sanitizeResult: true });\n  }\n\n  //-----------------------------------------------------------------------------\n  // Select queries\n  //-----------------------------------------------------------------------------\n  selectQuery(table, wherecols, wherevals, options={}) {\n    this.debugData(\"selectQuery()\", { table, wherecols, options });\n    const columns = this.formatColumns(options.columns);\n    const where   = this.formatWherePlaceholders(wherecols, wherevals);\n    const order   = this.formatOrderBy(options.orderBy || options.order);\n    return [\n      format(queries.select, { table, columns, where, order }),\n      this.prepareValues(wherevals)\n    ]\n  }\n  async selectAll(table, wherecols, wherevals, options={}) {\n    const [sql, values] = this.selectQuery(table, wherecols, wherevals, options);\n    this.debugData(\"selectAll()\", { table, wherecols, wherevals, options, sql, values });\n    return this.all(sql, values);\n  }\n  async selectAny(table, wherecols, wherevals, options={}) {\n    const [sql, values] = this.selectQuery(table, wherecols, wherevals, options);\n    this.debugData(\"selectAny()\", { table, wherecols, wherevals, options, sql, values });\n    return this.any(sql, values);\n  }\n  async selectOne(table, wherecols, wherevals, options={}) {\n    const [sql, values] = this.selectQuery(table, wherecols, wherevals, options);\n    this.debugData(\"selectOne()\", { table, wherecols, wherevals, options, sql, values });\n    return this.one(sql, values);\n  }\n  async select(...args) {\n    return this.selectAll(...args);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result) {\n    return result;\n  }\n  quote(name) {\n    return name\n      .split(/\\./)\n      .map(\n        part => part === allColumns\n          ? part\n          : this.quoteChar + part.replaceAll(this.quoteChar, this.escQuote) + this.quoteChar)\n      .join('.');\n  }\n  quoteTableColumn(table, column) {\n    // if the column already has a dot then we quote it as is,\n    // otherwise we explicitly add the table name\n    return column.match(/\\./)\n      ? this.quote(column)\n      : this.quote(`${table}.${column}`);\n  }\n  formatPlaceholder() {\n    return '?';\n  }\n  formatColumnPlaceholder(column, n) {\n    return `${this.quote(column)}=${this.formatPlaceholder(n)}`;\n  }\n  formatWherePlaceholder(column, value, n) {\n    // value can be an array containing a comparison operator and a value,\n    // e.g. ['>' 1973], otherwise we assume it's an equality operator, '='\n    const cmp = isArray(value) ? value[0] : '=';\n    return `${this.quote(column)}${cmp}${this.formatPlaceholder(n)}`;\n  }\n  formatPlaceholders(values, n=1) {\n    return values.map(\n      () => this.formatPlaceholder(n++)\n    ).join(', ');\n  }\n  formatColumnPlaceholders(columns, n=1, joint=', ') {\n    return columns.map(\n      column => this.formatColumnPlaceholder(column, n++)\n    ).join(joint);\n  }\n  formatWherePlaceholders(columns, values, n=1, joint=' AND ') {\n    let i = 0;\n    return columns.map(\n      column => this.formatWherePlaceholder(column, values[i++], n++)\n    ).join(joint) || whereTrue;\n  }\n  formatColumns(columns) {\n    return hasValue(columns)\n      ? splitList(columns)\n        .map(\n          column => this.quote(column)\n        )\n        .join(', ')\n      : allColumns;\n  }\n  formatReturning() {\n    return '';\n  }\n  formatOrderBy(order) {\n    return hasValue(order)\n      ? `ORDER BY ${order}`\n      : '';\n  }\n  prepareValues(values) {\n    return values.map(\n      // values can be arrays with a comparison, e.g. ['>', 1973], in which case\n      // we only want the second element\n      value => isArray(value)\n        ? value[1]\n        : value\n    )\n  }\n\n\n  //-----------------------------------------------------------------------------\n  // Cleanup\n  //-----------------------------------------------------------------------------\n  async destroy() {\n    this.debug(\"destroy() \");\n    await this.pool.destroy();\n  }\n}\n\nexport default Engine\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 252,
    "kind": "variable",
    "name": "notImplemented",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~notImplemented",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 253,
    "kind": "variable",
    "name": "poolDefaults",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~poolDefaults",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "{\"min\": number, \"max\": number, \"propagateCreateError\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "name": "quoteChars",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~quoteChars",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "{\"mysql\": string, \"default\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 255,
    "kind": "variable",
    "name": "queries",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~queries",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "{\"insert\": string, \"update\": string, \"delete\": string, \"select\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 256,
    "kind": "class",
    "name": "Engine",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~Engine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Engine}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 257,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true
  },
  {
    "__docId__": 258,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#engine",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "database",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#database",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "member",
    "name": "config",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#config",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "pool",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#pool",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "member",
    "name": "quoteChar",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#quoteChar",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "member",
    "name": "escQuote",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#escQuote",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#configure",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "initPool",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#initPool",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "acquire",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#acquire",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "release",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#release",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "execute",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#execute",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "action",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "prepare",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#prepare",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "optionalParams",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#optionalParams",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#run",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#any",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#all",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "one",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#one",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "insert",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#insert",
    "access": "public",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "colnames",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "keys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "update",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#update",
    "access": "public",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "datacols",
        "types": [
          "*"
        ]
      },
      {
        "name": "datavals",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#delete",
    "access": "public",
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "selectQuery",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#selectQuery",
    "access": "public",
    "description": null,
    "lineNumber": 162,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "selectAll",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#selectAll",
    "access": "public",
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "selectAny",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#selectAny",
    "access": "public",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "selectOne",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#selectOne",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherecols",
        "types": [
          "*"
        ]
      },
      {
        "name": "wherevals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "select",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#select",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#quote",
    "access": "public",
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "quoteTableColumn",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#quoteTableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "formatPlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "formatColumnPlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumnPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "formatWherePlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatWherePlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "formatPlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatPlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "formatColumnPlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumnPlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      },
      {
        "name": "joint",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": ", ",
        "defaultValue": ", "
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "formatWherePlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatWherePlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      },
      {
        "name": "joint",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": " AND ",
        "defaultValue": " AND "
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "formatColumns",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumns",
    "access": "public",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "formatReturning",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatReturning",
    "access": "public",
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "formatOrderBy",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatOrderBy",
    "access": "public",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "prepareValues",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#prepareValues",
    "access": "public",
    "description": null,
    "lineNumber": 258,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "destroy",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#destroy",
    "access": "public",
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 300,
    "kind": "file",
    "name": "src/Engines.js",
    "content": "import { databaseConfig } from \"./Utils/Database.js\";\nimport { invalid, missing } from \"./Utils/Error.js\";\nimport Mysql from './Engine/Mysql.js'\nimport Postgres from './Engine/Postgres.js'\nimport Sqlite from './Engine/Sqlite.js'\n\nlet Engines = { };\n\nexport const registerEngine = (name, module) => {\n  Engines[name] = async config => {\n    return new module(config);\n  }\n}\n\nregisterEngine('sqlite',     Sqlite);\nregisterEngine('mysql',      Mysql);\nregisterEngine('postgres',   Postgres);\nregisterEngine('postgresql', Postgres);\n\n//-----------------------------------------------------------------------------\n// Engine constructor\n//-----------------------------------------------------------------------------\nexport const engine = async config => {\n  config = databaseConfig(config);\n  const engine = config.engine || missing('database.engine');\n  const handler = Engines[engine] || invalid('database.engine', engine);\n  return await handler(config);\n}\n\nexport default Engines;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engines.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 301,
    "kind": "function",
    "name": "registerEngine",
    "memberof": "src/Engines.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Engines.js~registerEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{registerEngine}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "module",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 302,
    "kind": "function",
    "name": "engine",
    "memberof": "src/Engines.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Engines.js~engine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{engine}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "variable",
    "name": "Engines",
    "memberof": "src/Engines.js",
    "static": true,
    "longname": "src/Engines.js~Engines",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "Engines",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 304,
    "kind": "file",
    "name": "src/Proxy/Builder.js",
    "content": "import { builders } from \"../Builders.js\";\n\nexport const builderProxy = parent =>\n  new Proxy(\n    parent,\n    {\n      get(target, prop) {\n        // console.log('builderProxy %s', prop);\n        if (builders[prop]) {\n          return (\n            (...args) => builderProxy(target.factory(parent, prop, ...args))\n          ).bind(target);\n        }\n        else {\n          return Reflect.get(target, prop);\n        }\n      }\n    }\n  );\n\nexport default builderProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 305,
    "kind": "function",
    "name": "builderProxy",
    "memberof": "src/Proxy/Builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Builder.js~builderProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{builderProxy}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "parent",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "file",
    "name": "src/Proxy/Model.js",
    "content": "import { fail } from \"@abw/badger-utils\";\n\nexport const modelProxy = database =>\n  new Proxy(\n    database,\n    {\n      get(target, prop) {\n        if (prop === 'then') {\n          return Reflect.get(target, prop);\n        }\n        if (target.hasTable(prop)) {\n          return target.table(prop);\n        }\n        return target[prop]\n          || fail(\"Invalid table specified: \", prop);\n      }\n    }\n  );\n\nexport default modelProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 307,
    "kind": "function",
    "name": "modelProxy",
    "memberof": "src/Proxy/Model.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Model.js~modelProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{modelProxy}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "file",
    "name": "src/Proxy/Record.js",
    "content": "export const recordProxy = record =>\n  new Proxy(\n    record,\n    {\n      get(target, prop) {\n        // console.log('recordProxy get(%s)', prop);\n        // first look to see if the record has the property/method itself\n        if (Reflect.has(target, prop)) {\n          return Reflect.get(target, prop);\n        }\n        // then look to see if it's a data item\n        if (Reflect.has(target.row, prop)) {\n          return Reflect.get(target.row, prop);\n        }\n        // then look to see if it's a relation\n        if (Reflect.has(target.table.relations, prop)) {\n          // console.log('recordProxy column: ', prop);\n          return target.relation(prop);\n        }\n        return Reflect.get(target, prop);\n      }\n    }\n  );\n\nexport default recordProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 309,
    "kind": "function",
    "name": "recordProxy",
    "memberof": "src/Proxy/Record.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Record.js~recordProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{recordProxy}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "file",
    "name": "src/Queries.js",
    "content": "import { fail } from \"@abw/badger-utils\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\n\nconst defaults = {\n  maxExpansion: 16,\n  fragments: { },\n  queries:  { }\n};\n\nexport class Queries {\n  constructor(config) {\n    this.config = { ...defaults, ...config };\n    //this.fragments = schema.fragments || { };\n    //this.queries = schema.queries || { };\n    //this.maxExpansion = schema.maxExpansion || defaults.maxExpansion;\n    addDebugMethod(this, 'queries', this.config);\n  }\n  query(name) {\n    // if the name is a single word then it must be a named query, otherwise\n    // we assume it's an SQL query possibly with embedded fragments.\n    return this.expandFragments(\n      name.match(/^\\w+$/)\n        ? this.config.queries[name] || fail(\"Invalid query specified: \", name)\n        : name\n    );\n  }\n  expandFragments(query) {\n    const fragments = this.config.fragments;\n    query = query.trim();\n    let sql = query;\n    let max = this.config.maxExpansion;\n    let runaway = 0;\n    let expanded = [ ];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let replaced = false;\n      sql = sql.replace(\n        /<(\\w+?)>/g,\n        (match, word) => {\n          replaced = true;\n          expanded.push(word);\n          return fragments[word] || fail(\"Invalid fragment in SQL expansion: <\", word, \">\");\n        }\n      );\n      if (! replaced) {\n        break;\n      }\n      if (++runaway >= max) {\n        fail(\n          \"Maximum SQL expansion limit (maxExpansion=\", max, \") exceeded: \",\n          expanded.join(' -> ', )\n        )\n      }\n    }\n    this.debugData(\"expandFragments()\", { query, sql });\n    return sql;\n  }\n}\n\nexport const queries = (schema) =>\n  new Queries(schema)\n\nexport default Queries",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Queries.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "name": "defaults",
    "memberof": "src/Queries.js",
    "static": true,
    "longname": "src/Queries.js~defaults",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "{\"maxExpansion\": number, \"fragments\": *, \"queries\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 312,
    "kind": "class",
    "name": "Queries",
    "memberof": "src/Queries.js",
    "static": true,
    "longname": "src/Queries.js~Queries",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Queries}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 313,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Queries.js~Queries",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queries.js~Queries#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "config",
    "memberof": "src/Queries.js~Queries",
    "static": false,
    "longname": "src/Queries.js~Queries#config",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{...defaults: Object, ...config: Object}"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "query",
    "memberof": "src/Queries.js~Queries",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queries.js~Queries#query",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "expandFragments",
    "memberof": "src/Queries.js~Queries",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queries.js~Queries#expandFragments",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "function",
    "name": "queries",
    "memberof": "src/Queries.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Queries.js~queries",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{queries}",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 318,
    "kind": "file",
    "name": "src/Record.js",
    "content": "import relations from \"./Relation/index.js\";\nimport { fail } from \"@abw/badger-utils\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\nimport { throwDeletedRecordError } from \"./Utils/Error.js\";\nimport { relationConfig } from \"./Utils/Relation.js\";\n\nexport class Record {\n  constructor(table, row, config={}) {\n    this.table     = table;\n    this.database  = table.database;\n    this.row       = row;\n    this.relations = { };\n    this.config    = config;\n    addDebugMethod(this, 'record', { debugPrefix: `Record:${this.table.table}` }, config);\n  }\n  async update(set) {\n    this.debugData(\"update()\", { set });\n    this.assertNotDeleted('update');\n    const where = this.table.identity(this.row);\n    const update = await this.table.updateOneRow(set, where, { reload: true });\n    Object.assign(this.row, update);\n    return this;\n  }\n  async delete() {\n    this.debugData(\"delete()\");\n    this.assertNotDeleted('delete');\n    const where = this.table.identity(this.row);\n    await this.table.delete(where);\n    this.deleted = true;\n    return this;\n  }\n  assertNotDeleted(action) {\n    if (this.deleted) {\n      throwDeletedRecordError(\n        'action',\n        {\n          action,\n          table: this.table.table,\n          id:    this.table.keys.map( key => this.row[key] ).join('/')\n        }\n      )\n    }\n  }\n  async relation(name) {\n    this.debug('relation(%s)', name);\n    return this.relations[name]\n      ||=  await this.initRelation(name);\n  }\n  async initRelation(name) {\n    this.debug('initRelation(%s)', name);\n    const table = this.table.table;\n    const relation = relationConfig(\n      table, name,\n      this.table.relations[name]\n        || fail(`Invalid \"${name}\" relation specified for ${table} table`)\n    )\n    if (relation.load) {\n      return await relation.load(this);\n    }\n    const rfunc = relations[relation.type]\n      || fail(`Invalid \"${relation.type}\" relation type specified for ${name} relation in ${table} table`);\n    return await rfunc(this, relation);\n  }\n}\n\nexport default Record;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 319,
    "kind": "class",
    "name": "Record",
    "memberof": "src/Record.js",
    "static": true,
    "longname": "src/Record.js~Record",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Record}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 320,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 321,
    "kind": "member",
    "name": "table",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#table",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "member",
    "name": "database",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#database",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "row",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#row",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "member",
    "name": "relations",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#relations",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "member",
    "name": "config",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#config",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "update",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#update",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#delete",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "member",
    "name": "deleted",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#deleted",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "assertNotDeleted",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#assertNotDeleted",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "action",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "relation",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#relation",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "initRelation",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#initRelation",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "file",
    "name": "src/Relation/many.js",
    "content": "export const many = async (record, spec={}) => {\n  const lkey  = spec.from;\n  const rkey  = spec.to;\n  const order = spec.order;\n  let where   = spec.where   || { };\n  if (lkey && rkey) {\n    where[rkey] = record.row[lkey];\n  }\n  const options = order ? { order } : { };\n  if (spec.debug) {\n    console.log('many() relation: ', spec);\n    console.log('many() relation table: ', spec.table);\n    console.log('many() relation where: ', where);\n  }\n  const table = await record.database.table(spec.table);\n  return await table.allRecords(where, options);\n}\n\nexport default many\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/many.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 333,
    "kind": "function",
    "name": "many",
    "memberof": "src/Relation/many.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/many.js~many",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{many}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "file",
    "name": "src/Relation/one.js",
    "content": "export const one = async (record, spec={}) => {\n  // console.log('relation:one record: ', record);\n  // console.log('relation:one spec: ', spec);\n  const lkey  = spec.from;\n  const rkey  = spec.to;\n  let where   = spec.where || { };\n  if (lkey && rkey) {\n    where[rkey] = record.row[lkey];\n  }\n  if (spec.debug) {\n    console.log('one() relation: ', spec);\n    console.log('one() relation table: ', spec.table);\n    console.log('one() relation where: ', where);\n  }\n  const table = await record.database.table(spec.table);\n  return await table.oneRecord(where);\n}\n\nexport default one",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/one.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 335,
    "kind": "function",
    "name": "one",
    "memberof": "src/Relation/one.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/one.js~one",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{one}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "file",
    "name": "src/Table.js",
    "content": "import Queries from \"./Queries.js\";\nimport Record from \"./Record.js\";\nimport recordProxy from \"./Proxy/Record.js\";\nimport { fail, firstValue, isArray, noValue, splitList } from \"@abw/badger-utils\";\nimport { prepareColumns, prepareKeys } from \"./Utils/Columns.js\";\nimport { throwColumnValidationError, unexpectedRowCount } from \"./Utils/Error.js\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\n\nexport class Table {\n  constructor(database, config) {\n    this.config        = this.configure(config) || config;\n    this.database      = database || fail(\"No database specified\");\n    this.engine        = database.engine;\n    this.table         = config.table;\n    this.columns       = prepareColumns(config);\n    this.readonly      = Object.keys(this.columns).filter( key => this.columns[key].readonly );\n    this.required      = Object.keys(this.columns).filter( key => this.columns[key].required );\n    this.keys          = prepareKeys(config, this.columns);\n    this.id            = config.id;\n    this.recordClass   = config.recordClass || Record;\n    this.recordConfig  = config.recordConfig;\n    this.fragments     = this.prepareFragments(config);\n    this.relations     = config.relations || { };\n    this.queries       = new Queries({ ...config, debugPrefix: `Queries:${this.table}` });\n\n    // method aliases\n    this.insertRow     = this.insertOneRow;\n    this.insertRows    = this.insertAllRows;\n    this.insertRecord  = this.insertOneRecord;\n    this.insertRecords = this.insertAllRecords;\n    this.updateRow     = this.updateOneRow;\n    this.updateRows    = this.updateAllRows;\n    addDebugMethod(this, 'table', { debugPrefix: `Table:${this.table}` }, config);\n  }\n  configure(config) {\n    return config;\n  }\n  prepareFragments(config) {\n    const quote       = this.database.quote.bind(this.database);\n    const fragments   = config.fragments ||= { };\n    fragments.table   = quote(this.table);\n    fragments.columns = Object.values(this.columns).map(\n      spec => quote(spec.tableColumn)\n    ).join(', ');\n    return fragments;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Column validation\n  //-----------------------------------------------------------------------------\n  checkColumnNames(names) {\n    const table = this.table;\n    splitList(names).forEach(\n      column => this.columns[column]\n          || throwColumnValidationError('unknown', { column, table })\n    )\n  }\n  checkColumns(data={}, cols=[], vals=[], options={}) {\n    const table = this.table;\n    // check that all the values supplied correspond to valid columns\n    Object.keys(data).forEach(\n      column => {\n        const spec = this.columns[column]\n          || throwColumnValidationError('unknown', { column, table });\n        if (options.writable && spec.readonly) {\n          throwColumnValidationError('readonly', { column, table });\n        }\n        // cols.push(options.tableColumn ? spec.tableColumn : spec.column);\n        cols.push(spec.column);\n        vals.push(data[column])\n      }\n    )\n    return [cols, vals];\n  }\n  checkWritableColumns(data, cols=[], vals=[]) {\n    return this.checkColumns(data, cols, vals, { writable: true })\n  }\n  checkWhereColumns(...args) {\n    return this.checkColumns(...args)\n  }\n  checkRequiredColumns(data) {\n    const table = this.table;\n    this.required.forEach(\n      column => {\n        if (noValue(data[column])) {\n          throwColumnValidationError('required', { column, table });\n        }\n      }\n    );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Engine methods\n  //-----------------------------------------------------------------------------\n  query(name) {\n    return this.queries.query(name);\n  }\n  run(query, params, options) {\n    this.debugData(\"run()\", { query, params, options });\n    return this.engine.run(this.query(query), params, options)\n  }\n  any(query, params, options) {\n    this.debugData(\"any()\", { query, params, options });\n    return this.engine.any(this.query(query), params, options)\n  }\n  all(query, params, options) {\n    this.debugData(\"all()\", { query, params, options });\n    return this.engine.all(this.query(query), params, options)\n  }\n  one(query, params, options) {\n    this.debugData(\"one()\", { query, params, options });\n    return this.engine.one(this.query(query), params, options)\n  }\n\n  //-----------------------------------------------------------------------------\n  // Basic queries - insert\n  //-----------------------------------------------------------------------------\n  async insert(data, options) {\n    return isArray(data, options)\n      ? this.insertAllRows(data, options)\n      : this.insertOneRow(data, options)\n  }\n  async insertOneRow(data, options={}) {\n    this.debugData(\"insertOneRow()\", { data, options });\n    const [cols, vals] = this.checkWritableColumns(data);\n    this.checkRequiredColumns(data);\n    const insert = await this.engine.insert(this.table, cols, vals, this.keys);\n    return options.reload || options.record\n      ? this.insertReload(data, insert, options)\n      : insert;\n  }\n  async insertAllRows(data, options) {\n    this.debugData(\"insertAllRows()\", { data, options });\n    let rows = [ ];\n    for (const row of data) {\n      rows.push(await this.insertOneRow(row, options));\n    }\n    return rows;\n  }\n  async insertOneRecord(data, options={}) {\n    this.debugData(\"insertOneRecord()\", { data, options });\n    return this.insertOneRow(data, { ...options, record: true })\n  }\n  async insertAllRecords(data, options={}) {\n    this.debugData(\"insertAllRecords()\", { data, options });\n    return this.insertAllRows(data, { ...options, record: true })\n  }\n  //-----------------------------------------------------------------------------\n  // update\n  //-----------------------------------------------------------------------------\n  prepareUpdate(set, where) {\n    const [dcols, dvals] = this.checkWritableColumns(set);\n    const [wcols, wvals] = this.checkWhereColumns(where);\n    return [dcols, dvals, wcols, wvals];\n  }\n  async update(...args) {\n    return this.updateAllRows(...args);\n  }\n  async updateOneRow(set, where, options={}) {\n    this.debugData(\"updateOneRow()\", { set, where, options });\n    const args = this.prepareUpdate(set, where);\n    const update = await this.engine.update(this.table, ...args);\n    if (update.changes !== 1) {\n      return unexpectedRowCount(update.changes, 'updated');\n    }\n    return options.reload\n      ? this.updateReload(set, where)\n      : update;\n  }\n  async updateAnyRow(set, where, options={}) {\n    this.debugData(\"updateAnyRow()\", { set, where, options });\n    const args = this.prepareUpdate(set, where);\n    const update = await this.engine.update(this.table, ...args);\n    if (update.changes > 1) {\n      return unexpectedRowCount(update.changes, 'updated');\n    }\n    return options.reload\n      ? update.changes === 1\n        ? this.updateReload(set, where)\n        : undefined\n      : update;\n  }\n  async updateAllRows(set, where, options={}) {\n    this.debugData(\"updateAllRows()\", { set, where, options });\n    const args   = this.prepareUpdate(set, where);\n    const update = await this.engine.update(this.table, ...args);\n    // return update;\n    //let rows = [ ];\n    //for (const row of data) {\n    //  rows.push(await this.insertOne(row, options));\n    //}\n    //return rows;\n    return options.reload\n      ? fail(\"Cannot reload multiple updated rows\")\n      : update;\n  }\n\n  //-----------------------------------------------------------------------------\n  // delete\n  //-----------------------------------------------------------------------------\n  async delete(where) {\n    this.debugData(\"delete()\", { where });\n    const [cols, vals] = this.checkWhereColumns(where);\n    return this.engine.delete(this.table, cols, vals);\n  }\n\n  //-----------------------------------------------------------------------------\n  // oneRow(), anyRow() and allRows()\n  //-----------------------------------------------------------------------------\n  prepareFetch(where, params) {\n    params.columns ||= Object.keys(this.columns);\n    this.checkColumnNames(params.columns);\n    return this.checkWhereColumns(where);\n  }\n  async oneRow(where, options={}) {\n    this.debugData(\"oneRow()\", { where, options });\n    const params = { ...options };\n    const [wcols, wvals] = this.prepareFetch(where, params);\n    const row = await this.engine.selectOne(this.table, wcols, wvals, params);\n    return options.record\n      ? this.record(row)\n      : row;\n  }\n  async anyRow(where, options={}) {\n    this.debugData(\"anyRow()\", { where, options });\n    const params = { ...options };\n    const [wcols, wvals] = this.prepareFetch(where, params);\n    const row = await this.engine.selectAny(this.table, wcols, wvals, params);\n    return row\n      ? options.record\n        ? this.record(row)\n        : row\n      : undefined;\n  }\n  async allRows(where, options={}) {\n    this.debugData(\"allRows()\", { where, options });\n    const params = { ...options };\n    const [wcols, wvals] = this.prepareFetch(where, params);\n    const rows = await this.engine.selectAll(this.table, wcols, wvals, params);\n    return options.record\n      ? this.records(rows)\n      : rows;\n  }\n\n  //-----------------------------------------------------------------------------\n  // oneRecord(), anyRecord() and allRecords()\n  //-----------------------------------------------------------------------------\n  async oneRecord(where, options={}) {\n    this.debugData(\"oneRecord()\", { where, options });\n    return this.oneRow(where, { ...options, record: true });\n  }\n  async anyRecord(where, options={}) {\n    this.debugData(\"anyRecord()\", { where, options });\n    return this.anyRow(where, { ...options, record: true });\n  }\n  async allRecords(where, options={}) {\n    this.debugData(\"allRecords()\", { where, options });\n    return this.allRows(where, { ...options, record: true });\n  }\n\n  builder() {\n    return this.database.builder();\n  }\n  select(...args) {\n    return this.builder().from(this.table).select(...args);\n  }\n  // EEK!  this.columns() is already defined\n  //columns(...args) {\n  //  return this.builder().from(this.table).columns(...args);\n  //}\n\n  tableFragments() {\n    return this.tableFragments\n  }\n  identity(data) {\n    return this.keys.reduce(\n      (result, key) => {\n        result[key] = data[key]\n        return result\n      },\n      {}\n    );\n  }\n  async insertReload(input, output, options={}) {\n    // For insert queries where the input data is used to run the query,\n    // and the output data is returned from the query. We should have\n    // values for each of this.keys because they should always be\n    // either specified in the input data, or returned by the database\n    const fetch = { };\n    this.keys.map(\n      key => fetch[key] = firstValue(output[key], input[key])\n    );\n    return options.record\n      ? this.oneRecord(fetch)\n      : this.oneRow(fetch);\n  }\n  async updateReload(set, where) {\n    // For update queries things are a little more complicated.  In the\n    // usual case we can reload the rows using the original selection\n    // criteria (where).  But we might have done an update which changes\n    // that selection criteria (set), so we should use those values instead.\n    const fetch = { };\n    Object.keys(where).map(\n      key => fetch[key] = firstValue(set[key], where[key])\n    );\n    return this.oneRow(fetch);\n  }\n  newRecord(row) {\n    return recordProxy(\n      new this.recordClass(this, row, this.recordConfig)\n    );\n  }\n  record(row) {\n    this.debugData(\"record()\", { row });\n    return Promise.resolve(\n      this.newRecord(row)\n    );\n  }\n  records(rows) {\n    this.debugData(\"records()\", { rows });\n    return Promise.resolve(\n      rows.map(\n        row => this.newRecord(row)\n      )\n    );\n  }\n}\n\nexport default Table;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Table.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 337,
    "kind": "class",
    "name": "Table",
    "memberof": "src/Table.js",
    "static": true,
    "longname": "src/Table.js~Table",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Table}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 338,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 339,
    "kind": "member",
    "name": "config",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#config",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "database",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#database",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#engine",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "member",
    "name": "table",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#table",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "member",
    "name": "columns",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#columns",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "readonly",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#readonly",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "member",
    "name": "required",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#required",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "member",
    "name": "keys",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#keys",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "member",
    "name": "id",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#id",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "recordClass",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#recordClass",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "recordConfig",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#recordConfig",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "fragments",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#fragments",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "member",
    "name": "relations",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#relations",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "member",
    "name": "queries",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#queries",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "member",
    "name": "insertRow",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#insertRow",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "insertRows",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#insertRows",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "member",
    "name": "insertRecord",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#insertRecord",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "insertRecords",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#insertRecords",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "updateRow",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#updateRow",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "updateRows",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#updateRows",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#configure",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "method",
    "name": "prepareFragments",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#prepareFragments",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "method",
    "name": "checkColumnNames",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkColumnNames",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "names",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "checkColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkColumns",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "cols",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "vals",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "checkWritableColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkWritableColumns",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "cols",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "vals",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "checkWhereColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkWhereColumns",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "checkRequiredColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkRequiredColumns",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "query",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#query",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "run",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#run",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "any",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#any",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "all",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#all",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "one",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#one",
    "access": "public",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "insert",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insert",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "insertOneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertOneRow",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "insertAllRows",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertAllRows",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "method",
    "name": "insertOneRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertOneRecord",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "insertAllRecords",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertAllRecords",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "prepareUpdate",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#prepareUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "update",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#update",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 378,
    "kind": "method",
    "name": "updateOneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateOneRow",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "updateAnyRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateAnyRow",
    "access": "public",
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "updateAllRows",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateAllRows",
    "access": "public",
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#delete",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "prepareFetch",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#prepareFetch",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "oneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#oneRow",
    "access": "public",
    "description": null,
    "lineNumber": 215,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "anyRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#anyRow",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "allRows",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#allRows",
    "access": "public",
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "oneRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#oneRecord",
    "access": "public",
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "anyRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#anyRecord",
    "access": "public",
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "allRecords",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#allRecords",
    "access": "public",
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "builder",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#builder",
    "access": "public",
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "select",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#select",
    "access": "public",
    "description": null,
    "lineNumber": 264,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "tableFragments",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#tableFragments",
    "access": "public",
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "identity",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#identity",
    "access": "public",
    "description": null,
    "lineNumber": 275,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "insertReload",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertReload",
    "access": "public",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      },
      {
        "name": "output",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "updateReload",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateReload",
    "access": "public",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "newRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#newRecord",
    "access": "public",
    "description": null,
    "lineNumber": 308,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "record",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#record",
    "access": "public",
    "description": null,
    "lineNumber": 313,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "records",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#records",
    "access": "public",
    "description": null,
    "lineNumber": 319,
    "undocument": true,
    "params": [
      {
        "name": "rows",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "file",
    "name": "src/Tables.js",
    "content": "import { isFunction } from \"@abw/badger-utils\";\n\nexport class Tables {\n  constructor(tables={}) {\n    this.tables = tables;\n  }\n  table(name) {\n    const config = this.tables[name];\n    if (isFunction(config) && isFunction(config.constructor)) {\n      // table config can be a class\n      return { tableClass: config };\n    }\n    return config;\n  }\n}\n\nexport default Tables;",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Tables.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 399,
    "kind": "class",
    "name": "Tables",
    "memberof": "src/Tables.js",
    "static": true,
    "longname": "src/Tables.js~Tables",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Tables}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 400,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Tables.js~Tables",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tables.js~Tables#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true
  },
  {
    "__docId__": 401,
    "kind": "member",
    "name": "tables",
    "memberof": "src/Tables.js~Tables",
    "static": false,
    "longname": "src/Tables.js~Tables#tables",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "method",
    "name": "table",
    "memberof": "src/Tables.js~Tables",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tables.js~Tables#table",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "file",
    "name": "src/Utils/Columns.js",
    "content": "import { fail, isArray, isObject, isString, objMap, splitList } from \"@abw/badger-utils\";\nimport { bitSplitter, defaultIdColumn } from \"../Constants.js\";\nimport { throwColumnValidationError } from \"./Error.js\";\n\n\n/**\n * Function to prepare column definitions for a table.  If the columns specified\n * are a string of whitespace delimited tokens then they are first split into an\n * array.  An array is converted to a hash object by splitting each item on the\n * first colon, e.g. `id:required` has the column name `id` and flags of `required`.\n * Each value is then converted to an object, e.g. `required` becomes `{ required: true }`.\n * Then end result is an object where the keys are the column names and corresponding\n * values are objects containing any flags defined for the column.\n * @param {!Object} schema - scheme containing table properties\n * @param {!String} [schema.table] - the database table name\n * @param {String|Array|Object} [schema.columns] - the table columns\n * @return {Object} a column specification object\n * @example\n * const columns = prepareColumns({\n *   table:   'artists',\n *   columns: 'id name'\n * })\n * @example\n * const columns = prepareColumns({\n *   table:   'artists',\n *   columns: 'id:readonly name:required'\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: ['id:readonly', 'name:required']\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: {\n *     id:   'readonly',\n *     name: 'required'\n *   }\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: {\n *     id:   { readonly: true },\n *     name: { required: true }\n *   }\n * })\n */\nexport const prepareColumns = (schema) => {\n  const columns = schema.columns\n    || throwColumnValidationError('noColumns', { table: schema.table });\n\n  if (isString(columns)) {\n    return prepareColumnsString(columns, schema);\n  }\n  else if (isArray(columns)) {\n    return prepareColumnsArray(columns, schema);\n  }\n  else if (isObject(columns)) {\n    return prepareColumnsHash(columns, schema);\n  }\n  else {\n    return throwColumnValidationError('invalidColumns', { table: schema.table, columns });\n  }\n}\n\nconst prepareColumnsString = (columns, schema) => {\n  return prepareColumnsArray(splitList(columns), schema);\n}\n\nconst prepareColumnsArray = (columns, schema) => {\n  let index = { };\n  columns.forEach(\n    item => {\n      const bits  = item.split(bitSplitter);\n      const name  = bits.shift();\n      index[name] = prepareColumnBits(name, bits, schema);\n    }\n  )\n  return prepareColumnsHash(index, schema);\n}\n\nconst prepareColumnsHash = (columns, schema) => {\n  return objMap(\n    columns,\n    (value, name) => {\n      if (isString(value)) {\n        return prepareColumnBits(name, value.split(bitSplitter), schema)\n      }\n      else if (isObject(value)) {\n        // column name can be defined in column spec as 'column' in case\n        // the database column name doesn't match the name you want to use\n        const column = value.column || (value.column = name);\n        // tableColumn is the full \"table.column\"\n        value.tableColumn = schema.table + '.' + column;\n        return value;\n      }\n      else {\n        fail(`Invalid \"${name}\" columns specified in ${schema.table} table: ${value}`)\n      }\n    }\n  )\n}\n\n/**\n * @ignore\n * Internal function to convert an array of colon delimited parts from a column\n * specification string to an object.\n */\nconst prepareColumnBits = (name, bits, schema) => {\n  return bits.reduce(\n    (result, bit) => {\n      const kv = bit.split('=', 2);\n      const key = kv.shift();\n      result[key] = kv.length ? kv[0] : true;\n      return result\n    },\n    { column: name, tableColumn: schema.table + '.' + name }\n  );\n}\n\n\n/**\n * Function to determine the id and/or keys columns for a table.\n * If the keys are explicitly listed in the schema then they are used.\n * Otherwise it looks for each column that defines the `key` flag.\n * If the `id` column is set in the schema, or as an `id` flag on a\n * column then that is assumed to be both the id and single key.\n * If no keys or id is defined then we assume it's an `id` column.\n * @param {!Object} schema - scheme containing table properties\n * @param {!String} [schema.table] - the database table name\n * @param {Object} columns - the table columns\n * @return {Array} - an array of keys\n */\nexport const prepareKeys = (schema, columns={}) => {\n  let keys  = splitList(schema.keys);\n  const ids = Object.keys(columns).filter( key => columns[key].id );\n  if (ids.length > 1) {\n    return throwColumnValidationError('multipleIds', { table: schema.table });\n  }\n  if (keys.length === 0) {\n    keys = Object.keys(columns).filter( key => columns[key].key );\n  }\n  if (schema.id) {\n    keys.unshift(schema.id);\n  }\n  else if (ids.length) {\n    schema.id = ids[0];\n    keys.unshift(schema.id);\n  }\n  else if (keys.length === 0) {\n    schema.id = defaultIdColumn;\n    keys.unshift(schema.id);\n  }\n  return keys;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Columns.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 404,
    "kind": "function",
    "name": "prepareColumns",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{prepareColumns}",
    "description": "Function to prepare column definitions for a table.  If the columns specified\nare a string of whitespace delimited tokens then they are first split into an\narray.  An array is converted to a hash object by splitting each item on the\nfirst colon, e.g. `id:required` has the column name `id` and flags of `required`.\nEach value is then converted to an object, e.g. `required` becomes `{ required: true }`.\nThen end result is an object where the keys are the column names and corresponding\nvalues are objects containing any flags defined for the column.",
    "examples": [
      "const columns = prepareColumns({\n  table:   'artists',\n  columns: 'id name'\n})",
      "const columns = prepareColumns({\n  table:   'artists',\n  columns: 'id:readonly name:required'\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: ['id:readonly', 'name:required']\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: {\n    id:   'readonly',\n    name: 'required'\n  }\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: {\n    id:   { readonly: true },\n    name: { required: true }\n  }\n})"
    ],
    "lineNumber": 50,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "scheme containing table properties"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.table",
        "description": "the database table name"
      },
      {
        "nullable": null,
        "types": [
          "String",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.columns",
        "description": "the table columns"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a column specification object"
    }
  },
  {
    "__docId__": 405,
    "kind": "function",
    "name": "prepareColumnsString",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsString",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 406,
    "kind": "function",
    "name": "prepareColumnsArray",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsArray",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 407,
    "kind": "function",
    "name": "prepareColumnsHash",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsHash",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 408,
    "kind": "function",
    "name": "prepareColumnBits",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnBits",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 111,
    "ignore": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "bits",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "function",
    "name": "prepareKeys",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareKeys",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{prepareKeys}",
    "description": "Function to determine the id and/or keys columns for a table.\nIf the keys are explicitly listed in the schema then they are used.\nOtherwise it looks for each column that defines the `key` flag.\nIf the `id` column is set in the schema, or as an `id` flag on a\ncolumn then that is assumed to be both the id and single key.\nIf no keys or id is defined then we assume it's an `id` column.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "scheme containing table properties"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.table",
        "description": "the database table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "columns",
        "description": "the table columns"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "an array of keys"
    }
  },
  {
    "__docId__": 410,
    "kind": "file",
    "name": "src/Utils/Database.js",
    "content": "import { extract, hasValue, isString, remove } from \"@abw/badger-utils\";\nimport { invalid, missing } from \"./Error.js\";\n\n/**\n * @ignore\n * Regex to parse database string.\n */\nexport const databaseStringRegex = /^(\\w+):\\/\\/(?:(?:(\\w+)(?::(\\w+))?@)?(\\w+)(?::(\\d+))?\\/)?(\\w+)/;\n\n/**\n * @ignore\n * Lookup table mapping captures from above regex to configuration option.\n */\nexport const databaseStringElements = {\n  engine:   1,\n  user:     2,\n  password: 3,\n  host:     4,\n  port:     5,\n  database: 6,\n};\n\n/**\n * @ignore\n * Lookup table of aliases for configuration options.\n */\nexport const databaseAliases = {\n  username: 'user',\n  pass:     'password',\n  hostname: 'host',\n  file:     'filename',\n  name:     'database',\n};\n\n/**\n * Function to create and sanitize a database configuration.  If the argument\n * is a string then it is passed to {@link parseDatabaseString}.\n * @param {!(Object|String)} config - database connection string or configuration object\n * @param {!String} [config.engine] - database engine, one of `sqlite`, `mysql` or `postgres`\n * @param {?String} [config.username] - alias for `user` option\n * @param {?String} [config.user] - name of user to connect to database\n * @param {?String} [config.password] - password for user to connect to database\n * @param {?String} [config.pass] - alias for `password` option\n * @param {?String} [config.host] - database host name\n * @param {?String} [config.hostname] - alias for `host` option\n * @param {?String} [config.port] - database port\n * @param {?String} [config.database] - database name\n * @param {?String} [config.filename] - database filename for sqlite databases\n * @param {?String} [config.file] - alias for `filename` option\n * @return {Object} the database config object\n * @example\n * const config = databaseConfig('sqlite://dbfile.db')\n * @example\n * const config = databaseConfig('mysql://user:password@hostname:port//database')\n * @example\n * const config = databaseConfig('postgres://user:password@hostname:port//database')\n * @example\n * const config = databaseConfig({\n *   engine:   'sqlite',\n *   filename: 'dbfile.db'\n * })\n * @example\n * const config = databaseConfig({\n *   engine:   'postgres',\n *   database: 'musicdb',\n *   user:     'bobby',\n *   password: 'secret',\n *   host:     'mydbhost.com',\n *   port:     '5150'\n * })\n */\nexport const databaseConfig = config => {\n  if (config.env) {\n    Object.assign(config, configEnv(config.env, { prefix: config.envPrefix }))\n  }\n  let database = config.database || missing('database');\n\n  if (isString(database)) {\n    // parse connection string\n    config.database = database = parseDatabaseString(database);\n  }\n\n  // extract the engine name to top level config\n  config.engine ||= database.engine || missing('database.engine');\n  delete database.engine;\n\n  // fixup any aliases\n  Object.entries(databaseAliases).map(\n    ([key, value]) => {\n      if (hasValue(database[key])) {\n        database[value] ||= remove(database, key);\n      }\n    }\n  )\n\n  return config;\n}\n\nexport const configEnv = (env, options={}) => {\n  const prefix   = options.prefix || 'DATABASE'\n  const uscore   = prefix.match(/_$/) ? '' : '_';\n  const regex    = new RegExp(`^${prefix}${uscore}`);\n\n  // if there's an environment variable that exactly matches the prefix,\n  // e.g. DATABASE or MY_DATABASE then it's assumed to be a connection\n  // string.  Otherwise we extract all the environment variables that\n  // start with the prefix (and an underscore if there isn't already one)\n  // on the prefix), e.g. DATABASE_ENGINE, DATABASE_HOST, etc., and put\n  // them in an object\n  const database = env[prefix]\n    || extract(\n      env, regex,\n      { key: key => key.replace(regex, '').toLowerCase() }\n    );\n\n  return { database };\n}\n\n\n/**\n * Function to parse a database configuration string and return an object of\n * configuration options.\n * @param {!String} string - database connection string\n * @return {Object} a database config object parsed from the string\n * @example\n * config config = parseDatabaseString('postgresql://user:password@host:port/database')\n * @example\n * const config = parseDatabaseString('sqlite://filename.db')\n * @example\n * const config = parseDatabaseString('sqlite://:memory:')\n * @example\n * const config = parseDatabaseString('sqlite:memory')\n * @example\n */\nexport const parseDatabaseString = string => {\n  let config = { };\n  let match;\n\n  if (string.match(/^postgres(ql)?:/)) {\n    // special case for postgres which can handle a connectionString\n    // NOTE: we accept postgresql: or postgres: as prefixes and Do The\n    // Right Thing\n    config.engine = 'postgres';\n    config.connectionString = string.replace(/^postgres:/, 'postgresql:');\n  }\n  else if ((match = string.match(/^sqlite:\\/\\/(.*)/))) {\n    // special case for sqlite which only has a filename (or \":memory:\")\n    config.engine   = 'sqlite';\n    config.filename = match[1];\n  }\n  else if (string === 'sqlite:memory') {\n    // special case for sqlite allowing 'sqlite:memory' as short for 'sqlite://:memory:'\n    config.engine   = 'sqlite';\n    config.filename = ':memory:';\n  }\n  else if ((match = string.match(databaseStringRegex))) {\n    // all other cases (e.g. mysql)\n    Object.entries(databaseStringElements).map(\n      ([key, index]) => {\n        const value = match[index];\n        if (hasValue(value)) {\n          config[key] = value;\n        }\n      }\n    );\n  }\n  else {\n    invalid('database', string);\n  }\n  return config;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 411,
    "kind": "variable",
    "name": "databaseStringRegex",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseStringRegex",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseStringRegex}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "variable",
    "name": "databaseStringElements",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseStringElements",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseStringElements}",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "{\"engine\": number, \"user\": number, \"password\": number, \"host\": number, \"port\": number, \"database\": number}"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "variable",
    "name": "databaseAliases",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseAliases",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseAliases}",
    "description": "",
    "lineNumber": 27,
    "ignore": true,
    "type": {
      "types": [
        "{\"username\": string, \"pass\": string, \"hostname\": string, \"file\": string, \"name\": string}"
      ]
    }
  },
  {
    "__docId__": 414,
    "kind": "function",
    "name": "databaseConfig",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~databaseConfig",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseConfig}",
    "description": "Function to create and sanitize a database configuration.  If the argument\nis a string then it is passed to {@link parseDatabaseString}.",
    "examples": [
      "const config = databaseConfig('sqlite://dbfile.db')",
      "const config = databaseConfig('mysql://user:password@hostname:port//database')",
      "const config = databaseConfig('postgres://user:password@hostname:port//database')",
      "const config = databaseConfig({\n  engine:   'sqlite',\n  filename: 'dbfile.db'\n})",
      "const config = databaseConfig({\n  engine:   'postgres',\n  database: 'musicdb',\n  user:     'bobby',\n  password: 'secret',\n  host:     'mydbhost.com',\n  port:     '5150'\n})"
    ],
    "lineNumber": 72,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "database connection string or configuration object"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.engine",
        "description": "database engine, one of `sqlite`, `mysql` or `postgres`"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.username",
        "description": "alias for `user` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.user",
        "description": "name of user to connect to database"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.password",
        "description": "password for user to connect to database"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.pass",
        "description": "alias for `password` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.host",
        "description": "database host name"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.hostname",
        "description": "alias for `host` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.port",
        "description": "database port"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.database",
        "description": "database name"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.filename",
        "description": "database filename for sqlite databases"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.file",
        "description": "alias for `filename` option"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the database config object"
    }
  },
  {
    "__docId__": 415,
    "kind": "function",
    "name": "configEnv",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~configEnv",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{configEnv}",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "env",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "{\"database\": *}"
      ]
    }
  },
  {
    "__docId__": 416,
    "kind": "function",
    "name": "parseDatabaseString",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~parseDatabaseString",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{parseDatabaseString}",
    "description": "Function to parse a database configuration string and return an object of\nconfiguration options.",
    "examples": [
      "config config = parseDatabaseString('postgresql://user:password@host:port/database')",
      "const config = parseDatabaseString('sqlite://filename.db')",
      "const config = parseDatabaseString('sqlite://:memory:')",
      "const config = parseDatabaseString('sqlite:memory')",
      ""
    ],
    "lineNumber": 135,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "database connection string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a database config object parsed from the string"
    }
  },
  {
    "__docId__": 417,
    "kind": "file",
    "name": "src/Utils/Debug.js",
    "content": "import { addDebug, ANSIescape, ANSIreset } from \"@abw/badger\";\nimport { doNothing, fail, isBoolean, isObject } from \"@abw/badger-utils\";\n\n/**\n * @ignore\n * Default width for debugging prefix column.\n */\nconst debugWidth = 16;\n\n/**\n * @ignore\n * Default debugging options\n */\nexport let debug = {\n  database: {\n    debug:  false,\n    prefix: 'Database',\n    color:  'bright magenta',\n  },\n  engine: {\n    debug:  false,\n    prefix: 'Engine',\n    color:  'red',\n  },\n  queries: {\n    debug:  false,\n    prefix: 'Queries',\n    color:  'blue',\n  },\n  table: {\n    debug:  false,\n    prefix: 'Table',\n    color:  'bright cyan',\n  },\n  record: {\n    debug:  false,\n    prefix: 'Record',\n    color:  'green',\n  },\n  builder: {\n    debug:  false,\n    prefix: 'Builder',\n    color:  'yellow',\n  },\n  test: {\n    debug:  false,\n    prefix: 'Test',\n    color:  'green'\n  },\n}\n\n/**\n * @ignore\n * Function to throw an error for an invalid debug option\n */\nconst invalidDebugItem = item =>\n  fail(`Invalid debug item \"${item}\" specified`)\n\n/**\n * Function to set debugging options.  Each key in the `options` should be\n * one of the components that supports debugging: `database`, `engine`, `queries`,\n * `table` or `record`.  The corresponding values should be a boolean value to\n * enable or disable debugging for the option or an object containing a `debug`\n * flag, and optionally, a `prefix` and/or `color`.\n * @param {!Object} options - debugging options\n * @example\n * setDebug({ engine: true })\n * @example\n * setDebug({\n *   engine: {\n *     debug: true,\n *     prefix: 'Choo Choo!',\n *     color: 'green'\n *   }\n * })\n */\nexport const setDebug = options => {\n  Object.entries(options).map(\n    ([key, value]) => {\n      const set = debug[key] || invalidDebugItem(key);\n      if (isBoolean(value)) {\n        set.debug = value;\n      }\n      else if (isObject(value)) {\n        Object.assign(set, value);\n      }\n    }\n  )\n}\n\n/**\n * Function to get debugging options for one of the components that supports debugging:\n * `database`, `engine`, `queries`, `table` or `record`.  One or more additional\n * objects can be passed that contain further configuration options. The returned object\n * will contained a merged set of the defaults and those options.\n * @param {!String} name - debugging options\n * @param {...Object} configs - additional debugging options\n * @example\n * getDebug('engine')\n * @example\n * getDebug('engine', { debug: true })\n * @example\n * getDebug('engine', { debug: true, color: 'green' })\n * @example\n * getDebug('engine', { debug: true }, { color: 'green' })\n */\nexport const getDebug = (name, ...configs) => {\n  const defaults = debug[name] || invalidDebugItem(name);\n  return Object.assign(\n    {},\n    defaults,\n    ...configs\n  );\n}\n\n/**\n * Function to add the `debug()` and `debugData()` methods to an object.\n * `database`, `engine`, `queries`, `table` or `record`.  One or more additional\n * objects can be passed that contain further configuration options. The returned object\n * will contained a merged set of the defaults and those options.\n * @param {!Object} object - object to receive methods\n * @param {!String} name - name of component type\n * @param {...Object} configs - additional debugging options\n * @example\n * addDebugMethod(myObject, 'engine', { debug: true })\n * @example\n * getDebug(myObject, 'engine', { debug: true }, { color: 'green' })\n */\nexport const addDebugMethod = (object, name, ...configs) => {\n  const options = getDebug(name, ...configs);\n  const enabled = options.debug;\n  const prefix  = options.debugPrefix || options.prefix;\n  const color   = options.debugColor  || options.color;\n  const preline = prefix.length > debugWidth - 2\n    ? prefix + \"\\n\" + \"\".padEnd(debugWidth, '-') + '> '\n    : (prefix + ' ').padEnd(debugWidth, '-') + '> ';\n  addDebug(object, enabled, preline, color);\n  object.debugData = DataDebugger(enabled, preline, color);\n}\n\n/**\n * @ignore\n * Function to generate a debugData() method for the above.\n */\nfunction DataDebugger(enabled, prefix, color, length=debugWidth) {\n  return enabled\n    ? (message, data={}) => {\n        console.log(\n          '%s' + prefix + '%s' + message,\n          color ? ANSIescape(color) : '',\n          color ? ANSIreset() : ''\n        );\n        Object.entries(data).map(\n          ([key, value]) => console.log(\n            '%s' + key.padStart(length, ' ') + '%s:',\n            color ? ANSIescape(color) : '',\n            color ? ANSIreset() : '',\n            value\n          )\n        )\n      }\n    : doNothing;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Debug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 418,
    "kind": "variable",
    "name": "debugWidth",
    "memberof": "src/Utils/Debug.js",
    "static": true,
    "longname": "src/Utils/Debug.js~debugWidth",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "variable",
    "name": "debug",
    "memberof": "src/Utils/Debug.js",
    "static": true,
    "longname": "src/Utils/Debug.js~debug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{debug}",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "{\"database\": *, \"engine\": *, \"queries\": *, \"table\": *, \"record\": *, \"builder\": *, \"test\": *}"
      ]
    }
  },
  {
    "__docId__": 420,
    "kind": "function",
    "name": "invalidDebugItem",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~invalidDebugItem",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 56,
    "ignore": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 421,
    "kind": "function",
    "name": "setDebug",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~setDebug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{setDebug}",
    "description": "Function to set debugging options.  Each key in the `options` should be\none of the components that supports debugging: `database`, `engine`, `queries`,\n`table` or `record`.  The corresponding values should be a boolean value to\nenable or disable debugging for the option or an object containing a `debug`\nflag, and optionally, a `prefix` and/or `color`.",
    "examples": [
      "setDebug({ engine: true })",
      "setDebug({\n  engine: {\n    debug: true,\n    prefix: 'Choo Choo!',\n    color: 'green'\n  }\n})"
    ],
    "lineNumber": 77,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "debugging options"
      }
    ],
    "return": null
  },
  {
    "__docId__": 422,
    "kind": "function",
    "name": "getDebug",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~getDebug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{getDebug}",
    "description": "Function to get debugging options for one of the components that supports debugging:\n`database`, `engine`, `queries`, `table` or `record`.  One or more additional\nobjects can be passed that contain further configuration options. The returned object\nwill contained a merged set of the defaults and those options.",
    "examples": [
      "getDebug('engine')",
      "getDebug('engine', { debug: true })",
      "getDebug('engine', { debug: true, color: 'green' })",
      "getDebug('engine', { debug: true }, { color: 'green' })"
    ],
    "lineNumber": 107,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "debugging options"
      },
      {
        "nullable": null,
        "types": [
          "...Object"
        ],
        "spread": true,
        "optional": false,
        "name": "configs",
        "description": "additional debugging options"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 423,
    "kind": "function",
    "name": "addDebugMethod",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~addDebugMethod",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{addDebugMethod}",
    "description": "Function to add the `debug()` and `debugData()` methods to an object.\n`database`, `engine`, `queries`, `table` or `record`.  One or more additional\nobjects can be passed that contain further configuration options. The returned object\nwill contained a merged set of the defaults and those options.",
    "examples": [
      "addDebugMethod(myObject, 'engine', { debug: true })",
      "getDebug(myObject, 'engine', { debug: true }, { color: 'green' })"
    ],
    "lineNumber": 129,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "object to receive methods"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of component type"
      },
      {
        "nullable": null,
        "types": [
          "...Object"
        ],
        "spread": true,
        "optional": false,
        "name": "configs",
        "description": "additional debugging options"
      }
    ],
    "return": null
  },
  {
    "__docId__": 424,
    "kind": "function",
    "name": "DataDebugger",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~DataDebugger",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 145,
    "ignore": true,
    "params": [
      {
        "name": "enabled",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      },
      {
        "name": "color",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "debugWidth",
        "defaultValue": "debugWidth"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "file",
    "name": "src/Utils/Error.js",
    "content": "import { fail } from \"@abw/badger-utils\"\nimport { format } from \"./Format.js\"\n\n//-----------------------------------------------------------------------------\n// General purpose error messages\n//-----------------------------------------------------------------------------\n/**\n * Function to throw a generic error used to report a missing configration item.\n * The error message will be of the form `No \"XXX\" specified`.\n * @param {!String} item - the name of the missing item\n * @example\n * missing('badger');   // throws error: No \"badger\" specified\n */\nexport const missing = (item) =>\n  fail(`No \"${item}\" specified`)\n\n/**\n * Function to throw a generic error used to report an invalid configration item.\n * The error message will be of the form `Invalid \"XXX\" specified: YYY`.\n * @param {!String} item - the name of the invalid item\n * @param value - the value of the invalid item\n * @example\n * invalid('badger', 99);   // throws error: Invalid \"badger\" specified: 99\n */\nexport const invalid = (item, value) =>\n  fail(`Invalid \"${item}\" specified: ${value}`)\n\n/**\n * Function to throw a generic error reporting that a method is not implemented.\n * This is used in base classes (e.g. {@link Engine}) where subclasses are\n * required to implement the method.\n * The error message will be of the form `METHOD is not implemented in MODULE`.\n * @param {!String} method - the name of the method\n * @param {!String} module - the name of the module\n * @example\n * notImplemented('wibble', 'FrussetPouch');  // throws error: wibble is not implemented in FrussetPouch\n */\nexport const notImplemented = (method, module) =>\n  fail(`${method} is not implemented in ${module}`)\n\n/**\n * Currying function used to generate a function that calls {@link notImplemented}\n * with the module name pre-defined.\n * @param {!String} module - the name of the module\n * @example\n * const thrower = notImplementedInModule('FrussetPouch');\n * throws('wibble');  // throws error: wibble is not implemented in FrussetPouch\n */\nexport const notImplementedInModule = module => method =>\n  notImplemented(method, module)\n\n/**\n * Wrapper around {@link notImplementedInModule} which provides a\n * more explicit error message for base classes.\n * @param {!String} module - the name of the module\n * @example\n * const thrower = notImplementedInModule('FrussetPouch');\n * throws('wibble');  // throws error: wibble is not implemented in the FrussetPouch base class\n */\nexport const notImplementedInBaseClass = module =>\n  notImplementedInModule(`the ${module} base class`)\n\n//-----------------------------------------------------------------------------\n// Custom error classes\n//-----------------------------------------------------------------------------\n/**\n * Error class for generating custom errors.\n */\nexport class CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n/**\n * Error class for reporting unexpected number of rows returned by a\n * database query.\n */\nexport class UnexpectedRowCount extends CustomError { }\n\n/**\n * Error class for reporting columns validation errors, e.g. when\n * attempting to update a `readonly` column.\n */\nexport class ColumnValidationError extends CustomError { }\n\n/**\n * Error class for reporting validation errors when inserting a row.\n */\nexport class InsertValidationError extends CustomError { }\n\n/**\n * Error class for reporting attempts to update a deleted record.\n */\nexport class DeletedRecordError extends CustomError { }\n\n/**\n * Error class for reporting query builder errors\n */\nexport class QueryBuilderError extends CustomError { }\n\n/**\n * Function for throwing a {@link UnexpectedRowCount} error when multiple\n * rows were returned or updated when only one was expected.\n * @param {!Integer} n - the number of rows encountered\n * @param {String} [action=returned] - the action that was being performed.\n * @example\n * // throw UnexpectedRowCount error with message \"10 rows were returned when one was expected\"\n * unexpectedRowCount(10);\n * @example\n * // throw UnexpectedRowCount error with message \"10 rows were updated when one was expected\"\n * unexpectedRowCount(10, 'updated');\n */\nexport function unexpectedRowCount(n, action='returned') {\n  throw new UnexpectedRowCount(`${n} rows were ${action} when one was expected`)\n}\n\n/**\n * Function to contruct a function for throwing errors of a particular type\n * using message formats.  The function returned expects a format name and\n * an optional object containing values to insert into the message format.\n * @param {!Object} formats - an object mapping short names to message formats\n * @param {Error} [error=Error] - the error type\n * @example\n * const hurl = thrower({ oops => 'Unexpected <animal> encountered });\n * hurl('oops', 'badger');  // throws error: Unexpected badger encountered\n */\nexport const thrower = (formats, error=Error) =>\n  (fmt, data) => {\n    const message = format(\n      formats[fmt] || fail(\"Invalid message format: \", fmt),\n      data\n    );\n    throw new error(message)\n  }\n\n/**\n * Error throwing function for column validation errors.\n */\nexport const throwColumnValidationError = thrower(\n  {\n    unknown:        'Unknown \"<column>\" column in the <table> table',\n    readonly:       'The \"<column>\" column is readonly in the <table> table',\n    required:       'Missing required column \"<column>\" for the <table> table',\n    multipleIds:    'Multiple columns are marked as \"id\" in the <table> table',\n    noColumns:      'No \"columns\" specified for the <table> table',\n    invalidColumns: 'Invalid \"columns\" specified for the <table> table: <columns>',\n  },\n  ColumnValidationError\n)\n\n/**\n * Error throwing function for deleted record errors.\n */\nexport const throwDeletedRecordError = thrower(\n  {\n    action: 'Cannot <action> deleted <table> record #<id>',\n  },\n  DeletedRecordError\n)\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 426,
    "kind": "function",
    "name": "missing",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~missing",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{missing}",
    "description": "Function to throw a generic error used to report a missing configration item.\nThe error message will be of the form `No \"XXX\" specified`.",
    "examples": [
      "missing('badger');   // throws error: No \"badger\" specified"
    ],
    "lineNumber": 14,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "the name of the missing item"
      }
    ],
    "return": null
  },
  {
    "__docId__": 427,
    "kind": "function",
    "name": "invalid",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~invalid",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{invalid}",
    "description": "Function to throw a generic error used to report an invalid configration item.\nThe error message will be of the form `Invalid \"XXX\" specified: YYY`.",
    "examples": [
      "invalid('badger', 99);   // throws error: Invalid \"badger\" specified: 99"
    ],
    "lineNumber": 25,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "the name of the invalid item"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value of the invalid item"
      }
    ],
    "return": null
  },
  {
    "__docId__": 428,
    "kind": "function",
    "name": "notImplemented",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplemented",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplemented}",
    "description": "Function to throw a generic error reporting that a method is not implemented.\nThis is used in base classes (e.g. {@link Engine}) where subclasses are\nrequired to implement the method.\nThe error message will be of the form `METHOD is not implemented in MODULE`.",
    "examples": [
      "notImplemented('wibble', 'FrussetPouch');  // throws error: wibble is not implemented in FrussetPouch"
    ],
    "lineNumber": 38,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "the name of the method"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 429,
    "kind": "function",
    "name": "notImplementedInModule",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplementedInModule",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplementedInModule}",
    "description": "Currying function used to generate a function that calls {@link notImplemented}\nwith the module name pre-defined.",
    "examples": [
      "const thrower = notImplementedInModule('FrussetPouch');\nthrows('wibble');  // throws error: wibble is not implemented in FrussetPouch"
    ],
    "lineNumber": 49,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 430,
    "kind": "function",
    "name": "notImplementedInBaseClass",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplementedInBaseClass",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplementedInBaseClass}",
    "description": "Wrapper around {@link notImplementedInModule} which provides a\nmore explicit error message for base classes.",
    "examples": [
      "const thrower = notImplementedInModule('FrussetPouch');\nthrows('wibble');  // throws error: wibble is not implemented in the FrussetPouch base class"
    ],
    "lineNumber": 60,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 431,
    "kind": "class",
    "name": "CustomError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~CustomError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{CustomError}",
    "description": "Error class for generating custom errors.",
    "lineNumber": 69,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 432,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Utils/Error.js~CustomError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/Error.js~CustomError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true
  },
  {
    "__docId__": 433,
    "kind": "member",
    "name": "name",
    "memberof": "src/Utils/Error.js~CustomError",
    "static": false,
    "longname": "src/Utils/Error.js~CustomError#name",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "class",
    "name": "UnexpectedRowCount",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~UnexpectedRowCount",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{UnexpectedRowCount}",
    "description": "Error class for reporting unexpected number of rows returned by a\ndatabase query.",
    "lineNumber": 80,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 435,
    "kind": "class",
    "name": "ColumnValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~ColumnValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ColumnValidationError}",
    "description": "Error class for reporting columns validation errors, e.g. when\nattempting to update a `readonly` column.",
    "lineNumber": 86,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 436,
    "kind": "class",
    "name": "InsertValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~InsertValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{InsertValidationError}",
    "description": "Error class for reporting validation errors when inserting a row.",
    "lineNumber": 91,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 437,
    "kind": "class",
    "name": "DeletedRecordError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~DeletedRecordError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{DeletedRecordError}",
    "description": "Error class for reporting attempts to update a deleted record.",
    "lineNumber": 96,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 438,
    "kind": "class",
    "name": "QueryBuilderError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~QueryBuilderError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{QueryBuilderError}",
    "description": "Error class for reporting query builder errors",
    "lineNumber": 101,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 439,
    "kind": "function",
    "name": "unexpectedRowCount",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~unexpectedRowCount",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{unexpectedRowCount}",
    "description": "Function for throwing a {@link UnexpectedRowCount} error when multiple\nrows were returned or updated when only one was expected.",
    "examples": [
      "// throw UnexpectedRowCount error with message \"10 rows were returned when one was expected\"\nunexpectedRowCount(10);",
      "// throw UnexpectedRowCount error with message \"10 rows were updated when one was expected\"\nunexpectedRowCount(10, 'updated');"
    ],
    "lineNumber": 115,
    "params": [
      {
        "nullable": false,
        "types": [
          "Integer"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "the number of rows encountered"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "returned",
        "defaultRaw": "returned",
        "name": "action",
        "description": "the action that was being performed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 440,
    "kind": "function",
    "name": "thrower",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~thrower",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{thrower}",
    "description": "Function to contruct a function for throwing errors of a particular type\nusing message formats.  The function returned expects a format name and\nan optional object containing values to insert into the message format.",
    "examples": [
      "const hurl = thrower({ oops => 'Unexpected <animal> encountered });\nhurl('oops', 'badger');  // throws error: Unexpected badger encountered"
    ],
    "lineNumber": 129,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "formats",
        "description": "an object mapping short names to message formats"
      },
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Error",
        "defaultRaw": "Error",
        "name": "error",
        "description": "the error type"
      }
    ],
    "return": null
  },
  {
    "__docId__": 441,
    "kind": "variable",
    "name": "throwColumnValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~throwColumnValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwColumnValidationError}",
    "description": "Error throwing function for column validation errors.",
    "lineNumber": 141,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "variable",
    "name": "throwDeletedRecordError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~throwDeletedRecordError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwDeletedRecordError}",
    "description": "Error throwing function for deleted record errors.",
    "lineNumber": 156,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "file",
    "name": "src/Utils/Format.js",
    "content": "import { fail, noValue } from \"@abw/badger-utils\";\n\n/**\n * Function to format strings by inserting values into placeholder locations.\n * @param {!String} msg - the source string\n * @param {Object} data - data items to insert into the string\n * @returns {String} - the expanded string\n * @example\n * format('Hello <name>!', { name: 'World'});  // Hello World!\n */\nexport const format = (msg, data) =>\n  msg.replace(\n    /<(\\w+)>/g,\n    (_, key) => {\n      const val = data[key];\n      if (noValue(val)) {\n        fail(`Invalid variable expansion <${key}> in message format: ${msg}`);\n      }\n      return val;\n    }\n  );\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Format.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 444,
    "kind": "function",
    "name": "format",
    "memberof": "src/Utils/Format.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Format.js~format",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{format}",
    "description": "Function to format strings by inserting values into placeholder locations.",
    "examples": [
      "format('Hello <name>!', { name: 'World'});  // Hello World!"
    ],
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String} - the expanded string"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "the source string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "data items to insert into the string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the expanded string"
    }
  },
  {
    "__docId__": 445,
    "kind": "file",
    "name": "src/Utils/Relation.js",
    "content": "import { fail, hasValue, isString, noValue, remove } from \"@abw/badger-utils\";\n\nconst relationStringRegex = /^(\\w+)\\s*([-=]>)\\s*(\\w+)\\.(\\w+)$/;\nconst relationType = {\n  '->': 'one',\n  '=>': 'many'\n};\nconst relationAliases = {\n  localKey:   'from',\n  local_key:  'from',\n  remoteKey:  'to',\n  remote_key: 'to',\n  orderBy:    'order',\n  order_by:   'order',\n};\n\n/**\n * Function to prepare a relation definition.\n * @param {!String} table - the table name\n * @param {!String} name - the relation name\n * @param {!String|Object} config - the relation configuration\n * @return {Object} a relation specification object\n * @example\n * const relation = relationConfig(\n *   'artists', 'albums', 'id => albums.artist_id'\n * })\n * @example\n * const relation = relationConfig(\n *   'artists', 'albums',\n *   {\n *     from:  'id',\n *     type:  'many',\n *     table: 'albums',\n *     to:    'artist_id'\n *    }\n * )\n */\nexport const relationConfig = (table, name, config) => {\n  if (isString(config)) {\n    config = parseRelationString(config);\n  }\n  else if (isString(config.relation)) {\n    config = {\n      ...parseRelationString(config.relation),\n      ...config\n    }\n  }\n\n  // fix up any aliases\n  Object.entries(relationAliases).map(\n    ([key, value]) => {\n      if (hasValue(config[key])) {\n        config[value] ||= remove(config, key);\n      }\n    }\n  );\n\n  // check for missing parameters\n  if (! config.load) {\n    ['type', 'table', 'to', 'from'].forEach(\n      key => {\n        if (noValue(config[key])) {\n          fail(`Missing \"${key}\" in ${name} relation for ${table} table`);\n        }\n      }\n    );\n  }\n\n  // set the name\n  config.name = `${table}.${name}`;\n\n  return config;\n}\n\n/**\n * Function to parse a relation definition string\n * @param {!String} string - the relation definition string\n * @return {Object} a relation specification object\n * @example\n * const relation = parseRelationString(\n *   'id => albums.artist_id'\n * })\n */\nexport const parseRelationString = string => {\n  let match;\n  return ((match = string.match(relationStringRegex)))\n    ? {\n        from:  match[1],\n        type:  relationType[match[2]] || fail('Invalid type \"', match[2], '\" specified in relation: ', string),\n        table: match[3],\n        to:    match[4],\n      }\n    : fail(\"Invalid relation string specified: \", string);\n}",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Relation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 446,
    "kind": "variable",
    "name": "relationStringRegex",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationStringRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 447,
    "kind": "variable",
    "name": "relationType",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationType",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "{\"->\": string, \"=>\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 448,
    "kind": "variable",
    "name": "relationAliases",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationAliases",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{\"localKey\": string, \"local_key\": string, \"remoteKey\": string, \"remote_key\": string, \"orderBy\": string, \"order_by\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 449,
    "kind": "function",
    "name": "relationConfig",
    "memberof": "src/Utils/Relation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Relation.js~relationConfig",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{relationConfig}",
    "description": "Function to prepare a relation definition.",
    "examples": [
      "const relation = relationConfig(\n  'artists', 'albums', 'id => albums.artist_id'\n})",
      "const relation = relationConfig(\n  'artists', 'albums',\n  {\n    from:  'id',\n    type:  'many',\n    table: 'albums',\n    to:    'artist_id'\n   }\n)"
    ],
    "lineNumber": 38,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": "the table name"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the relation name"
      },
      {
        "nullable": false,
        "types": [
          "String",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "the relation configuration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a relation specification object"
    }
  },
  {
    "__docId__": 450,
    "kind": "function",
    "name": "parseRelationString",
    "memberof": "src/Utils/Relation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Relation.js~parseRelationString",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{parseRelationString}",
    "description": "Function to parse a relation definition string",
    "examples": [
      "const relation = parseRelationString(\n  'id => albums.artist_id'\n})"
    ],
    "lineNumber": 84,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "the relation definition string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a relation specification object"
    }
  },
  {
    "__docId__": 451,
    "kind": "file",
    "name": "src/Utils/Tags.js",
    "content": "export const sql = sql => ({ sql })",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Tags.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 452,
    "kind": "function",
    "name": "sql",
    "memberof": "src/Utils/Tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Tags.js~sql",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{sql}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# Badger Database\n\nThe is the documentation site for the `@abw/badger-database` Javascript library.\n\nIt is a simple but powerful database management tool that allows you to\nbuild database abstraction layers for your Javascript projects. It has\nsupport for accessing Postgres, MySQL and Sqlite databases.\n\nRead the [manual](manual) for a step-by-step look at the functionality provided.\n\nConsult the [API documentation](identifiers) for details of the various classes,\nmethods and other functions provided.\n\n",
    "longname": "/Users/abw/js/badger-database-js/docs/index.md",
    "name": "./docs/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@abw/badger-database\",\n  \"version\": \"1.1.4\",\n  \"description\": \"Javascript database abstraction layer\",\n  \"type\": \"module\",\n  \"main\": \"dist/badger-database.cjs.js\",\n  \"module\": \"dist/badger-database.esm.js\",\n  \"exports\": \"./dist/badger-database.esm.js\",\n  \"author\": \"Andy Wardley\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/abw/badger-database-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/abw/badger-database-js/issues\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup -c\",\n    \"dev\": \"rollup -c -w\",\n    \"lint\": \"eslint 'src/**/*'\",\n    \"docs:build\": \"esdoc\",\n    \"docs:serve\": \"serve docs\",\n    \"test\": \"ava --serial\",\n    \"pretest\": \"pnpm run build\"\n  },\n  \"keywords\": [\n    \"badger\",\n    \"database\",\n    \"sql\"\n  ],\n  \"devDependencies\": {\n    \"@itsjamie/esdoc-cli\": \"^0.5.0\",\n    \"@itsjamie/esdoc-core\": \"^0.5.0\",\n    \"@itsjamie/esdoc-importpath-plugin\": \"^0.5.0\",\n    \"@itsjamie/esdoc-inject-style-plugin\": \"^0.5.0\",\n    \"@itsjamie/esdoc-standard-plugin\": \"^0.5.0\",\n    \"@rollup/plugin-commonjs\": \"^11.0.1\",\n    \"@rollup/plugin-json\": \"^4.1.0\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"ava\": \"^4.3.0\",\n    \"better-sqlite3\": \"^7.6.2\",\n    \"dotenv\": \"^16.0.1\",\n    \"eslint\": \"^8.20.0\",\n    \"mysql2\": \"^2.3.3\",\n    \"pg\": \"^8.8.0\",\n    \"rollup\": \"^2\",\n    \"rollup-plugin-terser\": \"^7.0.2\",\n    \"sqlite3\": \"^5.1.1\"\n  },\n  \"dependencies\": {\n    \"@abw/badger\": \"^1.0.8\",\n    \"@abw/badger-utils\": \"^1.0.12\",\n    \"proxymise\": \"^1.0.2\",\n    \"tarn\": \"^3.0.2\"\n  }\n}\n",
    "longname": "/Users/abw/js/badger-database-js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "content": "# badger-database\n\n<img src=\"./images/badger2.svg\" width=\"300\"/>\n\nThis is the manual for the `badger-database` Javascript module.\n\n* [Installation](manual/installation.html) - installing the library\n* [Connecting](manual/connecting.html) - connecting to a database\n* [Basic Queries](manual/basic_queries.html) - performing basic SQL queries\n* [Named Queries](manual/named_queries.html) - defining named SQL queries for abstraction and reusability\n* [Query Fragments](manual/query_fragments.html) - defining named SQL fragments for embedding into queries\n* [Query Building](manual/query_builder.html) - building SQL queries programmatically\n* [Builder Method](manual/builder_method.html) - methods for building SQL queries\n* [Tables](manual/tables.html) - using tables to automatically generate basic queries\n* [Table Columns](manual/table_columns.html) - defining table columns\n* [Table Methods](manual/table_methods.html) - calling table methods\n* [Table Class](manual/table_class.html) - defining custom table classes\n* [Records](manual/records.html) - using records\n* [Record Methods](manual/record_methods.html) - calling record methods\n* [Record Class](manual/record_class.html) - defining custom record classes\n* [Relations](manual/relations.html) - defining relations between tables\n* [Model](manual/model.html) - accessing database tables in a simpler form\n* [Waiter](manual/waiter.html) - chaining together asynchronous operations\n* [Debugging](manual/debugging.html) - enabling debugging messages\n* [Extending](manual/extending.html) - extending badger-database to add your own functionality\n* [Limitations](manual/limitations.html) - coping with the limitations of badger-database\n* [Examples](manual/examples.html) - working examples using badger-database\n\n## Notes on Case Conventions\n\nThe Javascript convention is to use StudlyCaps for class names (e.g. `Artists`) and\ncamelCase for methods, function, variables, etc., (e.g. `albumTracks`).\n\nWhen it comes to database table and columns names you might want to adopt the same\nconvention.  That's fine.  However, be warned that many databases are case insensitive\nby default.  As a result you might find that the database you're using returns the\ndata with column names converted to lower case.  Most databases have an option to make\nit case sensitive so you might want to look into that.\n\nI prefer to avoid the problem altogether by defining my database tables and columns using\nsnake_case (e.g. `artists`, `artist_id`, `album_tracks`, etc). I typically use a number\nof other programming languages to access the same database in a project and many other\nlanguages (e.g. Rust, Perl, Python, etc.) use snake_case by convention.\n\nIn these examples I've adopted this convention because it's what works for me.  It doesn't\nbother me that I have to think in snake_case when I'm accessing row data, but camelCase\nwhen using method names.  In fact, I think it probably helps me to differentiate between\n\"raw\" data from the database and code.  You may disagree, and of course, you are free to\nadopt your own convention that does it differently.\n\n# Author\n\n[Andy Wardley](https://github.com/abw)\n",
    "longname": "/Users/abw/js/badger-database-js/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\nUse your favourite package manager to install the module\nfrom `@abw/badger-database`.  You should also install\nat least one of the database driver modules:\n\n* `pg` for Postgres\n* `mysql2` for Mysql\n* `better-sqlite3` for Sqlite.\n\n### npm\n\n    // postgres\n    npm install @abw/badger-database pg\n    // mysql\n    npm install @abw/badger-database mysql2\n    // sqlite\n    npm install @abw/badger-database better-sqlite3\n\n### pnpm\n\n    // postgres\n    pnpm add @abw/badger-database pg\n    // mysql\n    pnpm add @abw/badger-database mysql2\n    // sqlite\n    pnpm add @abw/badger-database better-sqlite\n\n### yarn\n\n    // postgres\n    yarn add @abw/badger-database pg\n    // mysql\n    yarn add @abw/badger-database mysql\n    // sqlite\n    yarn add @abw/badger-database better-sqlite\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/connecting.md",
    "name": "./manual/connecting.md",
    "content": "# Connecting\n\nThe `connect()` function is used to connect to a database.  It is the default\nexport from the `@abw/badger-database` module.\n\n```js\nimport connect from '@abw/badger-database'\n```\n\nYou can also use named imports.\n\n```js\nimport { connect } from '@abw/badger-database'\n```\n\nOr you can use `require()` if you're still using Common JS format.\n\n```js\nconst { connect } = require('@abw/badger-database')\n```\n\n## Connection String\n\nThe simplest way to connect to a database is using a connection string for the\n`database` parameter. This is a concept that should be familiar to Postgres users.\n\n```js\nconst db = await connect({\n  database: 'postgresql://user:password@hostname:5432/database'\n})\n```\n\nInternally we use the slightly shorter name of `postgres` (no `ql` at the end)\nfor the Postgres engine name.  To avoid any chance of confusion, we also support\nthis in the connection string and automatically \"correct\" it for you.\n\n```js\nconst db = await connect({\n  // 'postgres://...' works the same as 'postgresql://...'\n  database: 'postgres://user:password@hostname:5432/database'\n})\n```\n\nYou can use the same connection string format for Mysql databases:\n\n```js\nconst db = await connect({\n  database: 'mysql://user:password@hostname:3306/database'\n})\n```\n\nAnd also for Sqlite databases, although here the only parameter supported\nis the database filename.\n\n```js\nconst db = await connect({\n  database: 'sqlite://database'\n})\n```\n\nFor an in-memory Sqlite database, use `:memory:` as the database name:\n\n```js\nconst db = await connect({\n  database: 'sqlite://:memory:'\n})\n```\n\nOr if you find that a bit clunky, you can use the shortened version:\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory'\n})\n```\n\nMost of the elements are optional for Postgres and Mysql databases.\nHere are the minimal versions which assume the default host (`localhost`),\nport (`3306` for Mysql and `5432` for Postgres) and no username or password.\n\n```js\nconst db = await connect({\n  database: 'postgresql://database'\n})\n```\n\n```js\nconst db = await connect({\n  database: 'mysql://database'\n})\n```\n\n## Connection Parameters\n\nThe connection strings shown in the previous sections are short-hand versions\nfor the more verbose form.  If your connection parameters are stored in a file,\nloaded via an API call, or fetched in some other way then it may be more\nconvenient to use this form.\n\n```js\nconst db = await connect({\n  // \"postgres://badger:s3cr3t@dbhost.com:5433/animals\" is short for:\n  database: {\n    engine:   'postgres',   // or 'postgresql'\n    user:     'badger',\n    password: 's3cr3t',\n    host:     'dbhost.com',\n    port:     '5433',\n    database: 'animals',\n  }\n})\n```\n\nThe same configuration options apply to Mysql.  For Sqlite the only supported\noption is `filename`.\n\n```js\nconst db = await connect({\n  database: {\n    engine:   'sqlite',\n    filename: 'animals.db',\n  }\n})\n```\n\nYou can also use `:memory:` as the `filename` for an in-memory database.\n\n```js\nconst db = await connect({\n  database: {\n    engine:   'sqlite',\n    filename: ':memory:',\n  }\n})\n```\n\n## Connection Parameter Aliases\n\nI don't know about you, but whenever I'm writing the code to connect to a database there's\na good chance I'll get one of the parameter names wrong.  Is it `user` or `username`?\n`pass` or `password`? `host` or `hostname`? `file` or `filename`?\n\nOf course you could google it, but there's no need. You can specify any of the \"incorrect\"\nparameters and we'll automatically fix them for you.\n\nFor example, if you specify `file` instead of `filename` for a Sqlite database, we'll\nsilently correct it.\n\n```js\nconst db = await connect({\n  database: {\n    engine: 'sqlite',\n    file:   'animals.db',   // converted to 'filename'\n  }\n})\n```\n\nThis also just works:\n\n```js\nconst db = await connect({\n  database: {\n    engine:   'postgres',\n    database: 'animals',\n    user:     'badger',\n    pass:     's3cr3t',     // converted to 'password'\n    host:     'dbhost.com',\n    port:     '5433',\n  }\n})\n```\n\nAnd this works too:\n\n```js\nconst db = await connect({\n  database: {\n    engine:   'postgres',\n    database: 'animals',\n    username: 'badger',     // converted to 'user'\n    password: 's3cr3t',\n    hostname: 'dbhost.com', // converted to 'host'\n    port:     '5433',\n  }\n})\n```\n\nYou can also use `name` as an alias for `database`:\n\n```js\nconst db = await connect({\n  database: {\n    engine:   'postgres',\n    name:     'animals',\n  }\n})\n```\n\n## Environment Variables\n\nYou can configure the database using environment variables.\nA database connection string should be defined as the `DATABASE`\nenvironment variable.\n\nFor example, you could define `DATABASE` in a `.env` file:\n\n```bash\nDATABASE=sqlite:memory:\n```\n\nYou can load the environment variables from the `.env` file\nusing [dotenv](https://www.npmjs.com/package/dotenv) or a similar\nmodule. The environment variables will then be defined in `process.env`.\nPass these to the `connect` function as `env`.\n\n```js\nimport dotenv from 'dotenv'\nimport process from 'node:process'\nimport connect from '@abw/badger-database'\n\n// load the .env file\ndotenv.config();\n\nconst db = await connect({\n  env: process.env\n});\n```\n\nYou can also define different database parameters using the `DATABASE_`\nprefix.  For example, for a Sqlite in-memory database:\n\n```bash\nDATABASE_ENGINE=sqlite\nDATABASE_FILENAME=:memory:\n```\n\nOr for a Mysql database:\n\n```bash\nDATABASE_ENGINE=mysql\nDATABASE_NAME=animals\nDATABASE_USER=badger\nDATABASE_PASSWORD=s3cr3t\n```\n\nIf you want to use a different environment variable name or prefix, then\ndefine it using the `envPrefix` option.\n\n```js\nconst db = await connect({\n  env: process.env\n  envPrefix: 'MY_DB'\n});\n```\n\nThen you can define the database connection string like so:\n\n```\nMY_DB=sqlite:memory:\n```\n\nOr using separate environment variables like this:\n\n```bash\nMY_DB_ENGINE=mysql\nMY_DB_NAME=animals\nMY_DB_USER=badger\nMY_DB_PASSWORD=s3cr3t\n```\n\n## Pool Options\n\nThe Postgres and Mysql database engines use a connection pool for efficiency.\nBy default, the minimum number of connections is 2 and the maximum is 10.  You\ncan change these values using the `pool` option.\n\n```js\nconst db = await connect({\n  database: { ... },\n  pool: {\n    min: 5,\n    max: 20\n  }\n})\n```\n\nThe Sqlite engine uses [better-sqlite3](https://github.com/WiseLibs/better-sqlite3)\nwhich uses synchronous functions.  This is because Sqlite serialises all queries\nand there is nothing to gain (and the potential for problems) by using a connection\npool and/or asynchronous function (for further information about this from the author\nof better-sqlite3, see [here](https://github.com/WiseLibs/better-sqlite3/issues/32)).\n\nAs such, the pool is effectively disabled for Sqlite by setting the `min` and `max`\nvalues to 1.\n\n## Disconnecting\n\nWhen you're finished using the database you should call the `disconnect()` method on\nit.\n\n```js\ndb.disconnect()\n```",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/basic_queries.md",
    "name": "./manual/basic_queries.md",
    "content": "# Basic Queries\n\nIn these examples we'll look at some of the basic functionality of the\nlibrary using a database of users.\n\nThis first example shows how to connect to a database, create a table,\ninsert a row and then fetch it out again.\n\n```js\nimport connect from '@abw/badger-database'\n\nasync function main() {\n  // connect to a Sqlite database\n  const db = await connect({ database: 'sqlite://test.db' });\n\n  // create a table\n  await db.run(\n    `CREATE TABLE users (\n      id    INTEGER PRIMARY KEY ASC,\n      name  TEXT,\n      email TEXT\n    )`\n  );\n\n  // insert a row\n  const insert = await db.run(\n    'INSERT INTO users (name, email) VALUES (?, ?)',\n    ['Bobby Badger', 'bobby@badgerpower.com']\n  );\n  console.log(\"Inserted ID:\", insert.lastInsertRowid);\n\n  // fetch a row\n  const bobby = await db.one(\n    'SELECT * FROM users WHERE email=?',\n    ['bobby@badgerpower.com']\n  );\n  console.log(\"Fetched row:\", bobby);\n\n  // cleanup\n  db.disconnect();\n}\n\nmain()\n```\n\nNote that most of the database functions are asynchronous and return\npromises.  In these examples we've wrapped the code in an `async` function\ncalled `main()` so that we can use the `await` keyword to wait for requests\nto complete. You can, of course, use `.then(...)` if you prefer.\n\n```js\nimport connect from '@abw/badger-database'\n\nconnect({ database: 'sqlite://test.db' }).then(\n  db => {\n    db.run(\n      `CREATE TABLE users (\n        id    INTEGER PRIMARY KEY ASC,\n        name  TEXT,\n        email TEXT\n      )`\n    ).then(\n      () => db.run(\n        'INSERT INTO users (name, email) VALUES (?, ?)',\n        ['Bobby Badger', 'bobby@badgerpower.com']\n      )\n    ).then(\n      insert => console.log(\"Inserted ID:\", insert.lastInsertRowid)\n    ).then(\n      () => db.one(\n        'SELECT * FROM users WHERE email=?',\n        ['bobby@badgerpower.com']\n      )\n    ).then(\n      bobby => console.log(\"Fetched row:\", bobby)\n    ).then(\n      () => db.disconnect()\n    )\n  }\n);\n```\n\n## run(query, values, options)\n\nThe `run()` method is used to execute a query where you're not expecting\nto return any rows from the database.  However, the method does return some\ndata include the number of rows changed, and in the case of `INSERT` queries,\nthe generated id for the record.\n\nDifferent database engines return different values here.  For Sqlite it's\n`changes` for the number of rows affected and `lastInsertRowid` for the id\nof the insert row.  For Mysql it's `affectedRows` and `insertId`.  For\nPostgres it's `rowCount` and if you want to get the id then you must add\n`RETURNING id` to the end of the query.\n\nWe'll see in later examples using `tables` how the badger-database library\nautomatically standardises this response so that you always get back `changes`\nand `id` (or whatever your id column is called) regardless of the database\nengine.  But if you really can't wait until then, the trick is to pass a third\nargument to the `run()` method as an object containing the `sanitizeResult`\nkey set to a `true` value.  Then you will always get back `changes` and `id`\nfor all database engines.\n\n```js\n// insert a row\nconst insert = await db.run(\n  'INSERT INTO users (name, email) VALUES (?, ?)',\n  ['Bobby Badger', 'bobby@badgerpower.com'],\n  { sanitizeResult: true }\n);\nconsole.log(\"Rows changed:\", insert.changes);\nconsole.log(\"Inserted ID:\", insert.id);\n```\n\n## one(query, values, options)\n\nThe `one()` method should be used when you're expecting to fetch *exactly*\none row from the database.  The first argument is an SQL query string.  If\nyou  have any parameters to include in the query then they should be embedded\nin the SQL using placeholders (`?` for Mysql and Sqlite, `$1`, `$2`, `$3`, etc.,\nfor Postgres).  Then pass the parameter values in an array as the second\nargument.\n\n```js\nconst bobby = await db.one(\n  'SELECT * FROM users WHERE email=?',\n  ['bobby@badgerpower.com']\n);\nconsole.log(\"Fetched row:\", bobby);\n```\n\nThe `one()` method will throw an `UnexpectedRowCount` exception if no rows, or\nmore than one row is returned with a message of the form\n`N rows were returned when one was expected`.\n\n## any(query, values, options)\n\nThe `any()` method can be used if you want to get one row which may or may not exist.\n\n```js\nconst bobby = await db.any(\n  'SELECT * FROM users WHERE email=?',\n  ['bobby@badgerpower.com']\n);\nif (bobby) {\n  console.log(\"Fetched row:\", bobby);\n}\nelse {\n  console.log(\"Bobby Badger has gone missing!\");\n}\n```\n\n## all(query, values, options)\n\nThe `all()` method can be used to return multiple rows.\n\n```js\nconst bobbies = await db.all(\n  'SELECT * FROM users WHERE name=?',\n  ['Bobby Badger']\n);\nif (bobbies.length) {\n  console.log(\"Fetched %s users called 'Bobby Badger':\", bobbies.length);\n}\nelse {\n  console.log(\"There aren't any users called 'Bobby Badger'\");\n}\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/named_queries.md",
    "name": "./manual/named_queries.md",
    "content": "# Named Queries\n\nInstead of embedding SQL queries directly into your code, you can\ndefine them as named queries.  This allows you to hide away some of the\ndetails of the database implemenentation so that your application code\ncan be simpler and clearer.\n\nTo keep things simple, this example has all the code in one file,\nwhich isn't really hiding anything at all.  In practice, you would usually\nmove the database definition into a separate module.\n\n```js\nimport connect from '@abw/badger-database'\n\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  queries: {\n    createUsersTable:`\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY ASC,\n        name TEXT,\n        email TEXT\n      )`,\n    insertUser:\n      'INSERT INTO users (name, email) VALUES (?, ?)',\n    selectUserByEmail:\n      'SELECT * FROM users WHERE email=?'\n  }\n};\n\nasync function main() {\n  // connect to the database\n  const db = await connect(dbConfig);\n\n  // create the users table using a named query\n  await db.run('createUsersTable');\n\n  // insert a row using a named query\n  const insert = await db.run(\n    'insertUser',\n    ['Bobby Badger', 'bobby@badgerpower.com']\n  );\n  console.log(\"Inserted ID:\", insert.lastInsertRowid);\n\n  // fetch a row using a named query\n  const bobby = await db.one(\n    'selectUserByEmail',\n    ['bobby@badgerpower.com']\n  );\n  console.log(\"Fetched row:\", bobby);\n}\n\nmain()\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/query_fragments.md",
    "name": "./manual/query_fragments.md",
    "content": "# Query Fragments\n\nYou might want to define a number of different queries for fetching user\nrows using different search terms.  For example, to select a user by\n`email` or `name`.\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  queries: {\n    selectUserByEmail:\n      'SELECT * FROM users WHERE email=?',\n    selectUserByName:\n      'SELECT * FROM users WHERE name=?'\n  }\n};\n```\n\nTo avoid repetition, you can define named SQL `fragments` that can be embedded\ninto other queries.  Named fragments can be embedded into queries inside angle\nbrackets, e.g. `<fragmentName>`.\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  fragments: {\n    selectUser:\n      'SELECT * FROM users'\n  },\n  queries: {\n    selectUserByEmail:\n      '&lt;selectUser&gt; WHERE email=?',\n    selectUserByName:\n      '&lt;selectUser&gt; WHERE name=?'\n  }\n};\n```\n\nFragments can reference other fragments.  This can be useful when you're building\nmore complex queries, as shown in this somewhat contrived example:\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  fragments: {\n    selectUserCompany:\n      'SELECT users.*, companies.* FROM users',\n    joinUserCompany:\n      'JOIN companies on users.company_id=companies.id',\n    selectEmployee:\n      '&lt;selectUserCompany&gt; &lt;joinUserCompany&gt;',\n  },\n  queries: {\n    selectEmployeeByEmail:\n      '&lt;selectEmployee&gt; WHERE email=?',\n    selectEmployeeByName:\n      '&lt;selectEmployee&gt; WHERE name=?'\n  }\n};\n```\n\nYou can also embed fragments into ad-hoc queries passed to the\n`run()`, `one()`, `any()` and `all()` methods.  For example,\ngiven the above configuration you could write a custom query that\nincludes the `selectEmployee` fragment like so:\n\n```js\nconst badgers = await db.all(\n  '&lt;selectEmployee&gt; WHERE companies.name=?',\n  ['Badgers Inc.']\n);\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/query_builder.md",
    "name": "./manual/query_builder.md",
    "content": "# Query Builder\n\nThe philosophy of the badger-database library is that ORMs and\nSQL query generators are considered *Mostly Harmful*, especially\nif they're employed as an alternative to using SQL.  But that's\nnot to say that they don't have some benefits.\n\n* Correctness - automatically quoting table and column names\n\n* Flexibility - constructing queries out of sequence\n\n* Reusability - unlike some query builders, these are idempotent.\nYou can create a \"base\" query and then build new queries off it.\n\n* Syntactic sugar -\n\nBefore we get into too much detail, let's look at some examples.\n\n## Examples\n\nTODO: setup DB, define some tables, examples\n\nTODO: select() and columns() have changed.  select() is no longer\n\"magical\" in automatically scoping columns to the latest table.\nBut columns() is.\n\nNOTE: code has been updated since this was written so it will be\nwrong in places\n\n## Starting a Query Chain\n\nThe main database object has a `from()` method which allows you to\nstart a query by specifying a table you want to select from.  You can\nthen chain further operations like `select()` to specify the columns\nthat you want to select from the table.\n\n```js\nconst query = db\n  .from('users')\n  .select('id name');\n```\n\nYou can generate SQL for a query by calling the `sql()` method.\n\n```js\nconst sql = query.sql()\n```\n\nFor this query it generates the following SQL:\n\n```sql\nSELECT \"users\".\"id\", \"users\".\"name\"\nFROM \"users\"\n```\n\nNote how all the column and table names are correctly quoted to\navoid any potential conflicts with reserved words.\n\nThe `select()` method can take a string of whitespace delimited column\nnames and will \"Do The Right Thing\" to split them up into individual\ncolumn names.  These are then combined with the table name to avoid\nconflicts between the same column name in multiple tables.\n\nThis is an example of the syntactic sugar designed to make your life\nthat little bit easier when writing code.\n\nSpecifying the columns as `id name` is shorthand for either this:\n\n```js\nconst query = db\n  .from('users')\n  .select('id', 'name');\n```\n\nOr this:\n\n```js\nconst query = db\n  .from('users')\n  .select(['id', 'name']);\n```\n\nThey all do the same thing.  You can also put commas and optional whitespace\nbetween the items in one of these shorthand strings, e.g. `id,name` and\n`id, name` are both treated the same as `id name`.\n\nIf you want to include raw SQL in your query then you can define\nan object with a `sql` property:\n\n```js\nconst query = db\n  .from('users')\n  .select({ sql: 'id, name as user_name' });\n```\n\nThere's a shorthand syntax for this, too.  Import the `sql` function and\nuse it to create a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\n\nconst query = db\n  .from('users')\n  .select(sql`id, name as user_name`);\n```\n\nYou can specify multiple tables and select columns from each.  The\n`select()` method assumes that the columns belong to the table defined\nby the most recent `from()` method in the chain.\n\n```js\nconst query = db\n  .from('users')\n  .select('id name');\n  .from('posts')\n  .select('title');\n```\n\nThis will generate the following SQL:\n\n```sql\nSELECT \"users\".\"id\", \"users\".\"name\", \"posts\".\"title\"\nFROM \"users\", \"posts\"\n```\n\nNote that we probably need to add some more to this query (e.g. a\n`JOIN` or `WHERE` clause) to make it useful but it demonstrates the\npoint about how columns are scoped to the most recently defined table.\n\nYou can specify multiple tables in a `from()` method, but be warned that\nit will be the *last* one that the `select()` method uses to attach columns\nto.\n\n```js\nconst query = db\n  .from('users posts')\n  .select('title');\n```\n\nThis generates SQL that binds the `title` column to the `posts` table, because\n`posts` is the last table defined.\n\n```sql\nSELECT \"posts\".\"title\"\nFROM \"users\", \"posts\"\n```\n\n## Running Queries\n\nCall the `all()` method to fetch all rows matching a query.  It's an\nasynchronous method so you'll need to `await` the response (or use `.then(...)`\nif you prefer).\n\n```js\nconst rows = await db\n  .from('users')\n  .select('id name')\n  .all();\n```\n\nThe method returns an array of rows that match the query.\n\nThe `any()` method can be used to return a single row.\n\n```js\nconst row = await db\n  .from('users')\n  .select('id name')\n  .where('id')\n  .any([123]);\n```\n\nThe method will return a single row or `undefined` if it doesn't\nmatch a row.\n\nIf you're expecting to get one and only one row returned then use the\n`one()` method instead.  This will throw an error if the row isn't\nfound or if the query returns multiple rows.\n\nThe SQL query generated will use placeholders for any `where()` clauses\nincluded.\n\nFor example, this query:\n\n```js\nconst row = db\n  .from('users')\n  .select('id name')\n  .where('id')\n```\n\nWill generate a SQL query that looks like this:\n\n```sql\nSELECT \"users\".\"id\", \"users\".\"name\"\nFROM \"users\"\nWHERE \"users\".\"id\"=?\n```\n\nThe values for placeholders should be passed as an array to the `all()`, `any()`\nand `one()` methods.\n\nTODO: see [where()](#where-criteria-) for information about other ways to\ndefine values.\n\n#The `all()`, `any()` and `one()` methods will automatically provide the values\n#for the placeholders (`123` in this case) when the query is run.\n\n\n## Chainability\n\nOne important benefit of this implementation over some others is\nthat each step creates a new link in the chain that \"points back\"\nto the previous link that it was created from.  This allows you to\ncreate multiple different queries from links in a chain without\naffecting them.\n\n```js\nconst query0 = db.from('users');\nconst query1 = query0.select('id name');\nconst query2 = query0.select('name email');\n```\n\nHere `query0`, `query1` and `query2` are all separate query chains.\n\n\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/builder_methods.md",
    "name": "./manual/builder_methods.md",
    "content": "# Query Builder Methods\n\nThis page describes all the query builder methods.\n\nThey all work in a similar way with respect to the arguments\nthey accept.  The short form is to pass a string which may have\nsome additional processing applied to it (typically splitting\na whitespace delimited string into multiple tokens).  Where there\nare two, three or four possible arguments, an array can be passed.\nOr an object can be passed with explicit properties for the different\nparameters.\n\nAll the methods can generate raw SQL.  This can be specified by\npassing an object with a single `sql` property:\n\n```js\ndb\n  .select({ sql: 'COUNT(id) AS n' })\n```\n\nOr using the `sql` function to create a tagged template literal:\n\n```js\nimport { sql } from '@abw/badger-database'\n\ndb\n  .select(sql`COUNT(id) AS n`)\n```\n\nAll of the methods can be called multiple time, or passed multiple\narguments.  They both have the same effect.  Generally speaking,\nyou can call the methods in any order and the query builder will\ngenerate the SQL query with them in the correct order.\n\nFor the sake of brevity these examples assume that you've already\nconnected to a database and stored the connection in the `db` variable.\n\n```js\nimport connect from '@abw/badger-database'\n\nasync function main() {\n  const db = connect({ database: 'sqlite:memory' });\n\n  // ...examples would go here\n}\n```\n\nThe examples show the SQL generated by the fragment.  In many cases they're\nnot complete queries and we've omitted the final `.sql()` method call\nwhich is called internally to generate the SQL.\n\nIn these example we're assuming that the database is Sqlite which\nquotes table and columns names using double quotes, e.g. `\"user\".\"id\"`.\nFor Mysql the names will be quoted using backticks.  Examples that\nshow placeholders also assume Sqlite (and Mysql) which uses question\nmarks, e.g. `?`.  For Postgress the placeholders are of the form `$1`,\n`$2`, `$3`, etc.\n\n## select(columns)\n\nThis method is used to specify one or more columns that you want to\nselect.\n\n```js\ndb.select('id');\n// -> SELECT \"id\"\n```\n\nYou can specify multiple columns using the shorthand syntax as a\nstring of whitespace delimited table names.\n\n```js\ndb.select('id email');\n// -> SELECT \"id\", \"email\"\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit column names.\n\n```js\ndb.select('id, email');\n// -> SELECT \"id\", \"email\"\n```\n\nColumns can have the table name included in them.  Both the table\nand columns names will be automatically quoted.\n\n```js\ndb.select('user.id user.email');\n// -> SELECT \"user\".\"id\", \"user\".\"email\"\n```\n\nYou can specify `*` to select all columns.  This will not be quoted.\n\n```js\ndb.select('*');\n// -> SELECT *\n```\n\nYou can also use `*` to select all columns from a table.  The table name\nwill be automatically quoted but the asterisk will not.\n\n```js\ndb.select('users.*');\n// -> SELECT \"users\".*\n```\n\nYou can pass an object to the method containing the `columns` property.\nThe format for the value is either a single column name or multiple columns\ndelimited with whitespace or commas/whitespace, as shown in the previous\nexamples.\n\n```js\ndb.select({ columns: 'id email company.*' });\n// -> SELECT \"id\", \"email\", \"company\".*\n```\n\nYou can also define the `table` as a property to have the table name automatically\nadded to the column names.\n\n```js\ndb.select({ table: 'users', columns: 'id email' });\n// -> SELECT \"users\".\"id\", \"users\".\"email\"\n```\n\nThe `prefix` property can be used to automatically create aliases for the columns.\nThe prefix will be attached to the front of each column name.\n\n```js\ndb.select({ columns: 'id email', prefix: 'user_' });\n// -> SELECT \"id\" AS \"user_id\", \"email\" AS \"user_email\"\n```\n\nThis also works in conjunction with the `table` property.\n\n```js\ndb.select({ table: 'users', columns: 'id email', prefix: 'user_' });\n// -> SELECT \"users\".\"id\" AS \"user_id\", \"users\".\"email\" AS \"user_email\"\n```\n\nAn object can also contain a `column` item.  In this case it is assumed to\nbe a single column name is not split into separate columns.  The optional\n`as` property can be provided to create an alias for the column.\n\n```js\ndb.select({ column: 'email', as: 'email_address' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nThe `table` property can also be provided in this case.\n\n```js\ndb.select({ table: 'users', column: 'email', as: 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nOr you can include the table name in the column.\n\n```js\ndb.select({ column: 'users.email', as: 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nThe shorthand format for creating a column alias is to pass an Array of\neither two elements (the column name and alias) or three (the table name,\ncolumn name and alias).\n\n```js\ndb.select(['email', 'email_address' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\n```js\ndb.select(['users', 'email', 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nYou can use raw SQL to define the table columns.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb.select({ sql: '\"email\" AS \"email_address\"' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\ndb.select(sql`\"email\" AS \"email_address\"`);\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nYou can call the method multiple times.  The column names will all be\ncollected after the `SELECT` keyword.\n\n```js\ndb.select('id email').select({ table: 'companies', column: 'name', as: 'company_name' });\n// -> SELECT \"id\", \"email\", \"companies\".\"name\" AS \"company_name\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.select('id email', { table: 'companies', column: 'name', as: 'company_name' });\n// -> SELECT \"id\", \"email\", \"companies\".\"name\" AS \"company_name\"\n```\n\n## from(table)\n\nThis method is used to specify one or more tables that you want to\nselect from.\n\n```js\ndb.from('users');\n// -> FROM \"users\"\n```\n\nYou can specify multiple tables using the shorthand syntax as a\nstring of whitespace delimited table names.\n\n```js\ndb.from('users companies');\n// -> FROM \"users\", \"companies\"\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit table names.\n\n```js\ndb.from('users, companies');\n// -> FROM \"users\", \"companies\"\n```\n\nYou can pass an object to the method containing the `tables` property.\nThe format for the value is either a single table name or multiple tables\ndelimited with either whitespace or commas, as shown in the previous\nexamples.\n\n```js\ndb.from({ tables: 'users, companies' });\n// -> FROM \"users\", \"companies\"\n```\n\nAn object can also contain a `table` item.  In this case it is assumed to\nbe a single table name is not split into separate table names.  The optional\n`as` property can be provided to create an alias for the table.\n\n```js\ndb.from({ table: 'users', as: 'people' });\n// -> FROM \"users\" AS \"people\"\n```\n\nThe shorthand format for creating a table alias is to pass an Array of two\nelements: the table name and alias.\n\n```js\ndb.from(['users', 'people']);\n// -> FROM \"users\" AS \"people\"\n```\n\nYou can use raw SQL to define the table name.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb.from({ sql: '\"users\" AS \"people\"' });\n// -> FROM \"users\" AS \"people\"\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\ndb.from(sql`\"users\" AS \"people\"`);\n// -> FROM \"users\" AS \"people\"\n```\n\nYou can call the method multiple times.  The tables names will all be\ncollected after the `FROM` keyword.\n\n```js\ndb.from(['users', 'people']).from('companies').from({ table: 'employees' })\n// -> FROM \"users\" AS \"people\", \"companies\", \"employees\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.from(['users', 'people'], 'companies', { table: 'employees' })\n// -> FROM \"users\" AS \"people\", \"companies\", \"employees\"\n```\n\n## where(criteria)\n\nThis method can be used to specify the criteria for matching rows.\nYou can specify one or more columns that you want to match against.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where('id')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\"=?\n```\n\nThe query will be constructed with placeholders matching the specified\ncolumn or columns.\n\nValues for placeholders should be passed as an array to the\n[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.\n\n```js\nconst row = await db\n  .select('name email')\n  .from('users')\n  .where('id')\n  .one([12345])\n```\n\nYou can specify multiple columns using the shorthand syntax as a\nstring of whitespace delimited table names.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where('id name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\"=? AND \"name\"=?\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit column names.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where('id, name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\"=? AND \"name\"=?\n```\n\nColumns can have the table name included in them.  Both the table\nand columns names will be automatically quoted.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where('users.id')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"users\".\"id\"=?\n```\n\nYou can pass an object to the method mapping column names to their respective values.\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where({ id: 12345 })\n  .one()\n```\n\nThe query will still be constructed with placeholder values but all the values\nwill be collected and automatically provided to the\n[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.\n\nYou can pass additional values to those method to provide any additional values.\nBe warned that they will always be added *after* values specified in the query.\n\nThis will work as intended:\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where({ id: 12345 })     // placeholder for id\n  .where('name')            // placeholder for name\n  .one(['Bobby Badger'])    // values are [12345, 'Bobby Badger']\n```\n\nBut this won't:\n\n```js\n// DON'T DO THIS!\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where('name')            // placeholder for name\n  .where({ id: 12345 })     // placeholder for id\n  .one(['Bobby Badger'])    // ERROR! values are [12345, 'Bobby Badger']\n```\n\nYou can also provide values as an array of `[column, value]`.\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where(['id', '12345'])\n  .one()\n```\n\nBy default the comparison operator is `=`.  You can provide an array of three\nvalues to set a different comparison operator: `[column, operator, value]`.\n\n```js\ndb\n  .select('id name email')\n  .from('users')\n  .where(['id', '>', '12345'])\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\">?\n```\n\nYou can also set a comparison operator using an object by setting the value\nto a two element array: `[operator, value]`.\n\n```js\ndb\n  .select('id name email')\n  .from('users')\n  .where({ id: ['>', '12345']})\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\">?\n```\n\nOr if you want to provide the value later then use a single element array: `[operator]`.\n\n```js\ndb\n  .select('id name email')\n  .from('users')\n  .where({ id: ['>']})\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\">?\n```\n\nYou can use raw SQL to define the criteria columns.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb\n  .select('id name email')\n  .from('users')\n  .where({ sql: 'id > ?' })\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE id > ?\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\ndb\n  .select('id name email')\n  .from('users')\n  .where(sql`id > ?`)\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE id > ?\n```\n\nYou can call the method multiple times.  The criteria will all be\ncollected after the `WHERE` keyword and combined with `AND`.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where(['id', '>', 12345])\n  .where('name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\">? AND \"name\"=?\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb\n  .select('name email')\n  .from('users')\n  .where(['id', '>', 12345], 'name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\">? AND \"name\"=?\n```\n\n## join(table)\n\nThis method can be used to join tables.  A string can be passed as\na shorthand syntax of the form `from=table.to`, where `from` is the\ncolumn you're joining from, `table` is the table you're joining onto\nand `to` is the column in the joined table that should match the value\nin the `from` column.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join('user.company_id=companies.id')\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nYou can pass an array to the method containing 2, 3, or 4 elements.\nWhen using two elements, the first should be the table column you're\njoining from and the second should be the table column you're joining to.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join(['user.company_id', 'companies.id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nThe three element version has the destination table and column separated.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join(['user.company_id', 'companies', 'id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nThe four element version allows you to specify the join type at the\nbeginning.  Valid types are `left`, `right`, `inner` and `full`.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join(['left', 'user.company_id', 'companies', 'id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nYou can pass an object to the method containing the `from`, `table`\nand `to` properties, and optionally the `type`.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join({ type: 'left', from: 'user.company_id', table: 'companies', to: 'id' })\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nOr you can combine the table name and column in the `to` property.\n\n```js\ndb\n  .from('users')\n  .select('name email')\n  .select(['companies.name', 'company_name'])\n  .join({ type: 'left', from: 'user.company_id', to: 'companies.id' })\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"user\".\"company_id\" = \"companies\".\"id\"\n```\n\nYou know the drill, right?  If the method doesn't do what you need then you\ncan use raw SQL to define the joins, either with an object containing a\n`sql` property:\n\n```js\ndb\n  .from('users')\n  .select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .join({ sql: 'JOIN employees ON user.id=employees.user_id' })\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN employees ON user.id=employees.user_id\n```\n\nOr using the `sql` function to create a tagged template literal.\n\n```js\ndb\n  .from('users')\n  .select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .join(sql`JOIN employees ON user.id=employees.user_id`)\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN employees ON user.id=employees.user_id\n```\n\nAnd just like the other methods, you can call the method multiple times.\n\n```js\ndb\n  .from('users')\n  .select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .join('user.id=employees.user_id')\n  .join('employees.company_id=companies.id')\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"employees\" ON \"user\".\"id\" = \"employees\".\"user_id\"\n//    JOIN \"companies\" ON \"employees\".\"company_id\" = \"companies\".\"id\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb\n  .from('users')\n  .select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .join('user.id=employees.user_id', 'employees.company_id=companies.id')\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"employees\" ON \"user\".\"id\" = \"employees\".\"user_id\"\n//    JOIN \"companies\" ON \"employees\".\"company_id\" = \"companies\".\"id\"\n```\n\n## order(columns)\n\nThis method can be used to create an `ORDER BY` clause.  There's also an\n`orderBy()` alias for the method if you prefer something a little closer\nin name to the SQL it generates.\n\nA string can be passed containing one or more columns.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order('name')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\"\n```\n\nColumns can be delimited by whitespace or commas, as usual.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order('name, email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\"\n```\n\nColumns can include the table name for disambiguation.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order('users.name users.email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"users\".\"name\", \"users\".\"email\"\n```\n\nThe default order is `ASC` for \"ascending\".  To set a different sort\norder (e.g. `DESC` for \"descending\"), pass a two element array with the\ncolumns as the first element and `DESC` as the second.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order(['name email', 'DESC'])\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nYou can also pass an objecting containing the `column` or `columns` property.\nThe `column` is assumed to be a single column whereas `columns` can contain\nmultiple columns separated by whitespace or commas in the usual way.  In addition\nyou can specify either `asc` or `desc` as a boolean flag to set the sort direction\nto be ascending or descending, respectively.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order({ columns: 'name email', desc: true })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nOr use `direction` (or `dir` for short) set to either `ASC` or `DESC` if you prefer.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order({ columns: 'name email', dir: 'DESC' })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nOf course it also supports raw SQL, either using a `sql` property in an object.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order({ sql: 'name DESC, email' })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY name DESC, email\n```\n\nOr using a tagged template literal.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order(sql`name DESC, email`)\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY name DESC, email\n```\n\nYou can call the method multiple times or pass multiple arguments to it.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order(['name', 'DESC'], 'email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\" DESC, \"email\"\n```\n\n## group(columns)\n\nThis method can be used to create a `GROUP BY` clause.  There's also a\n`groupBy()` alias for it.\n\nA string can be passed containing one or more columns.\n\n```js\ndb\n  .select(sql`company_id, COUNT(id) AS employees`)\n  .from('users')\n  .group('company_id')\n// -> SELECT company_id, COUNT(id) AS employees\n//    FROM \"users\"\n//    GROUP BY \"company_id\"\n```\n\nMultiple columns can be delimited by whitespace or commas and can contain\na table name.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .group('users.company_id, users.start_year')\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"users\".\"company_id\", \"users\".\"start_year\"\n```\n\nYou can also pass an objecting containing the `column` or `columns` property.\nThe `column` is assumed to be a single column whereas `columns` can contain\nmultiple columns separated by whitespace or commas in the usual way.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .group({ columns: 'company_id, year' })\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"company_id\", \"year\"\n```\n\nAs you might expect it also supports raw SQL, either using a `sql` property in an object.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .group({ sql: 'company_id' })\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY company_id\n```\n\nOr using a tagged template literal.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .group(sql`company_id`)\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY company_id\n```\n\nYou can call the method multiple times or pass multiple arguments to it.\n\n```js\ndb\n  .select('*')\n  .from('users')\n  .order('company_id', 'start_year')\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"company_id\", \"start_year\"\n```\n\n## columns(columns)\n\nThis is just like [select()](#select-columns-) with one important\ndistinction.  If you don't explicitly specify a table name then it\nwill automatically attach the column names to the most recently\nspecified table.\n\n```js\nconst query = db\n  .from('users')\n  .columns('id email');\n// -> SELECT \"users\".\"id\", \"users\".\"email\"\n//    FROM \"users\"\n```\n\nYou can interleave it with multiple calls to [from()](#from-table-)\nto access columns from different tables.\n\n```js\nconst query = db\n  .from('users')\n  .columns('id email');\n  .from('companies')\n  .columns('name');\n// -> SELECT \"users\".\"id\", \"users\".\"email\", \"companies\".\"name\"\n//    FROM \"users\"\n```\n\nIf you specify multiple table names in [from()](#from-table-) then the\nlast one will be used.\n\n```js\nconst query = db\n  .from('companies users')\n  .columns('id name');\n// -> SELECT \"users\".\"id\", \"users\".\"name\"\n//    FROM \"companies\", \"users\"\n```\n\nIf you specify a table with an alias then the alias will be used.\n\n```js\nconst query = db\n  .from({ table: \"users\", as: \"people\" })\n  .columns('id name');\n// -> SELECT \"people\".\"id\", \"people\".\"name\"\n//    FROM \"users\" AS \"people\"\n```\n\n## table(name)\n\nThis can be used in conjuction with [columns()](#columns-columns-) to select\na table to attach columns to.  The table should previously have been specified\nusing [from()](#from-table-).\n\n```js\nconst query = db\n  .from('users companies')\n  .table('users').columns('id name')\n  .table('companies').columns(['name', 'company_name'])\n// -> SELECT \"users\".\"id\", \"users\".\"name\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\", \"companies\"\n```\n\n## prefix(prefix)\n\nThis can be used in conjuction with [columns()](#columns-columns-) to define\na prefix for subsequent columns.\n\n```js\nconst query = db\n  .from('users companies')\n  .table('users').prefix('user_').columns('id name')\n  .table('companies').prefix('company_').columns('name')\n// -> SELECT \"users\".\"id\" AS \"user_id\", \"users\".\"name\" AS \"user_name\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\", \"companies\"\n```\n\nYou can clear the current prefix by calling `prefix()` without any arguments.\n\n\n## one(values)\n\nTODO\n\n## any(values)\n\nTODO\n\n## all(values)\n\nTODO",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/tables.md",
    "name": "./manual/tables.md",
    "content": "# Tables\n\nIt can quickly get tedious if you've got to write lots of different\nqueries for trivial operations like inserting, updating, selecting\nand deleting rows.\n\nIn this example we introduce the concept of `tables`.  This allows you\nto specify the columns in each table and use higher level methods to\nautomatically insert, update, select and delete rows from the table.\n\nNote that we're using the same database from the previous examples\nand assuming that the `users` table has already been created.\n\n```js\n// define the users table and the columns it contains\nconst db = await connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n    }\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n\n// insert a row\nawait users.insert({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n\n// update a row\nawait users.update(\n  { name: 'Brian \"The Brains\" Badger' },  // set...\n  { email: 'brian@badgerpower.com' }      // where...\n);\n\n// fetch a row\nconst brian = await users.oneRow({\n  email: 'brian@badgerpower.com'\n});\nconsole.log(brian);\n\n// delete a row\nawait users.delete({\n  email: 'brian@badgerpower.com'\n});\n```\n\nIn the next few sections we'll look at how [table columns](manual/table_columns.html)\nare defined, the [table methods](manual/table_methods.html) that are provided, and how\nto define your own custom [table class](manual/table_class.html) where you can put\nadditional functionality relating to a table.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_columns.md",
    "name": "./manual/table_columns.md",
    "content": "# Table Columns\n\nFor simple cases you can define table columns using a whitespace delimited string,\ne.g. `id name email`.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id name email'\n    }\n  }\n});\nconst users = await db.table('users');\n```\n\nYou don't have to include all of the columns in the database table if you don't\nwant to for some reason.  If there are columns that you don't want or need to\naccess from your application code then you can omit them.  Just be warned that\nyou won't be able to access any columns that aren't defined here.\n\nYou can add flags to the column names.  These include `id` to denote the unique\nidentifier (this is optional if the column is already called `id` as we assume\nthat's the default name for the id column), `required` to indicate\nthat a column must be provided when a row is inserted, and `readonly` to indicate\nthat a column cannot be inserted or updated.  Multiple flags can be added, each\nseparated by a colon.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id:readonly name:required email:required'\n    }\n  }\n});\n```\n\nIf you try to insert a row without providing any of the `required` columns\nthen an error will be throw.\n\n```js\n// Throws a ColumnValidationError: 'Missing required column \"email\" for the users table'\nawait users.insert({\n  name: 'Brian Badger',\n});\n```\n\nThe same thing will happen if you try to insert or update a `readonly` column.\n\n```js\n// Throws a ColumnValidationError: 'The \"id\" column is readonly in the users table'\nawait users.insert({\n  id:    999,\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com',\n});\n```\n\nThere may be times when you want to insert rows with pre-defined ids.  That's fine -\nyou don't have to define your id column as being readonly in this case.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id name:required email:required'\n    }\n  }\n});\nconst users = await db.table('users');\n\n// This is fine - id isn't readonly\nawait users.insert({\n  id:    999,\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com',\n});\n```\n\nIf your unique ID column isn't called `id` then you can mark the relevant column\nusing the `id` tag.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'user_id:readonly:id name:required email:required'\n    }\n  }\n});\n```\n\nIn the rare cases where you don't have a unique id column and instead you have multiple\nkeys that are used to uniquely identify a row then you can mark them with the `key` tag.\nFor example, you might have an `employee` table which has rows that are uniquely identified\nby the `company_id` and `user_id` columns.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    employees: {\n      columns: 'company_id:key user_id:key job_title'\n    }\n  }\n});\n```\n\nNote that some databases (e.g. Sqlite) will automatically create an `id` for each\nrow regardless.  There certainly are valid cases where you might chose to NOT have\na unique id column in a database but they are generally few and far between.\nSee [this Stack Overflow post](https://stackoverflow.com/questions/1207983/in-general-should-every-table-in-a-database-have-an-identity-field-to-use-as-a) for\nfurther enlightenment.\n\nDefining the columns using a string is a convenient short hand for simpler\ntables.  The more explicit form is to use an object with the column names as\nkeys.  The corresponding values can be strings containing any flags for the\ncolumns, or an empty string if there aren't any.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: {\n        user_id: 'readonly:id',\n        name:    'required',\n        email:   'required',\n        comment: '',\n    }\n  }\n});\n```\n\nOr you can fully expand them like so:\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: {\n        user_id: {\n          readonly: true,\n          id:       true\n        },\n        name: {\n          required: true\n        }\n        email: {\n          required: true\n        }\n        comment: { }\n      }\n    }\n  }\n});\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_methods.md",
    "name": "./manual/table_methods.md",
    "content": "# Table Methods\n\nThe table object provides a number of methods for generating and running\nqueries on table rows.\n\nAs per the previous examples, we'll assume the table definition looks\nsomething like this:\n\n```js\n// define the users table and the columns it contains\nconst db = await connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name:required email:required'\n    }\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n```\n\n## insert(data, options)\n\nThe `insert()` method will construct and run an `INSERT` SQL query to insert a\nrow from the column data that you provide.\n\n```js\nconst result = await users.insert({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\nconsole.log('Rows changed:', result.changes);\nconsole.log('Generated id:', result.id);\n```\n\nThe SQL query generated will look like this for Sqlite and Mysql:\n\n```sql\nINSERT INTO users (name, email)\nVALUES (?, ?)\n```\n\nNote the use of value placeholders `?` to prevent SQL injection attacks.\n\nThe format for placeholders in Postgres is slightly different but has the\nexact same effect:\n\n```sql\nINSERT INTO users (name, email)\nVALUES ($1, $2)\n```\n\nThe result returned from the `insert()` method is an object containing the\nnumber of rows affected as `changes` and the generated id, where applicable in\n`id`.  If you have defined a different id field (e.g. `user_id`) then this will\nbe returned instead.  Other data returned by the database engine may also be\ndefined.\n\nYou can insert multiple rows by passing an array of objects to the method.\n\n```js\nconst results = await users.insert([\n  {\n    name:  'Bobby Badger',\n    email: 'bobby@badgerpower.com'\n  },\n  {\n    name:  'Brian Badger',\n    email: 'brian@badgerpower.com'\n  }\n]);\nconsole.log('Generated id #1:', results[0].id )\nconsole.log('Generated id #2:', results[1].id )\n```\n\nThe return value will be an array of results the same as those returned by\ncalling the method to insert a single row.\n\nIn some cases you may want to immediately fetch the inserted row back out of the\ndatabase.  This can be the case when you have columns with default values that\nwill be generated by the database (e.g. a `created` timestamp) that you want to\ninspect.\n\nYou could easily do it yourself - the `insert()` method will return a result containing\nthe generated `id` (or other id field) which you can then use to fetch the record.\nOr even easier, pass a second argument to the method as an object containing the\n`reload` option set to a true value.\n\nAfter inserting a row the table `insert()` method will immediately reload it from the\ndatabase and return the data for the row.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com'\n  },\n  { reload: true }\n);\nconsole.log(frank.id);      // e.g. 3\nconsole.log(frank.name);    // Frank Ferret\nconsole.log(frank.email);   // frank@ferrets-r-us.com\n```\n\nThe same thing happens if you insert multiple rows and specify the `reload` options.\nThe only difference is that the return value will be an array of rows.\n\n```js\nconst animals = await users.insert(\n  [\n    {\n      name:  'Frank Ferret',\n      email: 'frank@ferrets-r-us.com'\n    },\n    {\n      name:  'Simon Stoat',\n      email: 'simon@stoats-r-superb.com'\n    },\n  ],\n  { reload: true }\n);\nconsole.log(animals.length);        // 2\nconsole.log(animals[0].id);         // e.g. 4\nconsole.log(animals[0].name);       // Frank Ferret\nconsole.log(animals[0].email);      // frank@ferrets-r-us.com\nconsole.log(animals[1].id);         // e.g. 5\nconsole.log(animals[1].name);       // Simon Stoat\nconsole.log(animals[1].email);      // simon@stoats-r-superb.com\n```\n\nThe other option that is supported by the insert methods is `record`.\nThis will reload the row from the database (as per the `reload` option)\nand return it as a record object.  We'll be talking more about\n[records](manual/records.html) shortly but for now you should know that\nit exists.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com'\n  },\n  { record: true }\n);\n// frank is a record object but it still behaves like a row\nconsole.log(frank.id);      // e.g. 3\nconsole.log(frank.name);    // Frank Ferret\nconsole.log(frank.email);   // frank@ferrets-r-us.com\n```\n\n## insertOneRow(data, options)\n\nInternally, the [insert()](#insert-data--options-) method calls either\n`insertAllRows()`, if the value passed is an array, or `insertOneRow()`\nif it's a single data object. You can call these methods directly if you prefer.\n\n```js\nconst result = await users.insertOneRow({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n```\n\nThe `insertRow()` method is provided as an alias for this method.\n\n## insertAllRows(array, options)\n\nHere's an example explicitly calling the `insertAllRows()` method.  It's exactly the\nsame as calling [insert()](#insert-data--options-) with an array of rows to insert.\n\n```js\nconst results = await users.insertAllRows([\n  {\n    name:  'Frank Ferret',\n    email: 'frank@badgerpower.com'\n  }\n  {\n    name:  'Simon Stoat',\n    email: 'simon@badgerpower.com'\n  }\n]);\n```\n\nThe `insertRows()` method is provided as an alias for this method.\n\n## insertOneRecord(data, options)\n\nThis is a wrapper around the [insertOneRow()](#insertonerow-data--options-)\nwhich automatically sets the `record` option for you.  The result returned\nwill be a record object instead of a result object.\n\n```js\nconst record = await users.insertOneRecord({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n// a record object still behaves like a row\nconsole.log(record.name);   // Brian Badger\nconsole.log(record.email);  // brian@badgerpower.com\n```\n\nThe `insertRecord()` method is provided as an alias for this method.\n\n## insertAllRecords(array, options)\n\nThis is a wrapper around the [insertAllRows()](#insertallrows-array--options-)\nwhich automatically sets the `record` option for you.  The result returned\nwill be an array of record objects instead of an array of results.\n\n```js\nconst records = await users.insertAllRecords([\n  {\n    name:  'Bobby Badger',\n    email: 'bobby@badgerpower.com'\n  },\n  {\n    name:  'Brian Badger',\n    email: 'brian@badgerpower.com'\n  }\n]);\n// array of records returned, but they behave like rows\nconsole.log(records.length); // 2\nconsole.log(records[0].name);    // Bobby Badger\nconsole.log(records[0].email);   // bobby@badgerpower.com\nconsole.log(records[1].name);    // Brian Badger\nconsole.log(records[1].email);   // brian@badgerpower.com\n```\n\nThe `insertRecords()` method is provided as an alias for this method.\n\n## update(set, where, options)\n\nThe `update()` method, as the name suggests, allows you to update rows.\n\n```js\nawait users.update(\n  { name: 'Brian \"The Brains\" Badger' },  // SET...\n  { email: 'brian@badgerpower.com' }      // WHERE...\n);\n```\n\nThe first argument is an object containing the changes you want to make.\nThe second optional argument is the `WHERE` clause identifying the rows\nyou want to update.  You can omit the second argument if you want to update\nall rows.\n\nThe SQL generated for the method call shown above will look something like this:\n\n```sql\nUPDATE users\nSET    name=?\nWHERE  email=?\n```\n\nAgain, the format for Postgres is slightly different, using `$1` and `$2` for\nplaceholders instead of `?`, but works exactly the same.\n\nIf you want to use comparison operators (other than the default `=`) in the\n`WHERE` clause then specify the value as an array of `[operator, value]`.\n\nFor example, to update all rows where the email address isn't `brian@badgerpower.com`\n(I know, I know, this is a terrible example), then you could write:\n\n```js\nawait users.update(\n  { name: \"He's not the Messiah, he's a very naughty boy\" },\n  { email: ['!=', 'brian@badgerpower.com'] }\n);\n```\n\nThe SQL generated for this example will look something like this:\n\n```sql\nUPDATE users\nSET    name=?\nWHERE  email!=?\n```\n\nAny single value SQL operator can be used, e.g. `=`, `!=`, `<`, `<=`, `>`, `>=`.\nYou can't use operators that expect lists of values, e.g. `in (...)`.\n\n## updateAllRows(set, where, options)\n\nThe [update()](#update-set--where--options-) method is internally a wrapper\naround `updateAllRows()`.  If you want additional checks to be performed to\nensure that you're only updating one row, or if you want to automatically\nreload a row after an update then you can use the\n[updateOneRow()](#updateonerow-set--where--options-) or\n[updateAnyRow()](#updateanyrow-set--where--options-) methods.\n\nThe `updateRows()` method is provided as an alias for this method.\n\n## updateOneRow(set, where, options)\n\nThis is a variant of the [update()](#update-set--where--options-) /\n[updateAllRows()](#updateallrows-set--where--options-) method that has an\nadditional assertion check that exactly one row is updated.  If zero or more\nrows are updated then an `UnexpectedRowCount` error will be thrown with a\nmessage of the form `N rows were updated when one was expected`.\n\nThis method also supports the `reload` option.  When set, the method will\nautomatically reload the row from the database after performing the update.\nThis can be useful if you've got a column which is automatically set when the\nrecord is updated, e.g. a `modified` column, which you want to inspect.\n\n```js\nconst row = await users.updateOneRow(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nconsole.log('updated row:', row);\n```\n\nThe `where` clause defaults to using the equality operator, `=`, but as described\nin the [update()](#update-set--where--options-) method, you can use other comparison\noperators by specifying the value as an an array, e.g. `{ year: ['>', 2000] }`\nto match all records where the `year` is greater than `2000`.\n\nOne thing to note: this uses the modification and selection criteria specified\nto reload the data.  If, for example, you change the email address of a row\nthen it will correctly reload the record using the new email address.\n\n```js\nconst row = await users.updateOneRow(\n  { email: 'brian-badger@badgerpower.com' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nconsole.log('new email address:', row.email); // brian-badger@badgerpower.com\n```\n\nHowever, there are edge cases where it's not possible to reload the same row that\nwas modified, based on the criteria provided.  Consider this somewhat contrived\nexample: if the users table has a `friends` column and there is exactly one record\nwhere the `friends` count is set to `0`.  You feel sorry for the poor user and\ndecide to modify their `friends` count to be `1`.  You'll be their friend, right?\n\n```js\nawait users.updateOneRow(\n  { friends: 1 },\n  { friends: 0 },\n  { reload: true }\n);\n```\n\nWhile there may have been exactly one user with `friends` set to `0` *before*\nthe update, once the update has been applied there may be multiple rows which have\nthe `friends` count set to `1`.  The reload will fail with an `UnexpectedRowCount`\nerror.  In these cases you should always provide some other unique attribute to ensure\nthat the correct row can be identified and reloaded:\n\n```js\nawait users.updateOneRow(\n  { friends: 1 },\n  { email: 'bobby@badger.com' },\n  { reload: true }\n);\n```\n\nThe `updateRow()` method is provided as an alias for this method.\n\n## updateAnyRow(set, where, options)\n\nThis is a variant of the [update()](#update-set--where--options-) /\n[updateAllRows()](#updateallrows-set--where--options-) method that has an\nadditional assertion check that no more than one row is updated.  If more\nthan one rows are updated then an `UnexpectedRowCount` error will be thrown\nwith a message of the form `N rows were updated when one was expected`.\n\nThis also supports the `reload` option.  If a row is updated then the complete\nrow data will be returned.  Otherwise it will return `undefined`.\n\n```js\nconst row = await users.updateAnyRow(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nif (row) {\n  console.log(\"updated row:\", row);\n}\nelse {\n  console.log(\"could not update row - Brian not found!\")\n}\n```\n\nYou can also use other comparison operator as per the [update()](#update-set--where--options-)\nmethod, e.g. `{ year: ['>', 2000] }` to match all records where the `year` is greater\nthan `2000`.\n\n## delete(where)\n\nYou can probably guess what the `delete()` method does.\n\n```js\nawait users.delete({\n  email: 'brian@badgerpower.com'\n});\n```\n\nThe object passed as the only argument identifies the rows that you want to delete.\n\nThe SQL generated will look something like this:\n\n```sql\nDELETE FROM users\nWHERE email=?\n```\n\nYou can omit the selection criteria if you want to delete all rows in the table.\n\n```js\nawait users.delete()\n```\n\nNaturally, you should use this method with caution.\n\nYou can also use other comparison operator in the `where` clause, as per the\n[update()](#update-set--where--options-) method, e.g. `{ year: ['>', 2000] }`\nto match all records where the `year` is greater than `2000`.\n\n## oneRow(where, options)\n\nThere are three different methods for fetching rows from the table using\nselection criteria.  The `oneRow()` method will return a single row.\nIf the row isn't found or multiple rows match the criteria then an\n`UnexpectedRowCount` error will be thrown with a message of\nthe form `N rows were returned when one was expected`.\n\n```js\n// returns a single row or throws an error\nconst brian = await users.oneRow({\n  email: 'brian@badgerpower.com'\n});\nconsole.log('Brian:', brian);\n```\n\nThe `where` clause default to using the equality operator, `=`, but like the\n[update()](#update-set--where--options-) and [delete()](#delete-where-) method,\nyou can use other comparison operators, e.g. `{ year: ['>', 2000] }` to match\nall records where the `year` is greater than `2000`.\n\nYou can pass a second argument which can contain various options to modify\nthe selection.  For example, the `columns` option can be used to specify\nthe columns that you want to select.  They can be specified as a string\ncontaining the columns names separated by whitespace:\n\n```js\nconst brian = await users.oneRow(\n  { email: 'brian@badgerpower.com' },\n  { columns: 'id name' }\n);\n```\n\nOr as an array:\n\n```js\nconst brian = await users.oneRow(\n  { email: 'brian@badgerpower.com' },\n  { columns: ['id', 'name'] }\n);\n```\n\nThe `record` option can be specified if you want the data returned as a\n[record](manual/record.html) instead of a row.\n\n```js\nconst brian = await users.oneRow(\n  { email: 'brian@badgerpower.com' },\n  { record: true }\n);\n```\n\nThe generated SQL for this method (and also [anyRow()](#anyrow-where--options-)\nand [allRows()](#allrows-where--options-) will look something like this:\n\n```sql\nSELECT \"users\".\"id\", \"users\".\"name\" FROM users\nWHERE email=?\n```\n\n## anyRow(where, options)\n\nThe `anyRow()` method will return a single row if it exists or `undefined` if it doesn't.\n\n```js\n// returns a single row or undefined\nconst brian = await users.anyRow({\n  email: 'brian@badgerpower.com'\n});\nif (brian) {\n  console.log('Brian:', brian);\n}\nelse {\n  console.log('Brian Badger was not found');\n}\n```\n\nThe `where` clause default to using the equality operator, `=`, but like numerous\nother methods described above, you can use other comparison operators e.g.\n`{ year: ['>', 2000] }` to match all records where the `year` is greater\nthan `2000`.\n\nAs per [oneRow()](#onerow-where--options-) you can pass an additional objects\ncontaining options.  For example, to specify the columns you want returned:\n\n```js\nconst brian = await users.anyRow(\n  { email: 'brian@badgerpower.com' },\n  { columns: 'id email' }\n);\n```\n\nOr to return the row as a record object:\n\n```js\nconst brian = await users.anyRow(\n  { email: 'brian@badgerpower.com' },\n  { record: true }\n);\n```\n\n## allRows(where, options)\n\nThe `allRows()` method will return an array of all matching rows.\n\n```js\n// returns an array of all rows (possibly empty)\nconst bobbies = await users.allRows({\n  { name: 'Bobby Badger' }\n);\nif (bobbies.length) {\n  console.log(\"Fetched %s users called 'Bobby Badger':\", bobbies.length);\n}\nelse {\n  console.log(\"There aren't any users called 'Bobby Badger'\");\n}\n```\n\nIf you want to return all matching rows then you can omit the criteria or\nspecify an empty object.\n\n```js\nconst allUsers = await users.allRows();\n```\n\n```js\nconst allUsers = await users.allRows({ });\n```\n\nIt shouldn't surprise you to learn that you can use other comparison operators\nin the `where` clause, e.g. `{ year: ['>', 2000] }` to match all records where\nthe `year` is greater than `2000`.\n\nAs per [oneRow()](#onerow-where--options-) you can pass an additional objects\ncontaining options.  It supports the `columns` and `record` options.  You can\nalso provide `order` (or `orderBy` if you prefer to use a naming convention as\nclose as possible to the SQL equivalent of `ORDER BY`) to specify the order in\nwhich rows should be returned:\n\n```js\nconst allUsers = await users.allRows(\n  { },  // you can specify selection criteria or use an empty object to fetch all rows\n  { order: 'name DESC' }\n);\n```\n\n## oneRecord(where, options)\n\nThis method is a wrapper around [oneRow()](#onerow-where--options-) which returns\nthe row as a record object.  It effectively sets the `record` option for you.\n\nRead more about records [here](manual/records.html).\n\n## anyRecord(where, options)\n\nThis method is a wrapper around [anyRow()](#anyrow-where--options-) which returns\nthe row as a record object.\n\n## allRecords(where, options)\n\nThis method is a wrapper around [allRows()](#allrows-where--options-) which returns\nthe rows as an array of record objects.\n\n## run(sql, values)\n\nThis is a low-level method for running any arbitrary SQL query where\nyou're not expecting to fetch any rows.  It's just like the\n[run()](manual/basic_queries.html#run-query--values--options-)\nmethod on the database object.  The only difference is that there are\nsome table-specific fragments pre-defined: `table` contains the table\nname and `columns` contains a comma separated list of all column names.\nAny other `fragments` that you've specified in your table definition\nwill also be available.\n\nThe columns have the table name prepended and are property quoted for\nthe database.  For example, a `users` table having columns defined as\n`id name email` will expand the `columns` SQL fragment as\n`\"users\".\"id\", \"users\".\"name\", \"users\".\"email\"` for Sqlite and Postgres.\nFor Mysql the backtick character is used instead of double quotes.\n\nAs a trivial example, you can embed the `table` name in a query like so:\n\n```js\nusers.run('DROP TABLE &lt;table&gt;')\n```\n\nYou can also run any named `queries` that you've pre-defined for the table,\nor include any table `fragments` in your queries.  For example, if you've\ndefined a named query called `drop` then you can run it like so:\n\n```js\nusers.run('drop')\n```\n\n## one(query, values, options)\n\nThis is another low-level method for running an SQL query where you're\nexpecting to get exactly one row returned.  It's just like the\ncorresponding [one()](manual/basic_queries.html#one-query--values--options-)\ndatabase method, with the additional table-specific SQL fragments available, as\nper [run()](#run-query--values--options-).\n\n```js\nconst bobby = users.one(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE name=?',\n  ['Bobby Badger']\n)\n```\n\nYou can also run any pre-defined named `queries` or include query `fragments`\nin the queries you run using this method.\n\n## any(query, values, options)\n\nThis is yet another low-level method for running an SQL query, but where\nyou're expecting to get one row returned which may or may not exist.\nIt's just like the corresponding\n[any()](manual/basic_queries.html#any-query--values--options-)\ndatabase method, with the additional table-specific SQL fragments available,\nas per [run()](#run-query--values--options-).\n\n```js\nconst bobby = users.any(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE name=?',\n  ['Bobby Badger']\n)\n```\n\nPre-defined named `queries` can also be run, or you can include query\n`fragments` in the SQL.\n\n## all(query, values, options)\n\nThe final low-level method for running an SQL query where you're expecting to\nget multiple rows.  It's just like the corresponding\n[all()](manual/basic_queries.html#all-query--values--options-)\ndatabase method, with the additional table-specific SQL fragments available, as\nper [run()](#run-query--values--options-).\n\n```js\nconst rows = users.all(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt;',\n)\n```\n\nUnsurprisingly, this method also allows you to run pre-defined named\n`queries` or embed query `fragments` in the SQL.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_class.md",
    "name": "./manual/table_class.md",
    "content": "# Table Class\n\nYou can define your own custom table class for each table in the database.\nThis allows you to add your own methods for performing queries on the table.\nYou should extend the `Table` base class and then define it as the `tableClass`\noption in the table definition.\n\nHere's a complete example.\n\n```js\nimport { connect, Table } from '@abw/badger-database';\n\nexport class Users extends Table {\n  badgers() {\n    // custom method to fetch all badgers\n    return this.allRows({ animal: 'Badger' });\n  }\n}\n\nasync function main() {\n  const db = await connect({\n    database: 'sqlite:memory',\n    tables: {\n      users: {\n        // bind in the custom table class\n        tableClass: Users,\n        // column definitions\n        columns: 'id name email animal',\n        // query definitions\n        queries: {\n          create: `\n            CREATE TABLE users (\n              id     INTEGER PRIMARY KEY ASC,\n              name   TEXT,\n              email  TEXT,\n              animal TEXT\n            )`\n        }\n      },\n    }\n  });\n\n  // fetch users table object\n  const users = await db.table('users');\n\n  // run the 'create' query to create the database table\n  await users.run('create');\n\n  // insert some rows\n  await users.insert([\n    {\n      name:   'Bobby Badger',\n      email:  'bobby@badgerpower.com',\n      animal: 'Badger'\n    },\n    {\n      name:   'Brian Badger',\n      email:  'brian@badgerpower.com',\n      animal: 'Badger'\n    },\n    {\n      name:   'Frankie Ferret',\n      email:  'frank@ferret.com',\n      animal: 'Ferret'\n    }\n  ]);\n\n  // now call the custom badgers() method to fetch all badgers\n  const badgers = await users.badgers();\n\n  console.log(badgers.length);    // 2\n  console.log(badgers[0].name);   // Bobby Badger\n  console.log(badgers[1].name);   // Brian Badger\n\n  // disconnect\n  db.disconnect();\n}\n\nmain()\n```\n\n## Table Configuration\n\nYou can define a `configure()` function to your table class\nto provide the configuration options.  It will be passed an\nobject containing any configuration options from the main\nconfiguration for the table.  You can then add in any other\nconfiguration options.\n\nYou can either update the `config` passed in as an argument,\nor create a new configuration based on it.  In the latter case\nyou need to make sure you return the new configuration options\nat the end of the method.\n\n```js\nexport class Users extends Table {\n  configure(config) {\n    config.columns = 'id:readonly name:required email:required animal:required',\n    config.queries = {\n      create: `\n        CREATE TABLE users (\n          id     INTEGER PRIMARY KEY ASC,\n          name   TEXT,\n          email  TEXT,\n          animal TEXT\n        )`\n    }\n  }\n  badgers() {\n    // custom method to fetch all badgers\n    return this.allRows({ animal: 'Badger' });\n  }\n}\n```\n\nWhen you define the `tables` for the database you then only need\nto specify the `tableClass`.\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      tableClass: Users,\n    }\n  }\n});\n```\n\nIf you don't have any other table configuration options that you\nwant to specify then you can use a shortcut and point the `users`\ntable directly at your class.\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: Users,\n  }\n});\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/records.md",
    "name": "./manual/records.md",
    "content": "# Records\n\nVarious  [table methods](manual/table_methods.html) have the option\nto return a record object instead of a plain Javascript data object\ncontaining the row data.  Or, in the case\n[allRecords()](manual/table_methods.html#allrecords-where--options-) and\nsimilar methods, they return an array of record objects.\n\nThe record object implements a lightweight version of the Active Record\npattern.\n\n```js\nconst record = await users.oneRecord(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\nThe row data loaded from the database is stored in the `row` property.\nYou can access individual items or the row data as a whole.\n\n```js\nconsole.log(record.row.id);      // e.g. 1\nconsole.log(record.row.name);    // Bobby Badger\nconsole.log(record.row.email);   // bobby@badgerpower.com\nconsole.log(record.row);         // { id: 1, name: 'Bobby Badger', etc. }\n```\n\nTechnically speaking, the methods actually return a Proxy object wrapper\naround a record object (or an array of Proxy objects in the case of\n[allRecords()](manual/table_methods.html#allrecords-where--options-) et al).\nThe purpose of the Proxy object, among other things, is to give you access\nto row data items without needing to specify the `.row` property.\n\n```js\nconsole.log(record.id);          // e.g. 1\nconsole.log(record.name);        // Bobby Badger\nconsole.log(record.email);       // bobby@badgerpower.com\n```\n\nThis makes the record object look and feel just like a row of data, but with\nsome extra benefits.  For example, the [update()](manual/record_methods.html#update-set-)\nmethod allows you to update the record and corresponding row in the database.\n\n```js\nawait record.update({ name: 'Robert Badger' });\nconsole.log(record.name); // Robert Badger\n```\n\nThe Proxy object also gives you easy access to [relations](manual/relations.html)\nthat are defined for the table.  For example, if the `users` table defines `orders`\nas a relation then you can access them as `.orders`;\n\n```js\nconst orders = await record.orders;\n```\n\nNote that any other properties or methods defined for the record will take\npriority.  For example, `record.update` will resolve to the record\n[update()](manual/record_methods.html#update--) method so if you have a\ncolumn called `update` then you must access it as `record.row.update`.\n\nIn the next few sections we'll look at the [record methods](manual/record_methods.html)\nthat are provided, and how to define your own custom [record class](manual/record_class.html)\nwhere you can put additional functionality relating to a record.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/record_methods.md",
    "name": "./manual/record_methods.md",
    "content": "# Record Methods\n\nA record object is a wrapper around a row of data from a table.\n\nAs per the previous examples, we'll assume the table definition looks\nsomething like this:\n\n```js\n// define the users table and the columns it contains\nconst db = await connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name:required email:required'\n    }\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n\n// fetch a record from the users table\nconst record = await users.oneRecord({\n  email: 'bobby@badgerpower.com'\n})\n```\n\n## update(set)\n\nThe `update()` method allows you to update any columns in the row that the record\nrepresents.\n\n```js\nawait record.update({\n  name:  'Robert Badger, Esq.',\n  email: 'robert@badgerpower.com'\n})\n```\n\nThe data will be updated in both the database table row and the record object.\nAny other changes in the database row (e.g. a `modified` column that is set to\nthe current timestamp when a record is modified) will also be reflected in the\nrecord.\n\n```js\nconsole.log(record.name);       // Robert Badger, Esq.\n```\n\n## delete()\n\nThe `delete()` method allows you to delete the row in the table represented by\nthe record.\n\n```js\nawait record.delete();\nconsole.log(record.deleted)     // true\n```\n\nAfter deleting the record the `record.deleted` flag will be set `true`.  Any\nattempt to update the record (or delete it again) will throw a `DeletedRecordError`\nwith a message of the form `Cannot update deleted users record #123`.\n\n## relation(name)\n\nThis method allows you to access relations for a table.  Read more on that in\nthe [relations](manual/relations.html) manual page.\n\nFor example, if your `users` table has a `orders` relation defined then you can\naccess the related record(s) like so:\n\n```js\nconst orders = await record.relation('orders');\n```\n\nThe Proxy wrapper also allows you to access it more succinctly as:\n\n```js\nconst orders = await record.orders;\n```\n\n\n\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/record_class.md",
    "name": "./manual/record_class.md",
    "content": "# Record Class\n\nYou can define your own custom record class for each table in the database.\nThis allows you to add your own methods for performing queries on the record\ndata or other business logic.\n\nYou should extend the `Record` base class and then define it as the `recordClass`\noption in the table definition.\n\nHere's a complete example.\n\n```js\nimport { connect, Record } from '@abw/badger-database';\n\nexport class User extends Record {\n  hello() {\n    return 'Hello ' + this.row.name;\n  }\n}\n\nasync function main() {\n  const db = await connect({\n    database: 'sqlite:memory',\n    tables: {\n      users: {\n        // bind in the custom record class\n        recordClass: User,\n        // column definitions\n        columns: 'id name email animal',\n        // query definitions\n        queries: {\n          create: `\n            CREATE TABLE users (\n              id     INTEGER PRIMARY KEY ASC,\n              name   TEXT,\n              email  TEXT,\n              animal TEXT\n            )`\n        }\n      },\n    }\n  });\n\n  // fetch users table object\n  const users = await db.table('users');\n\n  // run the 'create' query to create the database table\n  await users.run('create');\n\n  // insert a row\n  await users.insert({\n    name:   'Bobby Badger',\n    email:  'bobby@badgerpower.com',\n    animal: 'Badger'\n  });\n\n  // fetch a record\n  const user = await users.oneRecord({\n    email: 'bobby@badgerpower.com'\n  })\n\n  // now call the custom hello() method on the record\n  console.log(user.hello());    // Hello Bobby Badger\n}\n\nmain()\n```\n\n## Record Configuration Options\n\nIf you want to pass additional configuration options to the record\nobject then you can define them as the `recordConfig` configuration\noption in the corresponding table configuration.\n\n```js\nconst db = await connect({\n  // ...database, etc.\n  tables: {\n    users: {\n      recordClass: User,\n      recordConfig: {\n        hello: 'Hiya'\n      }\n    },\n  }\n});\n```\n\nThe `recordConfig` parameters will then be available in the record\nobject as `this.config`.  For example, we can rewrite the `hello()`\nmethod to use the configuration value for `hello`:\n\n```js\nexport class User extends Record {\n  hello() {\n    return `${this.config.hello || 'Hello'} ${this.row.name}`;\n  }\n}\n```\n\nNow when the `hello()` method is called on a user record object\na different greeting will be returned:\n\n```js\nconsole.log(user.hello());    // Hiya Brian Badger\n```\n\nIf you want to perform any initialisation of the record then you can override\nthe constructor function.  It is passed three arguments: a reference to the\n`table` object, the `row` of data, and any configuration options.  Make sure\nyou call the `super()` constructor before you do anything else.\n\n```js\nexport class User extends Record {\n  constructor(table, row, config={}) {\n    super(table, row, config);\n    this.greeting = config.hello || 'Hello';\n  }\n  hello() {\n    return `${this.greeting} ${this.row.name}`;\n  }\n}\n```",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/relations.md",
    "name": "./manual/relations.md",
    "content": "# Relations\n\nRelations are, rather unsurprisingly, at the heart of relational databases.\n\nTo demonstrate the concepts we're going to use an overly simple schema for\na music database.  We'll assume that the database tables have already been\ncreated and populated with some sample data.\n\nOne table will store the `artists`.\n\n```sql\nCREATE TABLE artists (\n  id   SERIAL,\n  name TEXT,\n  PRIMARY KEY (id)\n)\n```\n\nAnother will store the albums that they release, including the `year` and `title`.\nNote the `artist_id` which forms a relation to the artist that released the\nalbum.  In this simple example we're going to assume that only one artist can\nrelease an album.  This isn't the case in the real world if you consider things\nlike multi-artist collaborations and compilation albums, but we're just trying\nto demonstrate the basic concepts here, not build the next Spotify.\n\n```sql\nCREATE TABLE albums (\n  id        SERIAL,\n  year      INTEGER,\n  title     TEXT,\n  artist_id INTEGER,\n  PRIMARY KEY (id),\n  FOREIGN KEY (artist_id) REFERENCES artists(id)\n)\n```\n\nA third table will store the tracks on each album, include the track `title`,\nthe `album_id` linking it to the album that it appears on, and the `track_no`\nto indicate it's position in the track listing for the album.  The `bonus`\ncolumn is a boolean value which defaults to false, which is used to indicate\n\"bonus tracks\" that sometime appear on albums.\n\n```sql\nCREATE TABLE tracks (\n  id        SERIAL,\n  title     TEXT,\n  album_id  INTEGER,\n  track_no  INTEGER,\n  bonus     BOOLEAN DEFAULT false,\n  PRIMARY KEY (id),\n  FOREIGN KEY (album_id) REFERENCES albums(id)\n)\n```\n\n## Relation Types\n\nThis example demonstrates two basic relation types: the \"many to one\" relation\nthat exists between artists and albums, and the \"one to many\" relation that\nexists between albums and track.\n\nEach artist can release many albums.  But in this simple example we're assuming\nthat an albums can only be released by one artist.  Therefore this is a \"many\nto one\" relation.\n\nEach album can have many tracks, but each track can only appear on a single album.\nTherefore this is a \"one to many\" relation.\n\n## Defining Table Relations\n\nThe relations for each table should be added to the `tables` configuration\nas the `relations` object.  This is what our main database configuration\nshould look like.\n\n```js\nconst musicdb = connect({\n  database: 'postgres://musicdb',\n  tables: {\n    artists: {\n      columns: 'id name',\n      relations: {\n        albums: {\n          type:  'many',\n          from:  'id',\n          to:    'artist_id',\n          table: 'albums',\n        }\n      }\n    },\n    albums: {\n      columns: 'id year title artist_id',\n      relations: {\n        artist: {\n          type:   'one',\n          from:   'artist_id',\n          to:     'id',\n          table:  'artists',\n        },\n        tracks: {\n          type:   'many',\n          from:   'id',\n          to:     'album_id',\n          table:  'tracks',\n          order:  'track_no',\n        }\n      }\n    }\n    tracks: {\n      columns: 'id title album_id track_no bonus',\n      relations: {\n        album: {\n          type:   'one',\n          from:   'album_id',\n          to:     'id',\n          table:  'albums',\n        },\n      }\n    }\n})\n```\n\nThe `artists` table has an `albums` relation which can include many albums.\nThe relation goes from the `id` column on the `artists` table to the\n`artist_id` column on the `albums` table.\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  from:  'id',\n  to:    'artist_id',\n  table: 'albums',\n}\n```\n\nThe `albums` table has two relations.  The `artist` relation is one\nartist with the join going from the `artist_id` column on the `albums`\ntable to the `id` column on the `artists` table.  The `tracks` relation\nis many tracks with the join going from the `id` column on the `tracks`\ntable to the `album_id` column on the `albums` table.  The tracks in\nthis relation should be ordered by the `track_no` column.\n\n```js\n// tables.albums.relations...\nartist: {\n  type:   'one',\n  from:   'artist_id',\n  to:     'id',\n  table:  'artists',\n},\ntracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n}\n```\n\nThe `tracks` table has a single relation for the `album` that it appears on.\nThe join goes from the `album_id` column on the `tracks` table to the `id`\ncolumn on the `albums` table.\n\n```js\n// tables.tracks.relations...\nalbum: {\n  type:   'one',\n  from:   'album_id',\n  to:     'id',\n  table:  'albums',\n},\n```\n\n## Fetching Relations\n\nLet's assume we've got Pink Floyd defined as an artist, and their\nseminal albums \"The Dark Side of the Moon\" and \"Wish You Were Here\"\nhave already been added to the database.\n\nWe can start by fetching an artist record for Pink Floyd.\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist = await artists.oneRecord({ name: 'Pink Floyd' });\n```\n\nThe `relation()` method allows us to fetch all related records in\na relation.  The `albums` relation is defined as a `many` type, so\nit returns an array of records from the `albums` table.\n\n```js\nconst albums = await artist.relation('albums');\nconsole.log(albums[0].title);   // The Dark Side of the Moon\nconsole.log(albums[1].title);   // Wish You Were Here\n```\n\nThe record proxy object allows you to simplify this.  If there's a\nrelation defined for a record then you can access it as a property\nof the record.  Just remember that there's actually a method call\nand database access going on behind the scenes so you have to `await`\nthe result.\n\n```js\nconst albums = await artist.albums;\nconsole.log(albums[0].title);   // The Dark Side of the Moon\nconsole.log(albums[1].title);   // Wish You Were Here\n```\n\nWe can take one of those albums and use the `artist` relation\nto fetch the artist that recorded the album.\n\n```js\nconst dsotm = albums[0];\nconst artist = await dsotm.artist;\nconsole.log(artist.name);   // Pink Floyd\n```\n\nWe can also fetch the tracks on the album.  They will be automatically\nordered by the `track_no` column.\n\n```js\nconst tracks = await dsotm.tracks;\nconsole.log(tracks[0].title);  // Speak to Me / Breathe\nconsole.log(tracks[1].title);  // On the Run\nconsole.log(tracks[2].title);  // Time\nconsole.log(tracks[3].title);  // The Great Gig in the Sky\n// ...etc...\n```\n\nAnd finally, we can go the other way and, for a given track,\nwe can fetch the album that it appears on.\n\n```js\nconst time = tracks[2];\nconst album = await time.album;\nconsole.log(album.title);   // The Dark Side of the Moon\n```\n\n## Additional Constraints\n\nAdditional constraints for a relation can be defined using the\n`where` property.\n\nFor example, we might want to define the `tracks` relation\nto only return tracks that aren't bonus tracks, and define a\nnew `bonus_tracks` relation for those that are.\n\n```js\n// tables.albums.relations...\ntracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n  where:  { bonus: 0 }\n},\nbonus_tracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n  where:  { bonus: 1 }\n}\n```\n\nIf your copy of The Dark Side of the Moon has\n\"Us and Them (Richard Wright Demo)\" and \"Money (Roger Waters Demo)\"\nincluded as bonus tracks (you lucky thing!) then you could fetch them\nlike so.  Assuming, of course, that they're in the database and have\nthe `bonus` columns set to `true` (or `1` which databases treat as the\nsame thing).\n\n```js\nconst bonus = await dsotm.bonus_tracks;\nconsole.log(bonus[0].title);  // Us and Them (Richard Wright Demo)\nconsole.log(bonus[1].title);  // Money (Roger Waters Demo)\n```\n\n## Shorthand Syntax for Defining Relations\n\nIf you've got a simple relation then you can define it as a string\nusing the shorthand syntax.  The general format for the `one` relation is:\n\n```js\nfrom -> table.to\n```\n\nFor a `many` relation it uses a \"fat arrow\" instead.\n\n```js\nfrom => table.to\n```\n\nFor example, the `album` relation defined for the `tracks` table looks\nlike this:\n\n```js\n// tables.tracks.relations...\nalbum: {\n  type:   'one',\n  from:   'album_id',\n  to:     'id',\n  table:  'albums',\n},\n```\n\nThat can be shortened to:\n\n```js\nalbum: 'album_id -> albums.id'\n```\n\nSimilarly, the `albums` relation for `artists` can be shortened from\nthis:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  table: 'albums',\n  from:  'id',\n  to:    'artist_id',\n}\n```\n\nTo this:\n\n```js\nalbums: 'id => albums.artist_id'\n```\n\nYou can't specify an `order` or additional `where` constraints using this\nsyntax.  If you need to specify those then you can either use the fully\nexpanded form:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  table: 'albums',\n  from:  'id',\n  to:    'artist_id',\n  order: 'year',\n}\n```\n\nOr you can define the shorthand form as the `relation` item and add `order` and/or `where`\nas additional items.\n\n```js\n// tables.artists.relations...\nalbums: {\n  relation: 'id => albums.artist_id',\n  order:    'year',\n}\n```\n\n## Custom Queries\n\nIf you want to define a more complex relation then you can provide your own\n`load` function to take care of it.\n\nFor example, suppose we want to fetch all the album tracks for a particular\nartist, ordered by the album year and then the track number.\n\nWe can define a custom query in the `queries` section of the `artists` table\ndefinition to load the relevant rows:\n\n```js\n// tables.artists...\nqueries: {\n  album_tracks: `\n    SELECT    tracks.*, albums.title as album, albums.year\n    FROM      albums\n    JOIN      tracks\n    ON        tracks.album_id=albums.id\n    WHERE     albums.artist_id=$1\n    ORDER BY  albums.year,tracks.track_no\n  `\n}\n```\n\nThen we can add an `album_tracks` relation in the `relations` section of the same\n`artists` table that looks something like this:\n\n```js\n// tables.artists...\nrelations: {\n  album_tracks: {\n    load: async (record) => {\n      const artists = record.table;\n      const rows = await artists.all(\n        'album_tracks',\n        [record.row.id]\n      )\n      return artists.records(rows);\n    }\n  }\n}\n```\n\nThe `load` function is passed a reference to the current record (an artist\nin this case).  Each record has a reference to the `table` object that it\ncame from.  Through that we can fetch all the relevant rows using the\n`album_tracks` query, passing the current artist id as the value for the\nplaceholder variable.\n\nYou can return the `rows` as they are, but in this example we'll convert them\nto records by calling the `records()` method on the table.  This ensures\nthey're returned as record object in case we want to perform any further\nrecord-based operations on them.\n\nHere's the complete definition for the `artists` table:\n\n```js\n// tables...\nartists: {\n  columns: 'id name',\n  queries: {\n    album_tracks: `\n      SELECT    tracks.*, albums.title as album, albums.year\n      FROM      albums\n      JOIN      tracks\n      ON        tracks.album_id=albums.id\n      WHERE     albums.artist_id=$1\n      ORDER BY  albums.year,tracks.track_no\n    `\n  },\n  relations: {\n    albums: 'id => albums.artist_id',\n    album_tracks: {\n      load: async (record) => {\n        const artists = record.table;\n        const rows = await artists.all(\n          'album_tracks',\n          [record.row.id]\n        )\n        return artists.records(rows);\n      }\n    }\n  }\n```\n\nAnd here's how we can use it.\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist  = await artists.oneRecord({ name: 'Pink Floyd' });\nconst tracks  = await artist.album_tracks;\n\n// we should now have all the tracks from The Dark Side of the Moon\n// followed by all those from Wish You Were Here\nconsole.log(tracks[0].album);  // The Dark Side of the Moon\nconsole.log(tracks[0].year);   // 1973\nconsole.log(tracks[0].title);  // Speak to Me / Breathe\n\nconsole.log(tracks[1].album);  // The Dark Side of the Moon\nconsole.log(tracks[1].year);   // 1973\nconsole.log(tracks[1].title);  // On the Run\n\n// ...etc...\n\nconsole.log(tracks[13].album);  // Wish You Were Here\nconsole.log(tracks[13].year);   // 1975\nconsole.log(tracks[13].title);  // Shine On You Crazy Diamond (Parts I-V)\n```\n\nThere are other ways to achieve a similar result.  For example, you could define\nyour own [record class](manual/record_class.html) for the artists table and add\nan `albumTracks` method:\n\n```js\nexport class Artist extends Record {\n  async albumTracks() {\n    const artists = this.table;\n    const rows = await artists.all(\n      'album_tracks',\n      [this.row.id]\n    )\n    return artists.records(rows);\n  }\n}\n```\n\nThe usage would be almost identical:\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist  = await artists.oneRecord({ name: 'Pink Floyd' });\nconst tracks  = await artist.albumTracks();\n// ...as before\n```\n\nIf you've already defined a record class for a table then this might be the\neasier approach.  On the other hand, if you don't already have a record\nclass then it might be slightly easier to define a custom relation with a\n`load` method to achieve the same effect.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/model.md",
    "name": "./manual/model.md",
    "content": "# Model\n\nThe database `model` property provides a short-hand way to access tables\nin the database model.\n\nGiven a database connection like this:\n\n```js\n// connect to the database\nconst musicdb = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    artists: {\n      columns: 'id name'\n    },\n    // ...etc...\n  }\n});\n```\n\nWe can fetch the `artists` table by calling the `table()` method:\n\n```js\nconst artists = await musicdb.table('artists');\n```\n\nThe database `model` is a proxy that allows you to use the shorthand form.\n\n```js\nconst artists = await musicdb.model.artists;\n```\n\nAdmittedly it doesn't save you much typing, but I find it slightly\neasier to read (and marginally easier to type).",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/waiter.md",
    "name": "./manual/waiter.md",
    "content": "# Waiter\n\nWhen you're at a restaurant it would be a bit tedious if you asked the waiter\nto bring you a steak (or vegetarian/vegan alternative if that's your thing),\nand then when he delivered it to your table, you asked him for some potatoes,\nand then when those came you asked him for some green beans, then some bread,\nbutter, a bottle of wine, and so on.  Each time you wait for one item to arrive\nbefore you order the next.\n\nThe better approach, of course, would be to place your entire order at once\nand then wait for the waiter to bring it.\n\nWriting asynchronous Javascript code can feel a bit like the first scenario\nsometimes.  For example, suppose we've got a music database and we want to load\nthe artist record for \"The Pink Floyd\" (as they were sometimes know in the early\ndays) and change the name to just \"Pink Floyd\".\n\nThe code might look something like this:\n\n```js\n// connect to the database\nconst musicdb = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    artists: {\n      columns: 'id name'\n    },\n    // ...etc...\n  }\n});\n\n// wait for the artists table\nconst artists = await musicdb.model.artists;\n\n// wait to fetch a record\nconst artist = await artists.oneRecord({\n  name: 'The Pink Floyd'\n});\n\n// wait to update the record\nawait artist.update({\n  name: 'Pink Floyd'\n});\n\n// fetch the new artist name\nconst name = artist.name;\n\n// check we got the expected value\nconsole.log(name);    // Pink Floyd\n```\n\nThe database object that is returned from the `connect()` method (which you *do*\nhave to wait for) includes a `waiter` property that allows you to \"place your\nentire order at once\" and then wait for the result.\n\n```js\nconst musicdb = await connect({\n  // as before\n});\nconst name = await musicdb.\n  .waiter       // waiter, please can you fetch...\n  .model        // ...the database model...\n  .artists      // ...which has an artists table...\n  .oneRecord({  // ...containing a record...\n    name: 'The Pink Floyd'\n  })\n  .update({     // ...that we want to update...\n    name: 'Pink Floyd'\n  })\n  .name;        // ...then tell me the new name...\n\nconsole.log(name);   //Pink Floyd\n```\n\nThat's all there is to it.  The `waiter` property contains a\n[proxymise](https://github.com/kozhevnikov/proxymise) wrapper\naround the database.  This allows you to chain together asynchronous\nmethod calls and access data properties in a convenient short-hand\nform.  You just need to `await` the final result.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/debugging.md",
    "name": "./manual/debugging.md",
    "content": "# Debugging\n\nTo enable debugging messages for the database library add the `debug` flag to the\n`connect()` configuration, set to `true`.\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory',\n  debug: true\n})\n```\n\nTo enable debugging for individual tables, add the `debug` flag to the table\nconfiguration.\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      columns: 'id name email',\n      debug: true,\n    }\n  }\n})\n```\n\nTo enable debugging for a record object associated with a table, set the `recordConfig`\nfor the table to include the `debug` flag.\n\n```js\nconst db = await connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      columns: 'id name email',\n      recordConfig: {\n        debug: true\n      }\n    }\n  }\n})\n```\n\nTo enable debugging on a global level (for example, to enable it for all tables,\nrecords, etc.), use the `setDebug` function.  You can set any of the following\nflags to `true` to enable debugging for that component.\n\n```js\nimport { connect, setDebug } from '../src/Utils/Debug.js';\n\nsetDebug({\n  database: true,   // general database queries\n  engine:   true,   // lower level functionality\n  queries:  true,   // query lookup and expansion\n  table:    true,   // table methods\n  record:   true,   // record methods\n})\n```\n\nInside a custom table or record module you can print debugging messages to the console\nusing the `debug()` method.\n\n```js\nexport class User extends Record {\n  helloWorld() {\n    this.debug(\"helloWorld()\");\n    // ...your code goes here...\n  }\n}\n```\n\nYou can use the `debugData()` method to generate debugging messages to display\nthe contents of data items.  This is a useful way to inspect the parameters\npassed to a method.\n\n```js\nexport class User extends Record {\n  helloWorld(message, options) {\n    this.debugData(\"helloWorld()\", { message, options });\n    // ...your code goes here...\n  }\n}\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/extending.md",
    "name": "./manual/extending.md",
    "content": "# Extending\n\n## Custom Tables Class\n\nYou can provide your own implementation of the `Tables` class which\nreturns the configuration options for a table.  For example, you might\nwant to define your tables in JSON or YAML files that are loaded on\ndemand.\n\nThe `table(name)` method is called to fetch the configuration options\nfor a table.  Any pre-defined tables will be stored in `this.tables`.\nYou can return the data from there or implement some other way to\nfetch the configuration options for the table.\n\n```js\nimport { connect, Tables } from '@abw/badger-database'\n\nclass YourTables extends Tables {\n  table(name) {\n    // any pre-defined tables data will be stored in this.tables\n    // or you can fetch it some other way...\n    return this.tables[name] ||= this.yourCustomTableLoader(name);\n  }\n  yourCustomTableLoader(name) {\n    // your code here to load the table definition for the `name` table\n    // return undefined if the table doesn't exist\n    return {\n        // columns, etc.\n    }\n  }\n}\n\nasync function main() {\n  const db = await connect({\n    // ...database, etc...\n    tablesClass: YourTables,\n    tables: {\n        // these tables will be defined in `this.tables` for YourTables\n        users: {\n            columns: 'id name email'\n        }\n    }\n  });\n  const users = await db.table('users');      // returns users defined above\n  const another = await db.table('another');  // calls yourCustomTableLoader('another')\n}\n\nmain();\n```\n\n## Custom Tables Object\n\nYou can instantiate your own `Tables` object and define it as the `tablesObject`\nconfiguration item.  If you have any pre-defined `tables` that you want it to\nmanage then you should pass them as constructor parameters.\n\n```js\nconst db = await connect({\n  // ...database, etc...\n  tablesObject: new YourTables({\n    tables: {\n        // these tables will be defined in `this.table` for YourTables\n        users: {\n            columns: 'id name email'\n        }\n    },\n    // any other configuration options for YourTable\n  })\n});\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/limitations.md",
    "name": "./manual/limitations.md",
    "content": "# Limitations\n\nThe scope of the library is, quite deliberately, limited.\n\nThe table methods to insert, update, select and delete rows,\nfor example, are intended to automate *most* of the trivial queries\nthat you might want to perform, but there will undoubtedly be cases\nwhere they fall short.\n\nYou can't select, update or delete rows using a JOIN onto another\ntable, for example.  Nor can you select rows using subqueries or\ntemporary tables.  Aliases for selecting columns aren't support at\nthe time of writing (although they might be by the time you read this).\n\nSimilarly, the support for relations has some shortcomings.  For example,\nyou can't define many-to-many relations that use intermediate link\ntables (although you can define your own load method to do that).\n\nThese are all deliberate design decision.  Supporting everything that\nis possible in SQL would require a full-blown ORM or SQL query generator\nwith all the problems that they bring.\n\nThe library aims to hit the 90/10 sweet spot, where it handles 90% of\ntrivial tasks that can easily be automated, leaving the remaining 10%\n(which would take 90% of the effort) up to you.\n\nInstead, the library makes it easy for you to define named queries and\ncustom table or record methods so that you can use the full power of SQL\nbehind the scenes, without having to embed SQL directly into your\napplication code.\n\nThis approach also makes it easier for the SQL expert in your team (if\nyou have one), to take responsibility for building and maintaining your\ndatabase abstraction layer, allowing other developers to treat it more\nlike a black box, accessing the complex functionality hidden behind the\nscenes through simple method calls.  Even if you don't have an SQL expert,\nthe fact that the library supports and encourages the use of SQL queries\nmakes it easier to cut and paste examples from Stack Overflow without\nhaving to first translate the SQL into the right calls to a query generator.\n\nSQL is powerful.  SQL is portable.  SQL is (nearly always) the solution\nif the library doesn't already do what you want.\n\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/examples.md",
    "name": "./manual/examples.md",
    "content": "# Examples\n\nThe [github repository](https://github.com/abw/badger-database-js) contains\na number of [examples](https://github.com/abw/badger-database-js/tree/master/examples)\nbased on those shown in these manual pages.\n\n* [01_basic_queries](https://github.com/abw/badger-database-js/tree/master/examples/01_basic_queries)\nConnecting to a database and running some basic SQL queries.\n\n* [02_named_queries](https://github.com/abw/badger-database-js/tree/master/examples/02_named_queries)\nUsing named queries for reusability and to simplify your application code.\n\n* [03_query_fragments](https://github.com/abw/badger-database-js/tree/master/examples/03_query_fragments)\nDefining reusable query fragments that can be embedded into other queries.\n\n* [04_tables](https://github.com/abw/badger-database-js/tree/master/examples/04_tables)\nDefining tables to get automatically generated insert, update, fetch and delete queries.\n\n* [05_table_class](https://github.com/abw/badger-database-js/tree/master/examples/05_table_class)\nDefining a custom table class with additional application-specific methods.\n\n* [06_records](https://github.com/abw/badger-database-js/tree/master/examples/06_records)\nUsing records and defining a custom record class with additional application-specific methods.\n\n* [07_musicdb](https://github.com/abw/badger-database-js/tree/master/examples/07_musicdb).\nA more complete example of a music database demonstrating custom table and records classes, and the\nuse of relations.\n\n* [08_debugging](https://github.com/abw/badger-database-js/tree/master/examples/08_debugging)\nEnabling debugging to see what's going on behind the scenes.\n",
    "static": true,
    "access": "public"
  }
]