[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Builder/After.js",
    "content": "import Builder from '../Builder.js';\n\nexport class After extends Builder {\n  static buildMethod = 'after'\n  static buildOrder  = 100\n  // TODO\n}\n\nexport default After",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/After.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "After",
    "memberof": "src/Builder/After.js",
    "static": true,
    "longname": "src/Builder/After.js~After",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{After}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/After.js~After",
    "static": true,
    "longname": "src/Builder/After.js~After.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/After.js~After",
    "static": true,
    "longname": "src/Builder/After.js~After.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "file",
    "name": "src/Builder/Before.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Before extends Builder {\n  static buildMethod = 'before'\n  static buildOrder  = 0\n  // TODO\n}\n\nexport default Before",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Before.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 53,
    "kind": "class",
    "name": "Before",
    "memberof": "src/Builder/Before.js",
    "static": true,
    "longname": "src/Builder/Before.js~Before",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Before}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Before.js~Before",
    "static": true,
    "longname": "src/Builder/Before.js~Before.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Before.js~Before",
    "static": true,
    "longname": "src/Builder/Before.js~Before.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/Builder/Columns.js",
    "content": "import Select from './Select.js';\n\nexport class Columns extends Select {\n  static buildMethod = 'columns'\n  static contextSlot = 'select'\n\n  initBuilder() {\n    // generated fragments get stored in the context with those from select()\n    // this.key = 'select';\n  }\n\n  resolveLinkString(columns, table=this.lookupTable(), prefix=this.context.prefix) {\n    // this is the same as Select, but with table defaulting to last defined\n    // table and prefix defaulting to last defined prefix\n    return super.resolveLinkString(columns, table, prefix);\n  }\n\n  resolveLinkArray(columns) {\n    const table = this.lookupTable()\n\n    if (columns.length === 2) {\n      // two-element array is [column, alias]\n      return this.quoteTableColumnAs(table, ...columns);\n      // table, columns[0], prefix ? `${prefix}${columns[1]}` : columns[1]);\n    }\n    else if (columns.length === 3) {\n      // three-element array is [table, column, alias]\n      return this.quoteTableColumnAs(...columns)\n    }\n    this.errorMsg('array', { n: columns.length });\n  }\n\n  resolveLinkObject(column) {\n    const table = this.lookupTable()\n\n    if (column.column && column.as) {\n      // object can contain \"column\" and \"as\" with optional \"table\"\n      return this.quoteTableColumnAs(\n        column.table || table,\n        column.column,\n        column.as\n      )\n    }\n    // or it must have \"column\" or \"columns\"\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table || table, column.prefix || this.context.prefix)\n    }\n    this.errorMsg('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Columns",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Columns.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "Columns",
    "memberof": "src/Builder/Columns.js",
    "static": true,
    "longname": "src/Builder/Columns.js~Columns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Columns}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Select.js~Select"
    ]
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Columns.js~Columns",
    "static": true,
    "longname": "src/Builder/Columns.js~Columns.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "contextSlot",
    "memberof": "src/Builder/Columns.js~Columns",
    "static": true,
    "longname": "src/Builder/Columns.js~Columns.contextSlot",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "optional": true,
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Columns.js~Columns",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Columns.js~Columns#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "file",
    "name": "src/Builder/Database.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Database extends Builder {\n  initBuilder(database) {\n    this.database = database;\n  }\n  resolve(context) {\n    return {\n      database: this.database,\n      ...context,\n    }\n  }\n}\n\nexport default Database",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "Database",
    "memberof": "src/Builder/Database.js",
    "static": true,
    "longname": "src/Builder/Database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Database}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Database.js~Database#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "database",
    "memberof": "src/Builder/Database.js~Database",
    "static": false,
    "longname": "src/Builder/Database.js~Database#database",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Database.js~Database#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"database\": *, ...context: Object}"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/Builder/Delete.js",
    "content": "import { isArray } from '@abw/badger-utils';\nimport Builder from '../Builder.js';\nimport { comma, DELETE } from '../Constants.js';\nimport { spaceAfter } from '../Utils/Space.js';\n\nexport class Delete extends Builder {\n  static buildMethod = 'delete'\n  static buildOrder  = 19\n  static subMethods  = 'from join where order order_by limit returning'\n  static keyword     = DELETE\n  static joint       = comma\n  static messages    = {\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"columns\", \"column\", \"table\" and \"prefix\".',\n  }\n\n  static generateSQL(values) {\n    const keyword = this.keyword;\n    const joint   = this.joint;\n    return values && values.length\n      ? spaceAfter(keyword) + (isArray(values) ? values.join(joint) : values)\n      : keyword;\n  }\n\n  resolveLink() {\n    if (this.args.length) {\n      return super.resolveLink();\n    }\n    else {\n      this.context.delete = [ ];\n    }\n  }\n\n  resolveLinkString(columns, table, prefix) {\n    return this.quoteTableColumns(table, columns, prefix)\n  }\n\n  resolveLinkObject(column) {\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table, column.prefix)\n    }\n    this.errorMsg('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Delete",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Delete.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "class",
    "name": "Delete",
    "memberof": "src/Builder/Delete.js",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Delete}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "subMethods",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.subMethods",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.joint",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Delete.js~Delete",
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.messages",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "generateSQL",
    "memberof": "src/Builder/Delete.js~Delete",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder/Delete.js~Delete.generateSQL",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "resolveLink",
    "memberof": "src/Builder/Delete.js~Delete",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Delete.js~Delete#resolveLink",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Delete.js~Delete",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Delete.js~Delete#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Delete.js~Delete",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Delete.js~Delete#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "file",
    "name": "src/Builder/From.js",
    "content": "import Builder from '../Builder.js';\nimport { isArray, isObject, isString, splitList } from '@abw/badger-utils';\nimport { comma, FROM } from '../Constants.js';\n\nexport class From extends Builder {\n  static buildMethod = 'from'\n  static buildOrder  = 30\n  static keyword     = FROM\n  static joint       = comma\n  static messages = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [table, alias].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"tables\", \"table\" and \"as\".',\n  }\n\n  initBuilder(...tables) {\n    // store the table name for subsequent columns() calls to use, but\n    // we need to be careful to only handle the valid cases, e.g. where\n    // it's a string (which might contain multiple table names), an\n    // array of [table, alias], or an object containing 'table'\n    const table = tables.at(-1);\n    if (isString(table)) {\n      this.tableName = splitList(table).at(-1);\n    }\n    else if (isArray(table) && table.length === 2) {\n      this.tableName = table[1];\n    }\n    else if (isObject(table) && table.as) {\n      this.tableName = table.as;\n    }\n  }\n\n  resolve(context) {\n    return super.resolve(\n      context,\n      // if we've got a table defined then add it to the context\n      this.tableName\n        ? { table: this.tableName }\n        : undefined\n    )\n  }\n\n  resolveLinkString(tables) {\n    // split a string of table names and quote each one\n    return splitList(tables).map(\n      table => this.quote(table)\n    );\n  }\n\n  resolveLinkArray(table) {\n    // a two-element array is [table, alias]\n    return table.length === 2\n      ? this.quoteTableAs(...table)\n      : this.errorMsg('array', { n: table.length });\n  }\n\n  resolveLinkObject(table) {\n    if (table.table) {\n      // if it's an object then it should have a table and optionally an 'as' for an alias\n      return table.as\n        ? this.quoteTableAs(table.table, table.as)\n        : this.quote(table.table)\n    }\n    else if (table.tables) {\n      // or it can have tables\n      return this.resolveLinkString(table.tables);\n    }\n    this.errorMsg('object', { keys: Object.keys(table).sort().join(', ') });\n  }\n}\n\nexport default From",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/From.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 82,
    "kind": "class",
    "name": "From",
    "memberof": "src/Builder/From.js",
    "static": true,
    "longname": "src/Builder/From.js~From",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{From}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/From.js~From",
    "static": true,
    "longname": "src/Builder/From.js~From.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/From.js~From",
    "static": true,
    "longname": "src/Builder/From.js~From.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/From.js~From",
    "static": true,
    "longname": "src/Builder/From.js~From.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/From.js~From",
    "static": true,
    "longname": "src/Builder/From.js~From.joint",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/From.js~From",
    "static": true,
    "longname": "src/Builder/From.js~From.messages",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "tables",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "tableName",
    "memberof": "src/Builder/From.js~From",
    "static": false,
    "longname": "src/Builder/From.js~From#tableName",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "tables",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/From.js~From",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/From.js~From#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/Builder/Group.js",
    "content": "import Builder from '../Builder.js';\nimport { splitList } from '@abw/badger-utils';\nimport { comma, GROUP_BY } from '../Constants.js';\n\nexport class Group extends Builder {\n  static buildMethod = 'group'\n  static buildAlias  = 'groupBy'\n  static buildOrder  = 60\n  static keyword     = GROUP_BY\n  static joint       = comma\n  static messages    = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [column].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"columns\" and \"column\".',\n  }\n\n  resolveLinkString(group) {\n    return splitList(group).map(\n      column => this.quote(column)\n    )\n  }\n\n  resolveLinkArray(group) {\n    if (group.length === 1) {\n      return this.quote(group[0]);\n    }\n    this.errorMsg('array', { n: group.length });\n  }\n\n  resolveLinkObject(group) {\n    if (group.column) {\n      return this.quote(group.column);\n    }\n    else if (group.columns) {\n      return this.resolveLinkString(group.columns)\n    }\n    this.errorMsg('object', { keys: Object.keys(group).sort().join(', ') });\n  }\n}\n\nexport default Group",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Group.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "class",
    "name": "Group",
    "memberof": "src/Builder/Group.js",
    "static": true,
    "longname": "src/Builder/Group.js~Group",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Group}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "buildAlias",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.buildAlias",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.joint",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Group.js~Group",
    "static": true,
    "longname": "src/Builder/Group.js~Group.messages",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Group.js~Group#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "group",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "name": "src/Builder/Having.js",
    "content": "import Where from './Where.js';\nimport { HAVING } from '../Constants.js';\n\nexport class Having extends Where {\n  static buildMethod = 'having'\n  static buildOrder  = 70\n  static keyword     = HAVING\n\n  // Everything works the same as for Where, EXCEPT for the fact that we save\n  // values in a separate list.  Any where() values go in this.context.values,\n  // and having() values go in this.context.havingValues so that we can make\n  // sure that these values are always provided at the end of the query.\n  // e.g. db.select(...).where({a:10}).having({c:30}).where({b:20}) will\n  // generate a query like 'SELECT ... WHERE a=? AND b=? ... HAVING c=?'.\n  // The where() values for a and b (10, 20) must come before the having()\n  // value for b (30)\n  addValues(...values) {\n    this.havingValues(...values)\n  }\n}\n\nexport default Having",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Having.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 108,
    "kind": "class",
    "name": "Having",
    "memberof": "src/Builder/Having.js",
    "static": true,
    "longname": "src/Builder/Having.js~Having",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Having}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Where.js~Where"
    ]
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Having.js~Having",
    "static": true,
    "longname": "src/Builder/Having.js~Having.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Having.js~Having",
    "static": true,
    "longname": "src/Builder/Having.js~Having.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Having.js~Having",
    "static": true,
    "longname": "src/Builder/Having.js~Having.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "addValues",
    "memberof": "src/Builder/Having.js~Having",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Having.js~Having#addValues",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 113,
    "kind": "file",
    "name": "src/Builder/Insert.js",
    "content": "import Builder from '../Builder.js';\nimport { comma, INSERT } from '../Constants.js';\n\nexport class Insert extends Builder {\n  static buildMethod = 'insert'\n  static buildOrder  = 17\n  static subMethods  = 'into join values returning'\n  static keyword     = INSERT\n  static joint       = comma\n  static messages    = {\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"columns\" and \"column\".',\n  }\n\n  static generateSQL() {\n    return this.keyword;\n  }\n\n  resolveLink() {\n    if (this.args.length) {\n      return super.resolveLink();\n    }\n    else {\n      this.context.insert = [ ];\n    }\n  }\n\n  resolveLinkString(columns) {\n    return this.quoteTableColumns(undefined, columns)\n  }\n\n  resolveLinkArray(columns) {\n    return this.quoteTableColumns(undefined, columns)\n  }\n\n  resolveLinkObject(column) {\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table)\n    }\n    this.errorMsg('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Insert",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Insert.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 114,
    "kind": "class",
    "name": "Insert",
    "memberof": "src/Builder/Insert.js",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Insert}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "subMethods",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.subMethods",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.joint",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Insert.js~Insert",
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.messages",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "generateSQL",
    "memberof": "src/Builder/Insert.js~Insert",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder/Insert.js~Insert.generateSQL",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "resolveLink",
    "memberof": "src/Builder/Insert.js~Insert",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Insert.js~Insert#resolveLink",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Insert.js~Insert",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Insert.js~Insert#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Insert.js~Insert",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Insert.js~Insert#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Insert.js~Insert",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Insert.js~Insert#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "file",
    "name": "src/Builder/Into.js",
    "content": "import { blank, comma, INTO, newline, VALUES } from '../Constants.js';\nimport { isArray, isString } from '@abw/badger-utils';\nimport Builder from '../Builder.js';\nimport { parens, spaceAfter, spaceBefore } from '../Utils/Space.js';\n\nexport class Into extends Builder {\n  static buildMethod = 'into'\n  static buildOrder  = 29\n  static keyword     = INTO\n  static joint       = comma\n\n  static generateSQL(values, context) {\n    const keyword  = this.keyword;\n    const joint    = this.joint;\n    const database = context.database;\n    const columns  = context.insert || [ ];\n    let   place    = context.placeholder;\n    const into     = spaceAfter(keyword) + (isArray(values) ? values.join(joint) : values)\n    const cols     = columns.length ? spaceBefore(parens(columns.join(comma))) : blank\n    const vals     = columns.length ? newline + spaceAfter(VALUES) + parens(\n      columns.map(\n        () => database.engine.formatPlaceholder(\n          place++\n        )\n      ).join(comma)\n    ) : blank;\n    return into + cols + vals;\n  }\n\n  initBuilder(...tables) {\n    // store the table name for subsequent columns() calls to use, but\n    if (tables.length === 1 && isString(tables[0])) {\n      this.tableName = tables[0];\n    }\n  }\n\n  resolve(context) {\n    return super.resolve(\n      context,\n      // if we've got a table defined then add it to the context\n      this.tableName\n        ? { table: this.tableName }\n        : undefined\n    )\n  }\n\n  resolveLinkString(table) {\n    // split a string of table names and quote each one\n    return [\n      this.quote(table)\n    ]\n  }\n}\n\nexport default Into",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Into.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 127,
    "kind": "class",
    "name": "Into",
    "memberof": "src/Builder/Into.js",
    "static": true,
    "longname": "src/Builder/Into.js~Into",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Into}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Into.js~Into",
    "static": true,
    "longname": "src/Builder/Into.js~Into.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Into.js~Into",
    "static": true,
    "longname": "src/Builder/Into.js~Into.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Into.js~Into",
    "static": true,
    "longname": "src/Builder/Into.js~Into.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Into.js~Into",
    "static": true,
    "longname": "src/Builder/Into.js~Into.joint",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "generateSQL",
    "memberof": "src/Builder/Into.js~Into",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder/Into.js~Into.generateSQL",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Into.js~Into",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Into.js~Into#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "tables",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "tableName",
    "memberof": "src/Builder/Into.js~Into",
    "static": false,
    "longname": "src/Builder/Into.js~Into#tableName",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Into.js~Into",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Into.js~Into#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Into.js~Into",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Into.js~Into#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "file",
    "name": "src/Builder/Join.js",
    "content": "import Builder from '../Builder.js';\nimport { blank, equals, FULL_JOIN, INNER_JOIN, JOIN, LEFT_JOIN, newline, ON, RIGHT_JOIN } from '../Constants.js';\nimport { spaceAfter, spaceAround } from '../Utils/Space.js';\n\nconst tableColumnRegex = /^(\\w+)\\.(\\w+)$/;\nconst joinRegex = /^(.*?)\\s*(<?=>?)\\s*(\\w+)\\.(\\w+)$/;\nconst joinElements = {\n  from:  1,\n  type:  2,\n  table: 3,\n  to:    4,\n};\nconst joinTypes = {\n  default: JOIN,\n  inner:   INNER_JOIN,\n  '=':     JOIN,\n  left:    LEFT_JOIN,\n  '<=':    LEFT_JOIN,\n  right:   RIGHT_JOIN,\n  '=>':    RIGHT_JOIN,\n  full:    FULL_JOIN,\n  '<=>':   FULL_JOIN,\n};\n\nexport class Join extends Builder {\n  static buildMethod = 'join'\n  static buildOrder  = 40\n  static keyword     = blank\n  static joint       = newline\n  static messages    = {\n    type:   'Invalid join type \"<joinType>\" specified for query builder \"<method>\" component.  Valid types are \"left\", \"right\", \"inner\" and \"full\".',\n    string: 'Invalid join string \"<join>\" specified for query builder \"<method>\" component.  Expected \"from=table.to\".',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"type\", \"table\", \"from\" and \"to\".',\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [type, from, table, to], [from, table, to] or [from, table.to].',\n  }\n\n  resolveLinkString(join) {\n    // join('a=b.c')\n    // join('a.b=c.d')\n    let match = join.match(joinRegex);\n    let config = { };\n    if (match) {\n      Object.entries(joinElements).map(\n        ([key, index]) => config[key] = match[index]\n      );\n      // console.log('parsed join string [%s]:', config);\n      return this.resolveLinkObject(config);\n    }\n    this.errorMsg('string', { join });\n    // return this.resolveLinkArray(splitList(columns), context);\n  }\n\n  resolveLinkArray(join) {\n    if (join.length === 4) {\n      const [type, from, table, to] = join;\n      return this.resolveLinkObject({ type, from, table, to });\n    }\n    else if (join.length === 3) {\n      const [from, table, to] = join;\n      return this.resolveLinkObject({ from, table, to });\n    }\n    else if (join.length === 2) {\n      const match = join[1].match(tableColumnRegex);\n      if (match) {\n        const from = join[0];\n        const [ , table, to] = match;\n        return this.resolveLinkObject({ from, table, to });\n      }\n    }\n    this.errorMsg('array', { n: join.length });\n  }\n\n  resolveLinkObject(join) {\n    const type = joinTypes[join.type || 'default']\n      || this.errorMsg('type', { joinType: join.type });\n\n    if (join.table && join.from && join.to) {\n      return this.constructJoin(\n        type, join.from, join.table, this.tableColumn(join.table, join.to)\n      );\n    }\n    else if (join.from && join.to) {\n      const match = join.to.match(tableColumnRegex);\n      if (match) {\n        return this.constructJoin(\n          type, join.from, match[1], this.tableColumn(match[1], match[2])\n        )\n      }\n    }\n    this.errorMsg('object', { keys: Object.keys(join).sort().join(', ') });\n  }\n\n  constructJoin(type, from, table, to) {\n    return spaceAfter(type)\n      + this.quote(table)\n      + spaceAround(ON)\n      + this.quote(from)\n      + spaceAround(equals)\n      + this.quote(to);\n  }\n}\n\nexport default Join",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Join.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 138,
    "kind": "variable",
    "name": "tableColumnRegex",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~tableColumnRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "joinRegex",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "joinElements",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinElements",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"from\": number, \"type\": number, \"table\": number, \"to\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "variable",
    "name": "joinTypes",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~joinTypes",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "{\"default\": *, \"inner\": *, \"=\": *, \"left\": *, \"<=\": *, \"right\": *, \"=>\": *, \"full\": *, \"<=>\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 142,
    "kind": "class",
    "name": "Join",
    "memberof": "src/Builder/Join.js",
    "static": true,
    "longname": "src/Builder/Join.js~Join",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Join}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Join.js~Join",
    "static": true,
    "longname": "src/Builder/Join.js~Join.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Join.js~Join",
    "static": true,
    "longname": "src/Builder/Join.js~Join.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Join.js~Join",
    "static": true,
    "longname": "src/Builder/Join.js~Join.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Join.js~Join",
    "static": true,
    "longname": "src/Builder/Join.js~Join.joint",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Join.js~Join",
    "static": true,
    "longname": "src/Builder/Join.js~Join.messages",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "join",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "constructJoin",
    "memberof": "src/Builder/Join.js~Join",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Join.js~Join#constructJoin",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "from",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "to",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "file",
    "name": "src/Builder/Limit.js",
    "content": "import Simple from './Simple.js';\nimport { LIMIT } from '../Constants.js';\n\nexport class Limit extends Simple {\n  static buildMethod = 'limit'\n  static buildOrder  = 90\n  static keyword     = LIMIT\n\n  initBuilder(limit) {\n    this.value = limit;\n  }\n}\n\nexport default Limit\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Limit.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 153,
    "kind": "class",
    "name": "Limit",
    "memberof": "src/Builder/Limit.js",
    "static": true,
    "longname": "src/Builder/Limit.js~Limit",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Limit}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Simple.js~Simple"
    ]
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Limit.js~Limit",
    "static": true,
    "longname": "src/Builder/Limit.js~Limit.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Limit.js~Limit",
    "static": true,
    "longname": "src/Builder/Limit.js~Limit.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Limit.js~Limit",
    "static": true,
    "longname": "src/Builder/Limit.js~Limit.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Limit.js~Limit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Limit.js~Limit#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "limit",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "value",
    "memberof": "src/Builder/Limit.js~Limit",
    "static": false,
    "longname": "src/Builder/Limit.js~Limit#value",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "file",
    "name": "src/Builder/Offset.js",
    "content": "import Simple from './Simple.js';\nimport { OFFSET } from '../Constants.js';\n\nexport class Offset extends Simple {\n  static buildMethod = 'offset'\n  static buildOrder  = 95\n  static keyword     = OFFSET\n\n  initBuilder(offset) {\n    this.value = offset;\n  }\n}\n\nexport default Offset\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Offset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 160,
    "kind": "class",
    "name": "Offset",
    "memberof": "src/Builder/Offset.js",
    "static": true,
    "longname": "src/Builder/Offset.js~Offset",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Offset}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Simple.js~Simple"
    ]
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Offset.js~Offset",
    "static": true,
    "longname": "src/Builder/Offset.js~Offset.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Offset.js~Offset",
    "static": true,
    "longname": "src/Builder/Offset.js~Offset.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Offset.js~Offset",
    "static": true,
    "longname": "src/Builder/Offset.js~Offset.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Offset.js~Offset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Offset.js~Offset#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "value",
    "memberof": "src/Builder/Offset.js~Offset",
    "static": false,
    "longname": "src/Builder/Offset.js~Offset#value",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/Builder/Order.js",
    "content": "import Builder from '../Builder.js';\nimport { splitList } from '@abw/badger-utils';\nimport { comma, ASC, DESC, ORDER_BY, space } from '../Constants.js';\n\nexport class Order extends Builder {\n  static buildMethod = 'order'\n  static buildAlias  = 'orderBy'\n  static buildOrder  = 80\n  static keyword     = ORDER_BY\n  static joint       = comma\n  static messages = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [column, direction] or [column].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"columns\", \"column\", \"direction\", \"dir\", \"asc\" and \"desc\".',\n  };\n\n  resolveLinkString(order, dir) {\n    return splitList(order).map(\n      column => this.constructOrder(column)\n    ).join(', ') + (dir ? space + dir : '');\n  }\n\n  resolveLinkArray(order) {\n    if (order.length === 2 || order.length === 1) {\n      return this.constructOrder(...order);\n    }\n    this.errorMsg('array', { n: order.length });\n  }\n\n  resolveLinkObject(order) {\n    const dir = order.direction || order.dir\n      || (order.desc && DESC)\n      || (order.asc  && ASC);\n\n    if (order.column) {\n      return this.constructOrder(order.column, dir);\n    }\n    else if (order.columns) {\n      return this.resolveLinkString(order.columns, dir)\n    }\n    this.errorMsg('object', { keys: Object.keys(order).sort().join(', ') });\n  }\n\n  constructOrder(column, dir) {\n    return this.quote(column) + (dir ? space + dir : '');\n  }\n}\n\nexport default Order",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Order.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "class",
    "name": "Order",
    "memberof": "src/Builder/Order.js",
    "static": true,
    "longname": "src/Builder/Order.js~Order",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Order}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "buildAlias",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.buildAlias",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.joint",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Order.js~Order",
    "static": true,
    "longname": "src/Builder/Order.js~Order.messages",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      },
      {
        "name": "dir",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "order",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "constructOrder",
    "memberof": "src/Builder/Order.js~Order",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Order.js~Order#constructOrder",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "dir",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "file",
    "name": "src/Builder/Prefix.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Prefix extends Builder {\n  static buildMethod = 'prefix'\n\n  initBuilder(prefix) {\n    this.prefix = prefix;\n  }\n\n  resolve(context) {\n    this.context = {\n      ...context,\n      prefix: this.prefix\n    }\n    return this.context;\n  }\n}\n\nexport default Prefix\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Prefix.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 179,
    "kind": "class",
    "name": "Prefix",
    "memberof": "src/Builder/Prefix.js",
    "static": true,
    "longname": "src/Builder/Prefix.js~Prefix",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Prefix}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": true,
    "longname": "src/Builder/Prefix.js~Prefix.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "prefix",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#prefix",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Prefix.js~Prefix",
    "static": false,
    "longname": "src/Builder/Prefix.js~Prefix#context",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, \"prefix\": *}"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "file",
    "name": "src/Builder/Range.js",
    "content": "import Builder from '../Builder.js';\nimport { isInteger, isObject } from '@abw/badger-utils';\n\nexport class Range extends Builder {\n  static buildMethod = 'range'\n  static messages = {\n    arg:    'Invalid argument specified for query builder \"<method>\" component. Expected (from, to), (from) or object.',\n    args:   'Invalid arguments with <n> items specified for query builder \"<method>\" component. Expected (from, to), (from) or object.',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"from\", \"to\", \"limit\" and \"offset\".',\n  }\n\n  initBuilder(...args) {\n    if (args.length === 2) {\n      this.args = this.twoNumberArgs(...args);\n    }\n    else if (args.length === 1) {\n      const arg = args[0];\n      if (isInteger(arg)) {\n        this.args = this.oneNumberArg(arg);\n      }\n      else if (isObject(arg)) {\n        this.args = this.objectArgs(arg);\n      }\n      else {\n        this.errorMsg('arg');\n      }\n    }\n    else {\n      this.errorMsg('args', { n: args.length });\n    }\n  }\n\n  twoNumberArgs(from, to) {\n    return {\n      offset: from,\n      limit: (to - from) + 1\n    }\n  }\n\n  oneNumberArg(from) {\n    return {\n      offset: from\n    }\n  }\n\n  objectArgs(args) {\n    if (args.from && args.to) {\n      return this.twoNumberArgs(args.from, args.to);\n    }\n    else if (args.from) {\n      return this.oneNumberArg(args.from);\n    }\n    else if (args.to) {\n      return {\n        limit: args.to + 1\n      };\n    }\n    else if (args.limit || args.offset) {\n      return {\n        limit:  args.limit,\n        offset: args.offset,\n      }\n    }\n    else {\n      this.errorMsg('object', { keys: Object.keys(args).sort().join(', ') });\n    }\n  }\n\n  resolve(context) {\n    this.context = {\n      ...context,\n      ...this.args,\n    }\n    return this.context;\n  }\n}\n\nexport default Range\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Range.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 186,
    "kind": "class",
    "name": "Range",
    "memberof": "src/Builder/Range.js",
    "static": true,
    "longname": "src/Builder/Range.js~Range",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Range}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Range.js~Range",
    "static": true,
    "longname": "src/Builder/Range.js~Range.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Range.js~Range",
    "static": true,
    "longname": "src/Builder/Range.js~Range.messages",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Range.js~Range",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Range.js~Range#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "args",
    "memberof": "src/Builder/Range.js~Range",
    "static": false,
    "longname": "src/Builder/Range.js~Range#args",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "twoNumberArgs",
    "memberof": "src/Builder/Range.js~Range",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Range.js~Range#twoNumberArgs",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "from",
        "types": [
          "*"
        ]
      },
      {
        "name": "to",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"offset\": *, \"limit\": *}"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "oneNumberArg",
    "memberof": "src/Builder/Range.js~Range",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Range.js~Range#oneNumberArg",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "from",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"offset\": *}"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "objectArgs",
    "memberof": "src/Builder/Range.js~Range",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Range.js~Range#objectArgs",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"limit\": *, \"offset\": *}"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Range.js~Range",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Range.js~Range#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Range.js~Range",
    "static": false,
    "longname": "src/Builder/Range.js~Range#context",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, ...undefined: Object}"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "file",
    "name": "src/Builder/Returning.js",
    "content": "import Select from './Select.js';\nimport { RETURNING } from '../Constants.js';\n\nexport class Returning extends Select {\n  static buildMethod = 'returning'\n  static buildOrder  = 96\n  static keyword     = RETURNING\n}\n\nexport default Returning",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Returning.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 199,
    "kind": "class",
    "name": "Returning",
    "memberof": "src/Builder/Returning.js",
    "static": true,
    "longname": "src/Builder/Returning.js~Returning",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Returning}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Select.js~Select"
    ]
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Returning.js~Returning",
    "static": true,
    "longname": "src/Builder/Returning.js~Returning.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Returning.js~Returning",
    "static": true,
    "longname": "src/Builder/Returning.js~Returning.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Returning.js~Returning",
    "static": true,
    "longname": "src/Builder/Returning.js~Returning.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "file",
    "name": "src/Builder/Select.js",
    "content": "import Builder from '../Builder.js';\nimport { comma, SELECT } from '../Constants.js';\n\nexport class Select extends Builder {\n  static buildMethod = 'select'\n  static buildOrder  = 20;\n  static subMethods  = 'select columns from table prefix join where having group groupBy order orderBy limit offset range returning'\n  static keyword     = SELECT\n  static joint       = comma\n  static messages    = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [column, alias] or [table, column, alias].',\n    object: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"columns\", \"column\", \"table\", \"prefix\" and \"as\".',\n  }\n\n  resolveLinkString(columns, table, prefix) {\n    return this.quoteTableColumns(table, columns, prefix)\n  }\n\n  resolveLinkArray(columns) {\n    if (columns.length === 2) {\n      // a two-element array is [column, alias]\n      return this.quoteColumnAs(...columns);\n    }\n    else if (columns.length === 3) {\n      // a three-element array is [table, column, alias]\n      return this.quoteTableColumnAs(...columns)\n    }\n    this.errorMsg('array', { n: columns.length });\n  }\n\n  resolveLinkObject(column) {\n    if (column.column && column.as) {\n      // object can contain \"column\", \"as\" and optional \"table\"\n      return column.table\n        ? this.quoteTableColumnAs(\n          column.table,\n          column.column,\n          column.as\n        )\n        : this.quoteColumnAs(\n          column.column,\n          column.as\n        )\n    }\n    // otherwise it should define \"column\" or \"columns\"\n    const cols = column.column || column.columns;\n    if (cols) {\n      return this.resolveLinkString(cols, column.table, column.prefix)\n    }\n    this.errorMsg('object', { keys: Object.keys(column).sort().join(', ') });\n  }\n}\n\nexport default Select",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Select.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 204,
    "kind": "class",
    "name": "Select",
    "memberof": "src/Builder/Select.js",
    "static": true,
    "longname": "src/Builder/Select.js~Select",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Select}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "member",
    "name": "subMethods",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.subMethods",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.joint",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Select.js~Select",
    "static": true,
    "longname": "src/Builder/Select.js~Select.messages",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Select.js~Select",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Select.js~Select#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "file",
    "name": "src/Builder/Set.js",
    "content": "import Where from './Where.js';\nimport { comma, SET } from '../Constants.js';\n\nexport class Set extends Where {\n  static buildMethod = 'set'\n  static buildOrder  = 45\n  static keyword     = SET\n  static joint       = comma\n  static messages = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [column, value].',\n    object: 'Invalid value array with <n> items specified for query builder \"<method>\" component. Expected [value] or [operator, value].',\n  }\n\n  // This works in a similar way to Where, EXCEPT for the fact that\n  // we save values in a separate list, this.context.setValues.\n  addValues(...values) {\n    this.setValues(...values)\n  }\n\n  resolveLinkArray(criteria) {\n    // don't allow three arguments - comparisons are not valid here\n    if (criteria.length == 2) {\n      this.addValues(criteria[1]);\n      return this.lookupDatabase().engine\n        .formatSetPlaceholder(\n          criteria[0],\n          this.context.placeholder++\n        )\n    }\n    else {\n      this.errorMsg('array', { n: criteria.length });\n    }\n  }\n}\n\nexport default Set",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Set.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 215,
    "kind": "class",
    "name": "Set",
    "memberof": "src/Builder/Set.js",
    "static": true,
    "longname": "src/Builder/Set.js~Set",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Set}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Where.js~Where"
    ]
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Set.js~Set",
    "static": true,
    "longname": "src/Builder/Set.js~Set.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Set.js~Set",
    "static": true,
    "longname": "src/Builder/Set.js~Set.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Set.js~Set",
    "static": true,
    "longname": "src/Builder/Set.js~Set.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Set.js~Set",
    "static": true,
    "longname": "src/Builder/Set.js~Set.joint",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Set.js~Set",
    "static": true,
    "longname": "src/Builder/Set.js~Set.messages",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "addValues",
    "memberof": "src/Builder/Set.js~Set",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Set.js~Set#addValues",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Set.js~Set",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Set.js~Set#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "file",
    "name": "src/Builder/Simple.js",
    "content": "import { isArray } from '@abw/badger-utils';\nimport Builder from '../Builder.js';\nimport { spaceAfter } from '../Utils/Space.js';\n\n// Base class for a couple of simple builders that\n// only take a single value: Limit and Offset\n\nexport class Simple extends Builder {\n  static buildMethod = 'simple'\n\n  static generateSQL(values) {\n    const keyword = this.keyword;\n    return spaceAfter(keyword)\n      + (isArray(values) ? values.at(-1) : values);\n  }\n\n  initBuilder(value) {\n    this.value = value;\n  }\n\n  resolve(context) {\n    this.context = {\n      ...context,\n      [this.slot]: this.value\n    }\n    return this.context;\n  }\n}\n\nexport default Simple\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Simple.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 224,
    "kind": "class",
    "name": "Simple",
    "memberof": "src/Builder/Simple.js",
    "static": true,
    "longname": "src/Builder/Simple.js~Simple",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Simple}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Simple.js~Simple",
    "static": true,
    "longname": "src/Builder/Simple.js~Simple.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "generateSQL",
    "memberof": "src/Builder/Simple.js~Simple",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder/Simple.js~Simple.generateSQL",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Simple.js~Simple",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Simple.js~Simple#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "value",
    "memberof": "src/Builder/Simple.js~Simple",
    "static": false,
    "longname": "src/Builder/Simple.js~Simple#value",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Simple.js~Simple",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Simple.js~Simple#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Simple.js~Simple",
    "static": false,
    "longname": "src/Builder/Simple.js~Simple#context",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, \"undefined\": *}"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "file",
    "name": "src/Builder/Table.js",
    "content": "import Builder from '../Builder.js';\n\nexport class Table extends Builder {\n  static buildMethod = 'table'\n\n  initBuilder(table) {\n    this.tableName = table;\n  }\n\n  resolve(context) {\n    this.context = {\n      ...context,\n      table: this.tableName\n    }\n    return this.context;\n  }\n}\n\nexport default Table\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Table.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 232,
    "kind": "class",
    "name": "Table",
    "memberof": "src/Builder/Table.js",
    "static": true,
    "longname": "src/Builder/Table.js~Table",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Table}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Table.js~Table",
    "static": true,
    "longname": "src/Builder/Table.js~Table.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Table.js~Table#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "member",
    "name": "tableName",
    "memberof": "src/Builder/Table.js~Table",
    "static": false,
    "longname": "src/Builder/Table.js~Table#tableName",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Table.js~Table#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder/Table.js~Table",
    "static": false,
    "longname": "src/Builder/Table.js~Table#context",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, \"table\": *}"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "src/Builder/Update.js",
    "content": "import From from './From.js';\nimport { comma, UPDATE } from '../Constants.js';\n\nexport class Update extends From {\n  static buildMethod = 'update'\n  static buildOrder  = 18\n  static subMethods  = 'join set where order order_by limit returning'\n  static keyword     = UPDATE\n  static joint       = comma\n}\n\nexport default Update",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Update.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "class",
    "name": "Update",
    "memberof": "src/Builder/Update.js",
    "static": true,
    "longname": "src/Builder/Update.js~Update",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Update}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/From.js~From"
    ]
  },
  {
    "__docId__": 240,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Update.js~Update",
    "static": true,
    "longname": "src/Builder/Update.js~Update.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Update.js~Update",
    "static": true,
    "longname": "src/Builder/Update.js~Update.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "member",
    "name": "subMethods",
    "memberof": "src/Builder/Update.js~Update",
    "static": true,
    "longname": "src/Builder/Update.js~Update.subMethods",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Update.js~Update",
    "static": true,
    "longname": "src/Builder/Update.js~Update.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Update.js~Update",
    "static": true,
    "longname": "src/Builder/Update.js~Update.joint",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "file",
    "name": "src/Builder/Values.js",
    "content": "import Builder from '../Builder.js';\nimport { isFloat, isInteger } from '@abw/badger-utils';\n\nexport class Values extends Builder {\n  static buildMethod = 'values'\n  static buildOrder  = 0\n\n  // values() is used to provide pre-defined values for the INSERT INTO clause.\n  // It adds the values to setValues() when the link is resolved but doesn't\n  // generate any output - see Into.js for where the VALUES clause is created\n\n  resolveLinkItem(item) {\n    if (isInteger(item) || isFloat(item)) {\n      return this.resolveLinkString(item);\n    }\n    return super.resolveLinkItem(item)\n  }\n\n  resolveLinkString(value) {\n    this.setValues(value)\n    return [];\n  }\n\n  resolveLinkArray(values) {\n    values.forEach(\n      value => {\n        this.setValues(value)\n      }\n    )\n    return [ ];\n  }\n}\n\nexport default Values",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Values.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 246,
    "kind": "class",
    "name": "Values",
    "memberof": "src/Builder/Values.js",
    "static": true,
    "longname": "src/Builder/Values.js~Values",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Values}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Values.js~Values",
    "static": true,
    "longname": "src/Builder/Values.js~Values.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Values.js~Values",
    "static": true,
    "longname": "src/Builder/Values.js~Values.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "resolveLinkItem",
    "memberof": "src/Builder/Values.js~Values",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Values.js~Values#resolveLinkItem",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Values.js~Values",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Values.js~Values#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Values.js~Values",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Values.js~Values#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "file",
    "name": "src/Builder/Where.js",
    "content": "import Builder from '../Builder.js';\nimport { hasValue, isArray, splitList } from '@abw/badger-utils';\nimport { AND, WHERE, space } from '../Constants.js';\n\nexport class Where extends Builder {\n  static buildMethod = 'where'\n  static buildOrder  = 50\n  static keyword     = WHERE\n  static joint       = space + AND + space\n  static messages = {\n    array:  'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [column, value] or [column, operator, value].',\n    object: 'Invalid value array with <n> items specified for query builder \"<method>\" component. Expected [value] or [operator, value].',\n  }\n\n  resolveLinkString(columns) {\n    const database = this.lookupDatabase();\n    // split columns into a list and generate criteria with placeholders\n    return splitList(columns).map(\n      column => database.engine.formatWherePlaceholder(\n        column,\n        undefined,\n        this.context.placeholder++\n      )\n    )\n  }\n\n  resolveLinkArray(criteria) {\n    const database = this.lookupDatabase();\n    if (criteria.length === 2) {\n      let match;\n      // a two-element array can be [column, [operator]] or [column, [operator, value]]\n      if (isArray(criteria[1])) {\n        if (hasValue(criteria[1][1])) {\n          this.addValues(criteria[1][1]);\n        }\n        match = [criteria[1][0], undefined];\n      }\n      else {\n        this.addValues(criteria[1]);\n      }\n      return database.engine.formatWherePlaceholder(\n        criteria[0],\n        match,\n        this.context.placeholder++\n      )\n    }\n    else if (criteria.length === 3) {\n      // a two-element array is [column, operator, value]\n      if (hasValue(criteria[2])) {\n        this.addValues(criteria[2]);\n      }\n      return database.engine.formatWherePlaceholder(\n        criteria[0],\n        [criteria[1], undefined],\n        this.context.placeholder++\n      )\n    }\n    else {\n      this.errorMsg('array', { n: criteria.length });\n    }\n  }\n\n  resolveLinkObject(criteria) {\n    const database = this.lookupDatabase();\n    let values = [ ];\n    const result = Object.entries(criteria).map(\n      ([column, value]) => {\n        if (isArray(value)) {\n          // the value can be a two element array: [operator, value]\n          // or a single element array: [operator]\n          if (value.length === 2) {\n            values.push(value[1])\n          }\n          else if (value.length !== 1) {\n            this.errorMsg('object', { n: value.length });\n          }\n        }\n        else {\n          // otherwise we assume it's just a value\n          values.push(value)\n        }\n        // generate the criteria with a placeholder\n        return database.engine.formatWherePlaceholder(\n          column,\n          value,\n          this.context.placeholder++\n        )\n      }\n    )\n    if (values.length) {\n      this.addValues(...values);\n    }\n    return result;\n  }\n\n  addValues(...values) {\n    // Subclasses Having.js and Set.js redefine this to save the values\n    // in different lists (havingValues() and setValues() respectively)\n    this.whereValues(...values)\n  }\n}\n\nexport default Where",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/Where.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 253,
    "kind": "class",
    "name": "Where",
    "memberof": "src/Builder/Where.js",
    "static": true,
    "longname": "src/Builder/Where.js~Where",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Where}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/Where.js~Where",
    "static": true,
    "longname": "src/Builder/Where.js~Where.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/Where.js~Where",
    "static": true,
    "longname": "src/Builder/Where.js~Where.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/Where.js~Where",
    "static": true,
    "longname": "src/Builder/Where.js~Where.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/Where.js~Where",
    "static": true,
    "longname": "src/Builder/Where.js~Where.joint",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/Where.js~Where",
    "static": true,
    "longname": "src/Builder/Where.js~Where.messages",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "addValues",
    "memberof": "src/Builder/Where.js~Where",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/Where.js~Where#addValues",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 263,
    "kind": "file",
    "name": "src/Builder/With.js",
    "content": "import Builder from './Builder.js';\nimport { comma, WITH } from '../Constants.js';\n\nexport class With extends Builder {\n  static buildMethod = 'with'\n  static buildOrder  = 10\n  static keyword     = WITH\n  static joint       = comma\n  static messages    = {\n    todo:    'Query builder \"<method>\" component is TODO',\n    array:   'Invalid array with <n> items specified for query builder \"<method>\" component. Expected [...].',\n    object:  'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Valid properties are \"xxx\".',\n    missing: 'Invalid object with \"<keys>\" properties specified for query builder \"<method>\" component.  Required \"<key>\" property is missing.',\n  }\n\n  initBuilder() {\n    this.errorMsg('todo');\n  }\n\n  resolveLinkArray(arg) {\n    if (arg.length === 2) {\n      return this.resolveLinkObject({\n        with: arg[0],\n        as:   arg[1]\n      })\n    }\n    else if (arg.length === 3) {\n      return this.resolveLinkObject({\n        with: arg[0],\n        as:   arg[1]\n      })\n    }\n    this.errorMsg('array', { n: arg.length });\n  }\n\n  resolveLinkObject(arg) {\n    // const keys = Object.keys(arg).sort().join(', ');\n    // const name = arg.with || this.errorMsg('missing', { key: 'with', keys })\n    // const as   = arg.as   || this.errorMsg('missing', { key: 'with', keys })\n    // const cols = arg.columns;\n    this.errorMsg('object', { keys: Object.keys(arg).sort().join(', ') });\n  }\n}\n\nexport default With\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder/With.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 264,
    "kind": "class",
    "name": "With",
    "memberof": "src/Builder/With.js",
    "static": true,
    "longname": "src/Builder/With.js~With",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{With}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Builder/Builder.js~Builder"
    ]
  },
  {
    "__docId__": 265,
    "kind": "member",
    "name": "buildMethod",
    "memberof": "src/Builder/With.js~With",
    "static": true,
    "longname": "src/Builder/With.js~With.buildMethod",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "buildOrder",
    "memberof": "src/Builder/With.js~With",
    "static": true,
    "longname": "src/Builder/With.js~With.buildOrder",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "member",
    "name": "keyword",
    "memberof": "src/Builder/With.js~With",
    "static": true,
    "longname": "src/Builder/With.js~With.keyword",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "member",
    "name": "joint",
    "memberof": "src/Builder/With.js~With",
    "static": true,
    "longname": "src/Builder/With.js~With.joint",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder/With.js~With",
    "static": true,
    "longname": "src/Builder/With.js~With.messages",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder/With.js~With",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/With.js~With#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder/With.js~With",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/With.js~With#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "arg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder/With.js~With",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder/With.js~With#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "arg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 273,
    "kind": "file",
    "name": "src/Builder.js",
    "content": "import { newline, unknown } from \"./Constants.js\";\nimport { addDebugMethod, format, spaceAfter, notImplementedInBaseClass, QueryBuilderError } from \"./Utils/index.js\";\nimport { fail, hasValue, isArray, isFunction, isObject, isString, noValue, splitList } from \"@abw/badger-utils\";\n\nexport let Builders   = { };\nexport let Generators = { };\n\nconst defaultContext = () => ({\n  setValues:    [ ],\n  whereValues:  [ ],\n  havingValues: [ ],\n  placeholder:  1,\n});\n\nconst notImplemented = notImplementedInBaseClass('Builder');\n\nexport class Builder {\n  static generateSQL(values) {\n    const keyword = this.keyword;\n    const joint   = this.joint;\n    return spaceAfter(keyword)\n      + (isArray(values) ? values.join(joint) : values);\n  }\n\n  constructor(parent, ...args) {\n    this.parent   = parent;\n    this.args     = args;\n\n    // copy static class variables into this, including messages for generating\n    // error messages via errorMsg(), the name of the build method which is also\n    // the default slot for storing things in the context\n    this.messages = this.constructor.messages;\n    this.method   = this.constructor.buildMethod;\n    this.slot     = this.constructor.contextSlot || this.method;\n\n    // call the initialisation method to allow subclasses to tweak these\n    this.initBuilder(...args);\n\n    // add debug() and debugData() methods\n    addDebugMethod(this, 'builder', { debugPrefix: this.method && `Builder:${this.method}` });\n  }\n\n  initBuilder() {\n    // stub for subclasses\n  }\n\n  async one(args, options) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.allValues(args);\n    this.debugData(\"one()\", { sql, values });\n    return db.one(sql, values, options);\n  }\n\n  async any(args, options) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.allValues(args);\n    this.debugData(\"any()\", { sql, values });\n    return db.any(sql, values, options);\n  }\n\n  async all(args, options={}) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.allValues(args);\n    this.debugData(\"all()\", { sql, values });\n    return db.all(sql, values, options);\n  }\n\n  async run(args, options={}) {\n    const sql    = this.sql();\n    const db     = this.lookupDatabase();\n    const values = this.allValues(args);\n    this.debugData(\"all()\", { sql, values });\n    return db.run(sql, values, { ...options, sanitizeResult: true });\n  }\n\n  contextValues() {\n    const { setValues, whereValues, havingValues } = this.resolveChain();\n    return { setValues, whereValues, havingValues };\n  }\n\n  allValues(where=[]) {\n    const { setValues, whereValues, havingValues } = this.resolveChain();\n\n    // In the usual case we just get one set of extra args and they\n    // go at the end.  But if there's some need to jiggle the parameters\n    // more then a function can be provided.\n    if (isFunction(where)) {\n      return where(setValues, whereValues, havingValues);\n    }\n    return [...setValues, ...whereValues, ...havingValues, ...where]\n  }\n\n  setValues(...values) {\n    if (values.length) {\n      this.context.setValues = [\n        ...this.context.setValues, ...values\n      ];\n    }\n    return this.context.setValues;\n  }\n\n  whereValues(...values) {\n    if (values.length) {\n      this.context.whereValues = [\n        ...this.context.whereValues, ...values\n      ];\n    }\n    return this.context.whereValues;\n  }\n\n  havingValues(...values) {\n    if (values.length) {\n      this.context.havingValues = [\n        ...this.context.havingValues, ...values\n      ];\n    }\n    return this.context.havingValues;\n  }\n\n  sql() {\n    // to generate SQL we first generate a context containing all the\n    // information collected from the query builder chain...\n    const context = this.resolveChain();\n\n    // ...then we call the generateSQL() static method on each class in\n    // the order determined by their static buildOrder\n    return Object.entries(Generators)\n      // sort generators by the buildOrder - the second array element in the value\n      .sort( (a, b) => a[1][1] - b[1][1] )\n      // filter out any that don't have slots defined\n      .filter( ([slot]) => context[slot] )\n      // call the generateSQL() static method\n      .map( ([slot, entry]) => entry[0].generateSQL(context[slot], context) )\n      // filter out any that didn't return a value\n      .filter( i => hasValue(i) )\n      // join together into a single string\n      .join(newline);\n  }\n\n  // resolve the complete chain from top to bottom\n  resolveChain() {\n    return this.context || this.resolve(\n      this.parent\n        ? this.parent.resolveChain()\n        : defaultContext()\n    );\n  }\n\n  // resolve a link in the chain and merge into parent context\n  resolve(context, args={}) {\n    const slot = this.slot;\n    this.context = {\n      ...context,\n      ...args\n    }\n    const values = this.resolveLink();\n    if (values && values.length) {\n      this.context[slot] = [...(this.context[slot] || []), ...values];\n    }\n    return this.context;\n  }\n\n  // resolve a link in the chain\n  resolveLink() {\n    return this.args.map(\n      item => (isObject(item) && item.sql)\n        ? item.sql\n        : this.resolveLinkItem(item)\n    ).flat()\n  }\n\n  // resolve an individual argument for a link in the chain\n  resolveLinkItem(item) {\n    if (isString(item)) {\n      return this.resolveLinkString(item);\n    }\n    else if (isArray(item)) {\n      return this.resolveLinkArray(item);\n    }\n    else if (isFunction(item)) {\n      return item(this);\n    }\n    else if (isObject(item)) {\n      return this.resolveLinkObject(item);\n    }\n    else if (noValue(item)) {\n      return this.resolveLinkNothing(item);\n    }\n    fail(\"Invalid query builder value: \", item);\n  }\n\n  resolveLinkString() {\n    notImplemented(\"resolveLinkString()\");\n  }\n\n  resolveLinkArray() {\n    notImplemented(\"resolveLinkArray()\");\n  }\n\n  resolveLinkObject() {\n    notImplemented(\"resolveLinkObject()\");\n  }\n\n  resolveLinkNothing() {\n    return [ ];\n  }\n\n  // utility methods\n  lookup(key, error) {\n    return this[key] ||\n      (this.parent\n        ? this.parent.lookup(key)\n        : fail(error || `Missing item in query chain: ${key}`))\n  }\n\n  lookupDatabase() {\n    return this.context.database || this.lookup('database');\n  }\n\n  lookupTable() {\n    return this.context.table || this.lookup('table');\n  }\n\n  quote(item) {\n    return this.lookupDatabase().quote(item)\n  }\n\n  quoteTableColumns(table, columns, prefix) {\n    // function to map columns to depends on table and/or prefix being defined\n    const func = table\n      ? prefix\n        ? column => this.quoteTableColumnAs(table, column, prefix + column)\n        : column => this.quoteTableColumn(table, column)\n      : prefix\n        ? column => this.quoteColumnAs(column, prefix + column)\n        : column => this.quote(column)\n    ;\n    // split string into items and apply function\n    return splitList(columns).map(func);\n  }\n\n  tableColumn(table, column) {\n    return column.match(/\\./)\n      ? column\n      : `${table}.${column}`;\n  }\n\n  quoteTableColumn(table, column) {\n    return this.quote(\n      this.tableColumn(table, column)\n    )\n  }\n\n  quoteTableAs(table, as) {\n    return [\n      this.quote(table),\n      this.quote(as)\n    ].join(' AS ');\n  }\n\n  quoteTableColumnAs(table, column, as) {\n    return [\n      this.quoteTableColumn(table, column),\n      this.quote(as)\n    ].join(' AS ')\n  }\n\n  quoteColumnAs(column, as) {\n    return [\n      this.quote(column),\n      this.quote(as)\n    ].join(' AS ')\n  }\n\n  errorMsg(msgFormat, args) {\n    const method = this.method || unknown;\n    return this.error(\n      format(\n        this.messages?.[msgFormat] || fail(\"Invalid message format: \", msgFormat),\n        { method, ...args }\n      )\n    )\n  }\n\n  toString() {\n    return this.sql();\n  }\n\n  error(...args) {\n    const etype   = this.errorType || QueryBuilderError;\n    throw new etype(args.join(''))\n  }\n}\n\nexport default Builder",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 274,
    "kind": "variable",
    "name": "Builders",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~Builders",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Builders}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "name": "Generators",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~Generators",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Generators}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "defaultContext",
    "memberof": "src/Builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder.js~defaultContext",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "variable",
    "name": "notImplemented",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~notImplemented",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 278,
    "kind": "class",
    "name": "Builder",
    "memberof": "src/Builder.js",
    "static": true,
    "longname": "src/Builder.js~Builder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Builder}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "generateSQL",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builder.js~Builder.generateSQL",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "parent",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#parent",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "args",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#args",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#messages",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "method",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#method",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "member",
    "name": "slot",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#slot",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "initBuilder",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#initBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "one",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#one",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "any",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#any",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "all",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#all",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "run",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Builder.js~Builder#run",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "contextValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#contextValues",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"setValues\": *, \"whereValues\": *, \"havingValues\": *}"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "allValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#allValues",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "setValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#setValues",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "whereValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#whereValues",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "havingValues",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#havingValues",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "sql",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#sql",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "resolveChain",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveChain",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "resolve",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "member",
    "name": "context",
    "memberof": "src/Builder.js~Builder",
    "static": false,
    "longname": "src/Builder.js~Builder#context",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "type": {
      "types": [
        "{...context: Object, ...args: Object}"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "resolveLink",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLink",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "resolveLinkItem",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkItem",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "resolveLinkString",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkString",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "resolveLinkArray",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkArray",
    "access": "public",
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "resolveLinkObject",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkObject",
    "access": "public",
    "description": null,
    "lineNumber": 203,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "resolveLinkNothing",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#resolveLinkNothing",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "lookup",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookup",
    "access": "public",
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "lookupDatabase",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookupDatabase",
    "access": "public",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "lookupTable",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#lookupTable",
    "access": "public",
    "description": null,
    "lineNumber": 223,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quote",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "quoteTableColumns",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableColumns",
    "access": "public",
    "description": null,
    "lineNumber": 231,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "tableColumn",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#tableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "quoteTableColumn",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 251,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "quoteTableAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableAs",
    "access": "public",
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "quoteTableColumnAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteTableColumnAs",
    "access": "public",
    "description": null,
    "lineNumber": 264,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "quoteColumnAs",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#quoteColumnAs",
    "access": "public",
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "as",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "errorMsg",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#errorMsg",
    "access": "public",
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "params": [
      {
        "name": "msgFormat",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "toString",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#toString",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "error",
    "memberof": "src/Builder.js~Builder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Builder.js~Builder#error",
    "access": "public",
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 319,
    "kind": "file",
    "name": "src/Builders.js",
    "content": "import { hasValue, splitList } from '@abw/badger-utils';\nimport { Builders, Generators } from './Builder.js';\nimport After     from './Builder/After.js';\nimport Before    from './Builder/Before.js';\nimport Columns   from './Builder/Columns.js';\nimport Database  from './Builder/Database.js';\nimport Delete    from './Builder/Delete.js';\nimport From      from './Builder/From.js';\nimport Group     from './Builder/Group.js';\nimport Having    from './Builder/Having.js';\nimport Insert    from './Builder/Insert.js';\nimport Into      from './Builder/Into.js';\nimport Join      from './Builder/Join.js';\nimport Limit     from './Builder/Limit.js';\nimport Offset    from './Builder/Offset.js';\nimport Order     from './Builder/Order.js';\nimport Prefix    from './Builder/Prefix.js';\nimport Range     from './Builder/Range.js';\nimport Returning from './Builder/Returning.js';\nimport Select    from './Builder/Select.js';\nimport Set       from './Builder/Set.js';\nimport Table     from './Builder/Table.js';\nimport Update    from './Builder/Update.js';\nimport Values    from './Builder/Values.js';\nimport Where     from './Builder/Where.js';\nimport Proxy     from './Proxy/Builder.js';\n\nexport const registerBuilder = module => {\n  const slot  = module.contextSlot || module.buildMethod;\n  const order = module.buildOrder;\n\n  /*\n  const method = module.buildMethod;\n  const alias  = splitList(module.buildAlias);\n  console.log('register [%s] as', [method, ...alias]);\n  console.log('register [%s] => [slot:%s] [order:%s]', method, slot, order);\n  */\n\n  // Register the main buildMethod and any buildAlias in the Builders table.\n  // Multiple aliases can be specified in buildAlias as an array or string which\n  // will be split on commas and/or whitespace.  This is what we use to map builder\n  // methods, e.g. select().from(), etc., onto the relevant modules.\n  [module.buildMethod, ...splitList(module.buildAlias)].forEach(\n    name => Builders[name] = module\n  )\n\n  // Builder modules have a slot that they use in the context.  Sometimes multiple\n  // builders can share the same slot (e.g. Columns and Select both use \"select\").\n  // When we're rendering a builder chain we first generate a context (which may be\n  // cached) in which each builder object instance adds their fragments of SQL to the\n  // array in their context slot, e.g. from('table1').from(['table2', 'alias']) will\n  // result in the \"from\" slot containing: ['\"table1\"', '\"table2\" as \"alias\"'].  Then\n  // we need to go through those slots in a particular order (e.g. select, from,\n  // join, where, etc) determined by each module's static buildOrder parameter and look\n  // to see if the corresponding slot has anything in it.  If it does, we call the\n  // module's static generateSQL() method to generate the complete SQL fragment,\n  // e.g. 'FROM \"table1\", \"table2\" as \"alias\"'\n  if (slot && hasValue(order)) {\n    Generators[slot] = [module, order];\n  }\n}\n\nexport const registerBuilders = (...builders) =>\n  builders.forEach(registerBuilder)\n\nregisterBuilders(\n  After, Before, Columns, Delete, From, Group, Having,\n  Insert, Into, Join, Limit, Offset, Order, Prefix, Range,\n  Returning, Select, Set, Table, Update, Values, Where,\n);\n\nexport const databaseBuilder = database =>\n  Proxy(Builders, new Database(undefined, database))\n\nexport const tableBuilder = table =>\n  Proxy(Builders, new Table(undefined, table))\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Builders.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 320,
    "kind": "function",
    "name": "registerBuilder",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~registerBuilder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{registerBuilder}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "module",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 321,
    "kind": "function",
    "name": "registerBuilders",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~registerBuilders",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{registerBuilders}",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [
      {
        "name": "builders",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 322,
    "kind": "function",
    "name": "databaseBuilder",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~databaseBuilder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseBuilder}",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 323,
    "kind": "function",
    "name": "tableBuilder",
    "memberof": "src/Builders.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Builders.js~tableBuilder",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{tableBuilder}",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 324,
    "kind": "file",
    "name": "src/Constants.js",
    "content": "export const defaultIdColumn  = 'id'\nexport const bitSplitter      = /:/\nexport const singleWord       = /^\\w+$/\nexport const allColumns       = '*'\nexport const whereTrue        = 'true'\nexport const unknown          = 'unknown'\nexport const space            = ' '\nexport const equals           = '='\nexport const comma            = ', '\nexport const newline          = \"\\n\"\nexport const blank            = ''\nexport const singleQuote      = \"'\"\nexport const doubleQuote      = '\"'\nexport const backtick         = '`'\nexport const lparen           = '('\nexport const rparen           = ')'\nexport const WITH             = 'WITH'\nexport const INSERT           = 'INSERT'\nexport const SELECT           = 'SELECT'\nexport const UPDATE           = 'UPDATE'\nexport const DELETE           = 'DELETE'\nexport const FROM             = 'FROM'\nexport const INTO             = 'INTO'\nexport const SET              = 'SET'\nexport const VALUES           = 'VALUES'\nexport const JOIN             = 'JOIN'\nexport const LEFT_JOIN        = 'LEFT JOIN'\nexport const RIGHT_JOIN       = 'RIGHT JOIN'\nexport const INNER_JOIN       = 'INNER JOIN'\nexport const FULL_JOIN        = 'FULL JOIN'\nexport const WHERE            = 'WHERE'\nexport const GROUP_BY         = 'GROUP BY'\nexport const ORDER_BY         = 'ORDER BY'\nexport const HAVING           = 'HAVING'\nexport const LIMIT            = 'LIMIT'\nexport const OFFSET           = 'OFFSET'\nexport const RETURNING        = 'RETURNING'\nexport const ON               = 'ON'\nexport const AND              = 'AND'\nexport const ASC              = 'ASC'\nexport const DESC             = 'DESC'\nexport const BEGIN            = 'BEGIN'\nexport const ROLLBACK         = 'ROLLBACK'\nexport const COMMIT           = 'COMMIT'\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 325,
    "kind": "variable",
    "name": "defaultIdColumn",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~defaultIdColumn",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{defaultIdColumn}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "variable",
    "name": "bitSplitter",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~bitSplitter",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{bitSplitter}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "variable",
    "name": "singleWord",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~singleWord",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{singleWord}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "variable",
    "name": "allColumns",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~allColumns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{allColumns}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "variable",
    "name": "whereTrue",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~whereTrue",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{whereTrue}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "variable",
    "name": "unknown",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~unknown",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{unknown}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "variable",
    "name": "space",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~space",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{space}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "variable",
    "name": "equals",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~equals",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{equals}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "variable",
    "name": "comma",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~comma",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{comma}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "variable",
    "name": "newline",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~newline",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{newline}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "variable",
    "name": "blank",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~blank",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{blank}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "singleQuote",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~singleQuote",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{singleQuote}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "variable",
    "name": "doubleQuote",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~doubleQuote",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{doubleQuote}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "variable",
    "name": "backtick",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~backtick",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{backtick}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "variable",
    "name": "lparen",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~lparen",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{lparen}",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "variable",
    "name": "rparen",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~rparen",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{rparen}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "variable",
    "name": "WITH",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~WITH",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{WITH}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "variable",
    "name": "INSERT",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~INSERT",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{INSERT}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "variable",
    "name": "SELECT",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~SELECT",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{SELECT}",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "variable",
    "name": "UPDATE",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~UPDATE",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{UPDATE}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "variable",
    "name": "DELETE",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~DELETE",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{DELETE}",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "variable",
    "name": "FROM",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~FROM",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{FROM}",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "variable",
    "name": "INTO",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~INTO",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{INTO}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "variable",
    "name": "SET",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~SET",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{SET}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "variable",
    "name": "VALUES",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~VALUES",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{VALUES}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "variable",
    "name": "JOIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~JOIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{JOIN}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "name": "LEFT_JOIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~LEFT_JOIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{LEFT_JOIN}",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "variable",
    "name": "RIGHT_JOIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~RIGHT_JOIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{RIGHT_JOIN}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "variable",
    "name": "INNER_JOIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~INNER_JOIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{INNER_JOIN}",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "variable",
    "name": "FULL_JOIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~FULL_JOIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{FULL_JOIN}",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "variable",
    "name": "WHERE",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~WHERE",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{WHERE}",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "variable",
    "name": "GROUP_BY",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~GROUP_BY",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{GROUP_BY}",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "variable",
    "name": "ORDER_BY",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~ORDER_BY",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ORDER_BY}",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "variable",
    "name": "HAVING",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~HAVING",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{HAVING}",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "variable",
    "name": "LIMIT",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~LIMIT",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{LIMIT}",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "variable",
    "name": "OFFSET",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~OFFSET",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{OFFSET}",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "variable",
    "name": "RETURNING",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~RETURNING",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{RETURNING}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "variable",
    "name": "ON",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~ON",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ON}",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 363,
    "kind": "variable",
    "name": "AND",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~AND",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{AND}",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "variable",
    "name": "ASC",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~ASC",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ASC}",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "variable",
    "name": "DESC",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~DESC",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{DESC}",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "variable",
    "name": "BEGIN",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~BEGIN",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{BEGIN}",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "variable",
    "name": "ROLLBACK",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~ROLLBACK",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ROLLBACK}",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "variable",
    "name": "COMMIT",
    "memberof": "src/Constants.js",
    "static": true,
    "longname": "src/Constants.js~COMMIT",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{COMMIT}",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "file",
    "name": "src/Database.js",
    "content": "import Queryable from './Queryable.js';\nimport Table from './Table.js';\nimport Tables from './Tables.js';\nimport Transaction from \"./Transaction.js\";\nimport proxymise from 'proxymise';\nimport modelProxy from './Proxy/Model.js';\nimport { engine } from './Engines.js';\nimport { addDebugMethod } from './Utils/index.js';\nimport { databaseBuilder } from './Builders.js';\nimport { fail } from '@abw/badger-utils';\n\nconst defaults = {\n  tablesClass: Tables\n};\n\nexport class Database extends Queryable {\n  constructor(engine, config={}) {\n    super(engine, config);\n    this.config    = config = { ...defaults, ...config };\n    this.queries   = config.queries;\n    this.fragments = config.fragments;\n    this.tables    = config.tablesObject || new config.tablesClass(config.tables);\n    this.initDatabase(config)\n    addDebugMethod(this, 'database', config);\n  }\n  initDatabase() {\n    // We do this part separately so that we can call this method when\n    // we create a transaction, allowing it to create wrappers around\n    // the new \"this\" that has the transaction stored in it\n    this.build     = databaseBuilder(this);\n    this.model     = modelProxy(this);\n    this.waiter    = proxymise(this);\n    this.state     = {\n      // tables must be created afresh to ensure they get the\n      // transaction reference\n      table: { },\n    };\n  }\n\n  //-----------------------------------------------------------------------------\n  // acquire/release a connection from the engine\n  //-----------------------------------------------------------------------------\n  acquire() {\n    return this.engine.acquire();\n  }\n  release(connection) {\n    this.engine.release(connection);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Tables\n  //-----------------------------------------------------------------------------\n  async table(name, options={}) {\n    return this.state.table[name]\n      ||= await this.initTable(name, options);\n  }\n  async hasTable(name) {\n    return await this.tables.table(name);\n  }\n  async initTable(name, options) {\n    const schema   = await this.hasTable(name) || fail(`Invalid table specified: ${name}`);\n    const tclass   = schema.tableClass   || Table;\n    const topts    = schema.tableOptions || { };\n    const transact = this.transact;\n    schema.table ||= name;\n    return new tclass(\n      this,\n      { ...schema, ...topts, ...options, transact }\n    );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query builder\n  //-----------------------------------------------------------------------------\n  select(...args) {\n    return this.build.select(...args);\n  }\n  insert(...args) {\n    return this.build.insert(...args);\n  }\n  update(...args) {\n    return this.build.update(...args);\n  }\n  delete(...args) {\n    return this.build.delete(...args);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Transactions\n  //-----------------------------------------------------------------------------\n  async transaction(code, config) {\n    const transact = new Transaction(this.engine, config);\n    const proxy = {\n      transact,\n      commit:   () => transact.commit(),\n      rollback: () => transact.rollback(),\n    };\n    Object.setPrototypeOf(proxy, this);\n    proxy.initDatabase()\n    await transact.run(proxy, code);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Delegates to engine methods\n  //-----------------------------------------------------------------------------\n  quote(name) {\n    return this.engine.quote(name);\n  }\n  disconnect() {\n    return this.engine.destroy();\n  }\n}\n\nexport const connect = config => {\n  const e = engine(config);\n  return new Database(e, config)\n}\n\nexport default Database\n\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 370,
    "kind": "variable",
    "name": "defaults",
    "memberof": "src/Database.js",
    "static": true,
    "longname": "src/Database.js~defaults",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{\"tablesClass\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 371,
    "kind": "class",
    "name": "Database",
    "memberof": "src/Database.js",
    "static": true,
    "longname": "src/Database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Database}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Queryable.js~Queryable"
    ]
  },
  {
    "__docId__": 372,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "config",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#config",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "queries",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#queries",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "fragments",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#fragments",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "tables",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#tables",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "initDatabase",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#initDatabase",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "build",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#build",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "model",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#model",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "waiter",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#waiter",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "state",
    "memberof": "src/Database.js~Database",
    "static": false,
    "longname": "src/Database.js~Database#state",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "{\"table\": *}"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "acquire",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#acquire",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "release",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#release",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "table",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Database.js~Database#table",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "hasTable",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Database.js~Database#hasTable",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "initTable",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Database.js~Database#initTable",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "select",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#select",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "insert",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#insert",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "update",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#update",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#delete",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "transaction",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Database.js~Database#transaction",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "code",
        "types": [
          "*"
        ]
      },
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#quote",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Database.js~Database#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 394,
    "kind": "function",
    "name": "connect",
    "memberof": "src/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Database.js~connect",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{connect}",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "file",
    "name": "src/Engine/Mysql.js",
    "content": "import Engine from '../Engine.js';\nimport { backtick, defaultIdColumn, COMMIT, ROLLBACK, BEGIN } from '../Constants.js';\nimport { throwEngineDriver } from '../Utils/Error.js';\n\nexport class MysqlEngine extends Engine {\n  static driver     = 'mysql2/promise'\n  static protocol   = 'mysql'\n  static alias      = 'maria mariadb'\n  static quoteChar  = backtick\n  static beginTrans = 'START TRANSACTION'\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { database: this.database });\n    const { default: mysql } = await import(this.driver).catch(\n      e => throwEngineDriver(this.driver, e)\n    );\n    return mysql.createConnection(this.database);\n  }\n\n  async connected(db) {\n    // work-around for https://github.com/sidorares/node-mysql2/issues/939\n    return ! db?.connection?._closing;\n  }\n\n  async disconnect(connection) {\n    this.debug(\"disconnect()\");\n    connection.destroy();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async run(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"run()\", { sql, params, options });\n    return this\n      .execute(\n        sql,\n        query => query.execute(params).then(([result]) => result),\n        options\n      )\n  }\n\n  async any(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"any()\", { sql, params, options });\n    return this\n      .execute(\n        sql,\n        query => query.execute(params).then(([rows]) => rows[0]),\n        options\n      )\n  }\n\n  async all(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"all()\", { sql, params, options });\n    return this\n      .execute(\n        sql,\n        query => query.execute(params).then(([rows]) => rows),\n        options\n      )\n  }\n\n  //-----------------------------------------------------------------------------\n  // Transaction methods - MySQL requires special handling\n  //-----------------------------------------------------------------------------\n  async begin(transact) {\n    this.debug('begin()')\n    return await transact.connection.query(BEGIN)\n  }\n\n  async commit(transact) {\n    this.debug('commit()');\n    return await transact.connection.query(COMMIT);\n  }\n\n  async rollback(transact) {\n    this.debug('rollback()');\n    return await transact.connection.query(ROLLBACK);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result, options={}) {\n    const keys = options.keys || [defaultIdColumn];\n    const id = keys[0];\n    result.changes ||= result.affectedRows || 0;\n    result.id      ||= result.insertId || null;\n    result[id]     ||= result.insertId || null;\n    return result;\n  }\n}\n\nexport default MysqlEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Mysql.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 396,
    "kind": "class",
    "name": "MysqlEngine",
    "memberof": "src/Engine/Mysql.js",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{MysqlEngine}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 397,
    "kind": "member",
    "name": "driver",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine.driver",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "member",
    "name": "protocol",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine.protocol",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 399,
    "kind": "member",
    "name": "alias",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine.alias",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 400,
    "kind": "member",
    "name": "quoteChar",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine.quoteChar",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "member",
    "name": "beginTrans",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "static": true,
    "longname": "src/Engine/Mysql.js~MysqlEngine.beginTrans",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "db",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "begin",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#begin",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "commit",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#commit",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "rollback",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#rollback",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Mysql.js~MysqlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Mysql.js~MysqlEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "file",
    "name": "src/Engine/Postgres.js",
    "content": "import Engine from '../Engine.js';\nimport { defaultIdColumn } from '../Constants.js';\nimport { throwEngineDriver } from '../Utils/Error.js';\n\nexport class PostgresEngine extends Engine {\n  static driver    = 'pg'\n  static protocol  = 'postgres'\n  static alias     = 'postgresql'\n  static returning = true\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { database: this.database });\n    const { default: pg } = await import(this.driver).catch(\n      e => throwEngineDriver(this.driver, e)\n    );\n    const client = new pg.Client(this.database);\n    await client.connect();\n    return client;\n  }\n\n  async disconnect(client) {\n    this.debug(\"disconnect()\");\n    client.end();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async clientExecute(client, sql, action) {\n    // Postgres doesn't have a prepare stage\n    return await action(client);\n  }\n\n  async run(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"run()\", { sql, params, options });\n    return this.execute(\n      sql,\n      client => client.query(sql, params),\n      options\n    )\n  }\n\n  async any(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"any()\", { sql, params, options });\n    return this.execute(\n      sql,\n      client => client.query(sql, params).then(({rows}) => rows[0]),\n      options\n    )\n  }\n\n  async all(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"all()\", { sql, params, options });\n    return this.execute(\n      sql,\n      client => client.query(sql, params).then(({rows}) => rows),\n      options\n    )\n  }\n\n  parseErrorArgs(e) {\n    return {\n      message:  e.message,\n      type:     e.severity,\n      code:     e.code,\n      position: e.position,\n    };\n  }\n\n  sanitizeResult(result, options={}) {\n    result.changes ||= result.rowCount || 0;\n    if (result.command === 'INSERT' && result.rows?.length) {\n      const keys = options.keys || [defaultIdColumn];\n      keys.forEach(\n        key => result[key] ||= result.rows[0][key]\n      )\n      result.id ||= result[keys[0]];\n    }\n    return result;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  formatPlaceholder(n) {\n    return '$' + n;\n  }\n}\n\nexport default PostgresEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Postgres.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 413,
    "kind": "class",
    "name": "PostgresEngine",
    "memberof": "src/Engine/Postgres.js",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{PostgresEngine}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 414,
    "kind": "member",
    "name": "driver",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine.driver",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 415,
    "kind": "member",
    "name": "protocol",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine.protocol",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 416,
    "kind": "member",
    "name": "alias",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine.alias",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 417,
    "kind": "member",
    "name": "returning",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "static": true,
    "longname": "src/Engine/Postgres.js~PostgresEngine.returning",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "client",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "clientExecute",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#clientExecute",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "client",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "action",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "parseErrorArgs",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#parseErrorArgs",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"message\": *, \"type\": *, \"code\": *, \"position\": *}"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "formatPlaceholder",
    "memberof": "src/Engine/Postgres.js~PostgresEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Postgres.js~PostgresEngine#formatPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 427,
    "kind": "file",
    "name": "src/Engine/Sqlite.js",
    "content": "import Engine from '../Engine.js';\nimport { missing, throwEngineDriver } from '../Utils/Error.js';\nimport { defaultIdColumn } from '../Constants.js';\nimport { remove } from '@abw/badger-utils';\n\nexport class SqliteEngine extends Engine {\n  static driver   = 'better-sqlite3'\n  static protocol = 'sqlite'\n\n  configure(config) {\n    // sqlite expects the filename first and then any options, so we copy\n    // the database configuration into the options and then extract filename\n    this.options  = { ...config.database };\n    this.filename = remove(this.options, 'filename') || missing('filename');\n\n    // better-sqlite3 is synchronous (because Sqlite serialises all\n    // requests anyway), so there's no need/benefit in using a pool\n    config.pool     ||= { };\n    config.pool.min ||= 1;\n    config.pool.max ||= 1;\n\n    return config;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods\n  //-----------------------------------------------------------------------------\n  async connect() {\n    this.debugData(\"connect()\", { filename: this.filename, options: this.options });\n    const { default: Database } = await import(this.driver).catch(\n      e => throwEngineDriver(this.driver, e)\n    );\n    return new Database(this.filename, this.options);\n  }\n\n  async connected(db) {\n    return db.open;\n  }\n\n  async disconnect(db) {\n    this.debug(\"disconnect()\");\n    db.close();\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query methods\n  //-----------------------------------------------------------------------------\n  async run(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"run()\", { sql, params, options });\n    return this.execute(\n      sql,\n      query => query.run(...params),\n      options\n    );\n  }\n\n  async any(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"any()\", { sql, params, options });\n    return this.execute(\n      sql,\n      query => query.get(...params),\n      options\n    );\n  }\n\n  async all(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"all()\", { sql, params, options });\n    return this.execute(\n      sql,\n      query => query.all(...params),\n      options\n    );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  sanitizeResult(result, options={}) {\n    result.changes ||= result.rowCount || 0;\n    const keys = options.keys || [defaultIdColumn];\n    const id = keys[0];\n    result[id] ||= result.lastInsertRowid;\n    result.id  ||= result.lastInsertRowid;\n    return result;\n  }\n}\n\nexport default SqliteEngine",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine/Sqlite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 428,
    "kind": "class",
    "name": "SqliteEngine",
    "memberof": "src/Engine/Sqlite.js",
    "static": true,
    "longname": "src/Engine/Sqlite.js~SqliteEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{SqliteEngine}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Engine.js~Engine"
    ]
  },
  {
    "__docId__": 429,
    "kind": "member",
    "name": "driver",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": true,
    "longname": "src/Engine/Sqlite.js~SqliteEngine.driver",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "member",
    "name": "protocol",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": true,
    "longname": "src/Engine/Sqlite.js~SqliteEngine.protocol",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#configure",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 432,
    "kind": "member",
    "name": "options",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#options",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "{...undefined: Object}"
      ]
    }
  },
  {
    "__docId__": 433,
    "kind": "member",
    "name": "filename",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#filename",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [
      {
        "name": "db",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "db",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 437,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#run",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 438,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#any",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#all",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine/Sqlite.js~SqliteEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine/Sqlite.js~SqliteEngine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "file",
    "name": "src/Engine.js",
    "content": "import { Pool } from 'tarn';\nimport { allColumns, doubleQuote, equals, whereTrue, BEGIN, COMMIT, ROLLBACK } from './Constants.js';\nimport { missing, notImplementedInBaseClass, SQLParseError, unexpectedRowCount, addDebugMethod } from \"./Utils/index.js\";\nimport { hasValue, isArray, isObject, splitList } from '@abw/badger-utils';\n\nconst notImplemented = notImplementedInBaseClass('Engine');\n\nconst poolDefaults = {\n  min: 2,\n  max: 10,\n  propagateCreateError: true\n}\n\nexport class Engine {\n  static quoteChar  = doubleQuote\n  static returning  = false\n\n  constructor(config={}) {\n    this.engine    = config.engine || missing('engine');\n    this.database  = config.database || missing('database');\n    this.driver    = this.constructor.driver || missing('driver');\n    this.quoteChar = this.constructor.quoteChar;\n    this.returning = this.constructor.returning;\n    this.messages  = this.constructor.messages;\n    this.config    = this.configure(config);\n    this.pool      = this.initPool(config.pool);\n    this.escQuote  = `\\\\${this.quoteChar}`;\n    addDebugMethod(this, 'engine', config);\n  }\n  configure(config) {\n    return config;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool configuration\n  //-----------------------------------------------------------------------------\n  initPool(options={}) {\n    return new Pool({\n      create: () => {\n        this.debug(\"connecting to pool\");\n        return this.connect();\n      },\n      validate: connection => {\n        return this.connected(connection);\n      },\n      destroy: connection => {\n        this.debug(\"disconnecting from pool\");\n        return this.disconnect(connection);\n      },\n      ...poolDefaults,\n      ...options\n    });\n  }\n\n  //-----------------------------------------------------------------------------\n  // Pool connections methods - must be implemented by subclasses\n  //-----------------------------------------------------------------------------\n  async connect()    { notImplemented(\"connect()\")    }\n  async connected()  { return true }\n  async disconnect() { notImplemented(\"disconnect()\") }\n\n  //-----------------------------------------------------------------------------\n  // Methods to acquire and release connections from the pool\n  //-----------------------------------------------------------------------------\n  async acquire() {\n    this.debug(\"acquire()\");\n    return this.pool.acquire().promise;\n  }\n\n  async release(connection) {\n    this.debug(\"release()\");\n    await this.pool.release(connection);\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query execution methods\n  //-----------------------------------------------------------------------------\n  async clientExecute(client, sql, action) {\n    const query = await client.prepare(sql)\n    return await action(query);\n  }\n\n  async execute(sql, action, options={}) {\n    this.debugData(\"execute()\", { sql, options });\n\n    // if we have a transaction in effect then we use the transaction's\n    // connection otherwise we fetch one from the pool\n    const transact = options.transact\n    const client = transact\n      ? transact.connection\n      : await this.acquire()\n\n    try {\n      // run the query\n      const result = await this\n        .clientExecute(client, sql, action)\n        .catch( e => this.parseError(sql, e) );\n\n      // sanitize the result\n      return options.sanitizeResult\n        ? this.sanitizeResult(result, options)\n        : result;\n    }\n    finally {\n      // release the connection back to the pool if it's one we acquired\n      if (! transact) {\n        this.release(client);\n      }\n    }\n  }\n\n  //-----------------------------------------------------------------------------\n  // Generic query methods - most must be defined by subclasses\n  //-----------------------------------------------------------------------------\n  async run() { notImplemented('run()') }\n  async any() { notImplemented('any()') }\n  async all() { notImplemented('all()') }\n\n  async one(sql, ...args) {\n    const [params, options] = this.queryArgs(args);\n    this.debugData(\"one()\", { sql, params, options });\n    const rows = await this.all(sql, params, options);\n    if (rows.length === 1) {\n      return rows[0];\n    }\n    else {\n      unexpectedRowCount(rows.length);\n    }\n  }\n\n  //-----------------------------------------------------------------------------\n  // Transaction queries\n  //-----------------------------------------------------------------------------\n  async begin(transact) {\n    this.debug('begin()')\n    return await this.run(BEGIN, { transact })\n  }\n\n  async commit(transact) {\n    this.debug('commit()');\n    return await this.run(COMMIT, { transact });\n  }\n\n  async rollback(transact) {\n    this.debug('rollback()');\n    return await this.run(ROLLBACK, { transact });\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query utility methods\n  //-----------------------------------------------------------------------------\n  parseError(sql, e) {\n    throw new SQLParseError(sql, this.parseErrorArgs(e));\n  }\n\n  parseErrorArgs(e) {\n    return {\n      message:  e.message,\n      type:     e.code,\n      code:     e.errno,\n      position: e.position,\n    };\n  }\n\n  queryArgs(args) {\n    const params = isArray(args[0])\n      ? args.shift()\n      : [ ];\n    const options = args.length\n      ? args.shift()\n      : { };\n    return [params, options];\n  }\n\n  prepareValues(values) {\n    return values.map(\n      // values can be arrays with a comparison, e.g. ['>', 1973], in which case\n      // we only want the second element\n      value => isArray(value)\n        ? value[1]\n        : value\n    )\n  }\n\n  sanitizeResult(result) {\n    return result;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query formatting\n  //-----------------------------------------------------------------------------\n  quote(name) {\n    if (isObject(name) && name.sql) {\n      return name.sql;\n    }\n    return name\n      .split(/\\./)\n      .map(\n        part => part === allColumns\n          ? part\n          : this.quoteChar + part.replaceAll(this.quoteChar, this.escQuote) + this.quoteChar)\n      .join('.');\n  }\n\n  quoteTableColumn(table, column) {\n    // if the column already has a dot then we quote it as is,\n    // otherwise we explicitly add the table name\n    return column.match(/\\./)\n      ? this.quote(column)\n      : this.quote(`${table}.${column}`);\n  }\n\n  formatPlaceholder() {\n    return '?';\n  }\n\n  formatColumnPlaceholder(column, n) {\n    return `${this.quote(column)}=${this.formatPlaceholder(n)}`;\n  }\n\n  formatWherePlaceholder(column, value, n) {\n    // value can be an array containing a comparison operator and a value,\n    // e.g. ['>' 1973], otherwise we assume it's an equality operator, '='\n    const cmp = isArray(value) ? value[0] : equals;\n    return `${this.quote(column)} ${cmp} ${this.formatPlaceholder(n)}`;\n  }\n\n  formatSetPlaceholder(column, n) {\n    return `${this.quote(column)} ${equals} ${this.formatPlaceholder(n)}`;\n  }\n\n  formatPlaceholders(values, n=1) {\n    return values.map(\n      () => this.formatPlaceholder(n++)\n    ).join(', ');\n  }\n\n  formatColumnPlaceholders(columns, n=1, joint=', ') {\n    return columns.map(\n      column => this.formatColumnPlaceholder(column, n++)\n    ).join(joint);\n  }\n\n  formatWherePlaceholders(columns, values, n=1, joint=' AND ') {\n    let i = 0;\n    return columns.map(\n      column => this.formatWherePlaceholder(column, values[i++], n++)\n    ).join(joint) || whereTrue;\n  }\n\n  formatColumns(columns) {\n    if (isObject(columns) && columns.sql) {\n      return columns.sql;\n    }\n    return hasValue(columns)\n      ? splitList(columns)\n        .map(\n          column => this.quote(column)\n        )\n        .join(', ')\n      : allColumns;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Cleanup\n  //-----------------------------------------------------------------------------\n  async destroy() {\n    this.debug(\"destroy()\");\n    await this.pool.destroy();\n  }\n}\n\nexport default Engine\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engine.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 442,
    "kind": "variable",
    "name": "notImplemented",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~notImplemented",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 443,
    "kind": "variable",
    "name": "poolDefaults",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~poolDefaults",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{\"min\": number, \"max\": number, \"propagateCreateError\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 444,
    "kind": "class",
    "name": "Engine",
    "memberof": "src/Engine.js",
    "static": true,
    "longname": "src/Engine.js~Engine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Engine}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 445,
    "kind": "member",
    "name": "quoteChar",
    "memberof": "src/Engine.js~Engine",
    "static": true,
    "longname": "src/Engine.js~Engine.quoteChar",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 446,
    "kind": "member",
    "name": "returning",
    "memberof": "src/Engine.js~Engine",
    "static": true,
    "longname": "src/Engine.js~Engine.returning",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 447,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true
  },
  {
    "__docId__": 448,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#engine",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "member",
    "name": "database",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#database",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 450,
    "kind": "member",
    "name": "driver",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#driver",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 451,
    "kind": "member",
    "name": "quoteChar",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#quoteChar",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 452,
    "kind": "member",
    "name": "returning",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#returning",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 453,
    "kind": "member",
    "name": "messages",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#messages",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 454,
    "kind": "member",
    "name": "config",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#config",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "member",
    "name": "pool",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#pool",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 456,
    "kind": "member",
    "name": "escQuote",
    "memberof": "src/Engine.js~Engine",
    "static": false,
    "longname": "src/Engine.js~Engine#escQuote",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#configure",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "initPool",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#initPool",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "connect",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#connect",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 460,
    "kind": "method",
    "name": "connected",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#connected",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 461,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#disconnect",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "acquire",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#acquire",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "release",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#release",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [
      {
        "name": "connection",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "clientExecute",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#clientExecute",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "client",
        "types": [
          "*"
        ]
      },
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "action",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "execute",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#execute",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "action",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "run",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#run",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 467,
    "kind": "method",
    "name": "any",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#any",
    "access": "public",
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 468,
    "kind": "method",
    "name": "all",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#all",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 469,
    "kind": "method",
    "name": "one",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#one",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "begin",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#begin",
    "access": "public",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "commit",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#commit",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "rollback",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#rollback",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [
      {
        "name": "transact",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "parseError",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#parseError",
    "access": "public",
    "description": null,
    "lineNumber": 152,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      },
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "parseErrorArgs",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#parseErrorArgs",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "e",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"message\": *, \"type\": *, \"code\": *, \"position\": *}"
      ]
    }
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "queryArgs",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#queryArgs",
    "access": "public",
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "prepareValues",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#prepareValues",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 477,
    "kind": "method",
    "name": "sanitizeResult",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#sanitizeResult",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 478,
    "kind": "method",
    "name": "quote",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#quote",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "quoteTableColumn",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#quoteTableColumn",
    "access": "public",
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [
      {
        "name": "table",
        "types": [
          "*"
        ]
      },
      {
        "name": "column",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "formatPlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "formatColumnPlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumnPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "formatWherePlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatWherePlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "formatSetPlaceholder",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatSetPlaceholder",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "params": [
      {
        "name": "column",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 484,
    "kind": "method",
    "name": "formatPlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatPlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "params": [
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "method",
    "name": "formatColumnPlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumnPlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      },
      {
        "name": "joint",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": ", ",
        "defaultValue": ", "
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 486,
    "kind": "method",
    "name": "formatWherePlaceholders",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatWherePlaceholders",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      },
      {
        "name": "n",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      },
      {
        "name": "joint",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": " AND ",
        "defaultValue": " AND "
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 487,
    "kind": "method",
    "name": "formatColumns",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Engine.js~Engine#formatColumns",
    "access": "public",
    "description": null,
    "lineNumber": 251,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 488,
    "kind": "method",
    "name": "destroy",
    "memberof": "src/Engine.js~Engine",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Engine.js~Engine#destroy",
    "access": "public",
    "description": null,
    "lineNumber": 267,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 489,
    "kind": "file",
    "name": "src/Engines.js",
    "content": "import Mysql from './Engine/Mysql.js'\nimport Postgres from './Engine/Postgres.js'\nimport Sqlite from './Engine/Sqlite.js'\nimport { splitList } from \"@abw/badger-utils\";\nimport { databaseConfig } from \"./Utils/Database.js\";\nimport { invalid, missing } from \"./Utils/Error.js\";\n\nlet Engines = { };\n\nexport const registerEngine = engine => {\n  const ructor = config => new engine(config);\n  [engine.protocol, ...splitList(engine.alias)].forEach(\n    name => Engines[name] = ructor\n  )\n}\n\nexport const registerEngines = (...engines) =>\n  engines.forEach(registerEngine)\n\nregisterEngines(Sqlite, Mysql, Postgres);\n\n//-----------------------------------------------------------------------------\n// Engine constructor\n//-----------------------------------------------------------------------------\nexport const engine = config => {\n  config = databaseConfig(config);\n  const engine = config.engine || missing('database.engine');\n  const handler = Engines[engine] || invalid('database.engine', engine);\n  return handler(config);\n}\n\nexport default Engines;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Engines.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 490,
    "kind": "function",
    "name": "registerEngine",
    "memberof": "src/Engines.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Engines.js~registerEngine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{registerEngine}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 491,
    "kind": "function",
    "name": "registerEngines",
    "memberof": "src/Engines.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Engines.js~registerEngines",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{registerEngines}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "engines",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 492,
    "kind": "function",
    "name": "engine",
    "memberof": "src/Engines.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Engines.js~engine",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{engine}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 493,
    "kind": "variable",
    "name": "Engines",
    "memberof": "src/Engines.js",
    "static": true,
    "longname": "src/Engines.js~Engines",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "Engines",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 494,
    "kind": "file",
    "name": "src/Proxy/Builder.js",
    "content": "import { extract, splitHash } from \"@abw/badger-utils\";\nimport { article } from \"../Utils/Article.js\";\nimport { QueryBuilderError } from \"../Utils/Error.js\";\n\n// In the usual case we have an object mapping methods names to\n// builder classes (`builders`) and a `parent` object.  However a\n// builder node can define a static subMethods item which defines\n// the allowable methods that can follow it.  A new builder proxy\n// is created with the options object containing a `valid` object\n// containing the valid query methods and `keyword` set to the\n// keyword for the builder node that declared the subMethods.\n// This allows us to generate a better error if an invalid method\n// is added, e.g. \"SELECT cannot be added to a DELETE query\".\n\nexport const builderProxy = (builders, parent, options={}) =>\n  new Proxy(\n    parent,\n    {\n      get(target, prop) {\n        // console.log('builderProxy %s', prop);\n\n        if (prop === 'toString') {\n          // special case for toString() which Proxies handle differently\n          return target.toString.bind(target);\n        }\n\n        // if it's not a builder method then delegate to the target\n        const bclass = builders[prop];\n        if (! bclass) {\n          return Reflect.get(target, prop);\n        }\n\n        if (options.valid) {\n          // if a parent has specified the valid subMethods that can follow\n          // it then we check that the method is listed in there...\n          let valid = Boolean(options.valid[prop]);\n\n          // ...but it might be a custom method that someone has added that the\n          // parent query (SELECT, INSERT, etc) didn't know about, so we allow\n          // the builder method to define a static validFor item to list the\n          // top-level queries that it can appear in, e.g. 'SELECT INSERT'\n          if (! valid && bclass.validFor) {\n            valid = Boolean(splitHash(bclass.validFor)[options.keyword])\n          }\n\n          // if it's not valid then we throw an error\n          if (! valid) {\n            throw new QueryBuilderError(\n              `${prop}() is not a valid builder method for ${article(options.keyword)} ${options.keyword} query.`\n            );\n          }\n        }\n\n        // console.log('builderProxy builder: %s =>', prop, bclass);\n        return (\n          (...args) => {\n            const builder   = new bclass(parent, ...args);\n            const methods   = bclass.subMethods;\n            if (methods) {\n              return builderProxy(\n                builders, builder,\n                { valid: extract(builders, methods), keyword: bclass.keyword }\n              )\n            }\n            else {\n              return builderProxy(builders, builder)\n            }\n          }\n        ).bind(target);\n      }\n    }\n  );\n\nexport default builderProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Builder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 495,
    "kind": "function",
    "name": "builderProxy",
    "memberof": "src/Proxy/Builder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Builder.js~builderProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{builderProxy}",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "builders",
        "types": [
          "*"
        ]
      },
      {
        "name": "parent",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 496,
    "kind": "file",
    "name": "src/Proxy/Model.js",
    "content": "export const modelProxy = database =>\n  new Proxy(\n    database,\n    {\n      get(target, prop) {\n        if (prop === 'then') {\n          return Reflect.get(target, prop);\n        }\n        return target.table(prop);\n      }\n    }\n  );\n\nexport default modelProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 497,
    "kind": "function",
    "name": "modelProxy",
    "memberof": "src/Proxy/Model.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Model.js~modelProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{modelProxy}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "database",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 498,
    "kind": "file",
    "name": "src/Proxy/Record.js",
    "content": "export const recordProxy = record =>\n  new Proxy(\n    record,\n    {\n      get(target, prop) {\n        // console.log('recordProxy get(%s)', prop);\n        // first look to see if the record has the property/method itself\n        if (Reflect.has(target, prop)) {\n          return Reflect.get(target, prop);\n        }\n        // then look to see if it's a data item\n        if (Reflect.has(target.row, prop)) {\n          return Reflect.get(target.row, prop);\n        }\n        // then look to see if it's a relation\n        if (Reflect.has(target.table.relations, prop)) {\n          // console.log('recordProxy column: ', prop);\n          return target.relation(prop);\n        }\n        return Reflect.get(target, prop);\n      }\n    }\n  );\n\nexport default recordProxy\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Proxy/Record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 499,
    "kind": "function",
    "name": "recordProxy",
    "memberof": "src/Proxy/Record.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Proxy/Record.js~recordProxy",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{recordProxy}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "file",
    "name": "src/Query.js",
    "content": "import Builder from './Builder.js'\nimport { fail, isArray, isFunction, isString } from \"@abw/badger-utils\";\nimport { addDebugMethod, missing } from './Utils/index.js';\n\nexport class Query {\n  constructor(engine, query, config={}) {\n    this.engine       = engine || missing('engine');\n    this.setValues    = config.setValues    || [ ];\n    this.whereValues  = config.whereValues  || [ ];\n    this.havingValues = config.havingValues || [ ];\n    this.transact     = config.transact;\n\n    if (isString(query)) {\n      this.query = query;\n    }\n    else if (query instanceof Builder) {\n      // if we have a query builder element then ask it to generate the SQL and\n      // provide any whereValues/havingValues it collected along the way that we\n      // combine with any provided in the config\n      this.query = query.sql();\n      const values = query.contextValues();\n      Object.keys(values).forEach(\n        key => this[key] = [ ...values[key], ...this[key] ]\n      )\n    }\n    else {\n      fail(`Invalid query type: `, query);\n    }\n\n    addDebugMethod(this, 'query', this.config);\n  }\n\n  sql() {\n    return this.query;\n  }\n\n  run(...args) {\n    const sql = this.sql();\n    const [values, options] = this.queryArgs(args);\n    this.debugData(\"run()\", { sql, values, options });\n    return this.engine.run(sql, values, options)\n  }\n\n  one(...args) {\n    const sql    = this.sql();\n    const [values, options] = this.queryArgs(args);\n    this.debugData(\"one()\", { sql, values, options });\n    return this.engine.one(sql, values, options)\n  }\n\n  any(...args) {\n    const sql = this.sql();\n    const [values, options] = this.queryArgs(args);\n    this.debugData(\"any()\", { sql, values, options });\n    return this.engine.any(sql, values, options)\n  }\n\n  all(...args) {\n    const sql = this.sql();\n    const [values, options] = this.queryArgs(args);\n    this.debugData(\"all()\", { sql, values, options });\n    return this.engine.all(sql, values, options)\n  }\n\n  queryArgs(args) {\n    const params = isArray(args[0])\n      ? args.shift()\n      : [ ];\n    const options = args.length\n      ? args.shift()\n      : { };\n    return [\n      this.allValues(params),\n      this.transact\n        ? { ...options, transact: this.transact }\n        : options\n    ];\n  }\n\n  allValues(where=[]) {\n    const wvalues = this.whereValues;\n    const hvalues = this.havingValues;\n    // In the usual case we just get one set of extra args and they\n    // go at the end.  But if there's some need to jiggle the parameters\n    // more then a function can be provided.\n    if (isFunction(where)) {\n      return where(wvalues, hvalues);\n    }\n    return [...wvalues, ...hvalues, ...where]\n  }\n\n  toString() {\n    return this.sql();\n  }\n}\n\nexport default Query\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Query.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 501,
    "kind": "class",
    "name": "Query",
    "memberof": "src/Query.js",
    "static": true,
    "longname": "src/Query.js~Query",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Query}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 502,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#engine",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "member",
    "name": "setValues",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#setValues",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 505,
    "kind": "member",
    "name": "whereValues",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#whereValues",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "member",
    "name": "havingValues",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#havingValues",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 507,
    "kind": "member",
    "name": "transact",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#transact",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "member",
    "name": "query",
    "memberof": "src/Query.js~Query",
    "static": false,
    "longname": "src/Query.js~Query#query",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "sql",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#sql",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "run",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#run",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "one",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#one",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "any",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#any",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "all",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#all",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "queryArgs",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#queryArgs",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "allValues",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#allValues",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "toString",
    "memberof": "src/Query.js~Query",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Query.js~Query#toString",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 518,
    "kind": "file",
    "name": "src/Queryable.js",
    "content": "import Query from \"./Query.js\";\nimport { singleWord } from \"./Constants.js\";\nimport { fail, isFunction, isString } from \"@abw/badger-utils\";\nimport { expandFragments } from \"./Utils/Queries.js\";\nimport { missing } from \"./Utils/Error.js\";\n\nexport class Queryable {\n  constructor(engine, config={}) {\n    this.engine   = engine || missing('engine');\n    this.transact = config.transact;\n  }\n\n  query(source) {\n    this.debugData(\"query()\", { source });\n    const query = this.queries[source]\n      || (this.database && this.database.query(source))\n      || fail(\"Invalid named query specified: \", source);\n    // a named query can be a function which we call, returning either a string\n    // or a query builder\n    return isFunction(query)\n      ? query(this)\n      : query;\n  }\n\n  fragment(name) {\n    this.debugData(\"fragment()\", { name });\n    return this.fragments[name]\n      || (this.database && this.database.fragment(name))\n      || fail(\"Invalid query fragment in SQL expansion: <\", name, \">\");\n  }\n\n  buildQuery(source, config={}) {\n    config.transact ||= this.transact;\n    this.debugData(\"buildQuery()\", { source, config });\n    return new Query(\n      this.engine,\n      isString(source) ? this.expandQuery(source) : source,\n      config\n    );\n  }\n\n  expandQuery(source, config) {\n    this.debugData(\"expandQuery()\", { source });\n    // if the source is a single word then it must be a named query\n    // otherwise it's an SQL query possibly with embedded fragments\n    return source.match(singleWord)\n      ? this.expandNamedQuery(source, config)\n      : expandFragments(source, this);\n  }\n\n  expandNamedQuery(name) {\n    this.debugData(\"expandNamedQuery()\", { name });\n    const query = this.query(name);\n    // the named query can be a string with embedded fragments that should\n    // be expanded, or it can be a query builder\n    return isString(query)\n      ? expandFragments(query, this)\n      : query;\n  }\n\n  sql(name, config) {\n    this.debugData(\"sql()\", { name, config });\n    return this.buildQuery(name, config).sql();\n  }\n\n  async run(query, params, options) {\n    this.debugData(\"run()\", { query, params, options });\n    return this.buildQuery(query).run(params, options)\n  }\n\n  async one(query, params, options) {\n    this.debugData(\"one()\", { query, params, options });\n    return this.loadedOne(\n      await this.buildQuery(query).one(params, options),\n      options\n    )\n  }\n\n  async any(query, params, options) {\n    this.debugData(\"any()\", { query, params, options });\n    return this.loadedAny(\n      await this.buildQuery(query).any(params, options),\n      options\n    )\n  }\n\n  async all(query, params, options) {\n    this.debugData(\"all()\", { query, params, options });\n    return this.loadedAll(\n      await this.buildQuery(query).all(params, options),\n      options\n    )\n  }\n\n  loadedOne(row) {\n    return row;\n  }\n\n  loadedAny(row) {\n    return row;\n  }\n\n  loadedAll(rows) {\n    return rows;\n  }\n}\n\nexport default Queryable",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Queryable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 519,
    "kind": "class",
    "name": "Queryable",
    "memberof": "src/Queryable.js",
    "static": true,
    "longname": "src/Queryable.js~Queryable",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Queryable}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 520,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 521,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Queryable.js~Queryable",
    "static": false,
    "longname": "src/Queryable.js~Queryable#engine",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 522,
    "kind": "member",
    "name": "transact",
    "memberof": "src/Queryable.js~Queryable",
    "static": false,
    "longname": "src/Queryable.js~Queryable#transact",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 523,
    "kind": "method",
    "name": "query",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#query",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "fragment",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#fragment",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 525,
    "kind": "method",
    "name": "buildQuery",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#buildQuery",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "config",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "expandQuery",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#expandQuery",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 527,
    "kind": "method",
    "name": "expandNamedQuery",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#expandNamedQuery",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 528,
    "kind": "method",
    "name": "sql",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#sql",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "run",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Queryable.js~Queryable#run",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "one",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Queryable.js~Queryable#one",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "any",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Queryable.js~Queryable#any",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "all",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Queryable.js~Queryable#all",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "loadedOne",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#loadedOne",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "loadedAny",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#loadedAny",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "loadedAll",
    "memberof": "src/Queryable.js~Queryable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Queryable.js~Queryable#loadedAll",
    "access": "public",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "params": [
      {
        "name": "rows",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 536,
    "kind": "file",
    "name": "src/Record.js",
    "content": "import relations from \"./Relation/index.js\";\nimport { fail } from \"@abw/badger-utils\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\nimport { throwDeletedRecordError } from \"./Utils/Error.js\";\nimport { relationConfig } from \"./Utils/Relation.js\";\n\nexport class Record {\n  constructor(table, row, config={}) {\n    this.table     = table;\n    this.database  = table.database;\n    this.row       = row;\n    this.relations = { };\n    this.config    = config;\n    addDebugMethod(this, 'record', { debugPrefix: `Record:${this.table.table}` }, config);\n  }\n\n  async update(set, options={}) {\n    this.debugData(\"update()\", { set });\n    this.assertNotDeleted('update');\n    const where = this.table.identity(this.row);\n    const update = await this.table.updateOne(set, where, { ...options, reload: true });\n    Object.assign(this.row, update);\n    return this;\n  }\n\n  async delete() {\n    this.debugData(\"delete()\");\n    this.assertNotDeleted('delete');\n    const where = this.table.identity(this.row);\n    await this.table.delete(where);\n    this.deleted = true;\n    return this;\n  }\n\n  assertNotDeleted(action) {\n    if (this.deleted) {\n      throwDeletedRecordError(\n        'action',\n        {\n          action,\n          table: this.table.table,\n          id:    this.table.keys.map( key => this.row[key] ).join('/')\n        }\n      )\n    }\n  }\n\n  async relation(name) {\n    this.debug('relation(%s)', name);\n    return this.relations[name]\n      ||=  await this.initRelation(name);\n  }\n\n  async initRelation(name) {\n    this.debug('initRelation(%s)', name);\n    const table = this.table.table;\n    const relation = relationConfig(\n      table, name,\n      this.table.relations[name]\n        || fail(`Invalid \"${name}\" relation specified for ${table} table`)\n    )\n    if (relation.load) {\n      return await relation.load(this);\n    }\n    const rfunc = relations[relation.type]\n      || fail(`Invalid \"${relation.type}\" relation type specified for ${name} relation in ${table} table`);\n    return await rfunc(this, relation);\n  }\n}\n\nexport default Record;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 537,
    "kind": "class",
    "name": "Record",
    "memberof": "src/Record.js",
    "static": true,
    "longname": "src/Record.js~Record",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Record}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 538,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 539,
    "kind": "member",
    "name": "table",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#table",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 540,
    "kind": "member",
    "name": "database",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#database",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 541,
    "kind": "member",
    "name": "row",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#row",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 542,
    "kind": "member",
    "name": "relations",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#relations",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 543,
    "kind": "member",
    "name": "config",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#config",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "update",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#update",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#delete",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 546,
    "kind": "member",
    "name": "deleted",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#deleted",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "assertNotDeleted",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#assertNotDeleted",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "action",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "relation",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#relation",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "initRelation",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#initRelation",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 550,
    "kind": "file",
    "name": "src/Relation/any.js",
    "content": "import { whereRelation } from \"../Utils/Relation.js\";\n\nexport const any = async (record, spec={}) => {\n  const where = whereRelation(record, spec);\n  const table = await record.database.table(spec.table);\n  return await table.anyRecord(where);\n}\n\nexport default any",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/any.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 551,
    "kind": "function",
    "name": "any",
    "memberof": "src/Relation/any.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/any.js~any",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{any}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "file",
    "name": "src/Relation/many.js",
    "content": "import { whereRelation } from \"../Utils/Relation.js\";\n\nexport const many = async (record, spec={}) => {\n  const where   = whereRelation(record, spec);\n  const order   = spec.order;\n  const options = order ? { order } : { };\n  const table   = await record.database.table(spec.table);\n  return await table.allRecords(where, options);\n}\n\nexport default many\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/many.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 553,
    "kind": "function",
    "name": "many",
    "memberof": "src/Relation/many.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/many.js~many",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{many}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "file",
    "name": "src/Relation/map.js",
    "content": "import { whereRelation } from \"../Utils/Relation.js\";\n\nexport const map = async (record, spec={}) => {\n  const where   = whereRelation(record, spec);\n  const key     = spec.key || record.table.id;\n  const value   = spec.value;\n  const table   = await record.database.table(spec.table);\n  const records = await table.allRecords(where);\n  return records.reduce(\n    (hash, record) => {\n      hash[record[key]] = spec.value ? record[value] : record;\n      return hash\n    },\n    { }\n  );\n}\n\nexport default map",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/map.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 555,
    "kind": "function",
    "name": "map",
    "memberof": "src/Relation/map.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/map.js~map",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{map}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 556,
    "kind": "file",
    "name": "src/Relation/one.js",
    "content": "import { whereRelation } from \"../Utils/Relation.js\";\n\nexport const one = async (record, spec={}) => {\n  const where = whereRelation(record, spec);\n  const table = await record.database.table(spec.table);\n  return await table.oneRecord(where);\n}\n\nexport default one",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Relation/one.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 557,
    "kind": "function",
    "name": "one",
    "memberof": "src/Relation/one.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Relation/one.js~one",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{one}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 558,
    "kind": "file",
    "name": "src/Table.js",
    "content": "import Record from \"./Record.js\";\nimport Queryable from \"./Queryable.js\";\nimport recordProxy from \"./Proxy/Record.js\";\nimport { databaseBuilder } from \"./Builders.js\";\nimport { isQuery } from \"./Utils/Queries.js\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\nimport { aliasMethods } from \"./Utils/Methods.js\";\nimport { prepareColumns, prepareKeys } from \"./Utils/Columns.js\";\nimport { throwColumnValidationError, unexpectedRowCount } from \"./Utils/Error.js\";\nimport { fail, firstValue, isArray, noValue, splitList } from \"@abw/badger-utils\";\n\nconst methodAliases = {\n  insertRow:     \"insertOneRow\",\n  insertRows:    \"insertAllRows\",\n  insertRecord:  \"insertOneRecord\",\n  insertRecords: \"insertAllRecords\",\n  update:        \"updateAll\",\n  updateRow:     \"updateOneRow\",\n  fetch:         \"fetchAll\",\n  fetchRecord:   \"fetchOneRecord\",\n  fetchRecords:  \"fetchAllRecords\",\n}\n\nexport class Table extends Queryable {\n  constructor(database, config) {\n    super(database.engine, config);\n    this.config        = this.configure(config) || config;\n    this.database      = database || fail(\"No database specified\");\n    this.table         = config.table;\n    this.columns       = prepareColumns(config);\n    this.readonly      = Object.keys(this.columns).filter( key => this.columns[key].readonly );\n    this.required      = Object.keys(this.columns).filter( key => this.columns[key].required );\n    this.keys          = prepareKeys(config, this.columns);\n    this.id            = config.id;\n    this.recordClass   = config.recordClass || Record;\n    this.recordConfig  = config.recordConfig;\n    this.queries       = config.queries || { };\n    this.fragments     = this.prepareFragments(config);\n    this.relations     = config.relations || { };\n    this.build         = databaseBuilder(this.database);\n    aliasMethods(this, methodAliases);\n    addDebugMethod(this, 'table', { debugPrefix: `Table:${this.table}` }, config);\n  }\n\n  configure(config) {\n    return config;\n  }\n\n  prepareFragments(config) {\n    const quote       = this.database.quote.bind(this.database);\n    const fragments   = config.fragments ||= { };\n    fragments.table   = quote(this.table);\n    fragments.columns = Object.values(this.columns).map(\n      spec => quote(spec.tableColumn)\n    ).join(', ');\n    return fragments;\n  }\n\n  //-----------------------------------------------------------------------------\n  // Basic queries - insert\n  //-----------------------------------------------------------------------------\n  async insert(data, options) {\n    return isArray(data, options)\n      ? this.insertAll(data, options)\n      : this.insertOne(data, options)\n  }\n\n  async prepareInsert(data, options) {\n    const [cols, vals] = await this.validateInsert(data, options);\n    const returning = this.engine.returning\n      ? { table: this.table, columns: this.keys }\n      : undefined;\n    this.checkRequiredColumns(data);\n    const insert = this.build\n      .insert(cols)\n      .into(this.table)\n      .values(vals)\n      .returning(returning);\n    this.debugData('prepareInsert()', { data, sql: insert.sql() })\n    return insert;\n  }\n\n  async validateInsert(data, options) {\n    return this.checkWritableColumns(data, options);\n  }\n\n  async insertOne(data, options={}) {\n    const insert = await this\n      .prepareInsert(data, options)\n      .then( query => query.run(undefined, { keys: this.keys }) );\n    return this.inserted(data, insert, options);\n  }\n\n  async insertAll(data, options) {\n    this.debugData(\"insertAll()\", { data, options });\n    let rows = [ ];\n    for (const row of data) {\n      rows.push(await this.insertOne(row, options));\n    }\n    return rows;\n  }\n\n  async insertOneRow(data, options) {\n    this.debugData(\"insertOneRow()\", { data, options });\n    return this.insertOne(data, this.withReloadOption(options))\n  }\n\n  async insertAllRows(data, options) {\n    this.debugData(\"insertAllRows()\", { data, options });\n    return this.insertAll(data, this.withReloadOption(options))\n  }\n\n  async insertOneRecord(data, options) {\n    this.debugData(\"insertOneRecord()\", { data, options });\n    return this.insertOne(data, this.withRecordOption(options))\n  }\n\n  async insertAllRecords(data, options) {\n    this.debugData(\"insertAllRecords()\", { data, options });\n    return this.insertAll(data, this.withRecordOption(options))\n  }\n\n  async inserted(input, output, options={}) {\n    return options.reload || options.record\n      ? this.insertReload(input, output, options)\n      : output;\n  }\n\n  async insertReload(input, output, options={}) {\n    // For insert queries where the input data is used to run the query,\n    // and the output data is returned from the query. We should have\n    // values for each of this.keys because they should always be\n    // either specified in the input data, or returned by the database\n    const fetch = { };\n    this.keys.map(\n      key => fetch[key] = firstValue(output[key], input[key])\n    );\n    return options.record\n      ? this.oneRecord(fetch)\n      : this.oneRow(fetch);\n  }\n\n\n  //-----------------------------------------------------------------------------\n  // update\n  //-----------------------------------------------------------------------------\n  async prepareUpdate(set, where, options) {\n    const [update, criteria] = await this.validateUpdate(set, where, options);\n    const query = this\n      .build\n      .update(this.table)\n      .set(update)\n      .where(criteria);\n    const sql = query.sql();\n    this.debugData(\"prepareUpdate()\", { where, sql })\n    return query\n  }\n\n  async validateUpdate(set, where, options) {\n    const [ , , update] = this.checkUpdatableColumns(set, options);\n    const [ , , criteria] = this.checkWhereColumns(where, options);\n    return [update, criteria]\n  }\n\n  async updateOne(set, where, options={}) {\n    this.debugData(\"updateOne()\", { set, where, options });\n    const update = await this\n      .prepareUpdate(set, where, options)\n      .then( query => query.run() );\n    return update.changes === 1\n      ? this.updated(set, where, update, options)\n      : unexpectedRowCount(update.changes, 'updated');\n  }\n\n  async updateAny(set, where, options={}) {\n    this.debugData(\"updateAny()\", { set, where, options });\n    const update = await this\n      .prepareUpdate(set, where, options)\n      .then( query => query.run() )\n    if (update.changes > 1) {\n      return unexpectedRowCount(update.changes, 'updated');\n    }\n    else if (update.changes === 1) {\n      return this.updated(set, where, update, options)\n    }\n    else {\n      return options.reload\n        ? undefined\n        : update;\n    }\n  }\n\n  async updateAll(set, where, options={}) {\n    this.debugData(\"updateAllRows()\", { set, where, options });\n    const update = await this\n      .prepareUpdate(set, where, options)\n      .then( query => query.run() );\n    return options.reload\n      ? fail(\"Cannot reload multiple updated rows\")\n      : update;\n  }\n\n  async updateOneRow(set, where, options) {\n    this.debugData(\"updateOneRow()\", { set, where, options });\n    return this.updateOne(set, where, this.withReloadOption(options))\n  }\n\n  async updateAnyRow(set, where, options) {\n    this.debugData(\"updateAnyRow()\", { set, where, options });\n    return this.updateAny(set, where, this.withReloadOption(options))\n  }\n\n  async updated(set, where, result, options) {\n    return options.reload\n      ? this.updateReload(set, where, options)\n      : result;\n  }\n\n  async updateReload(set, where, options) {\n    // For update queries things are a little more complicated.  In the\n    // usual case we can reload the rows using the original selection\n    // criteria (where).  But we might have done an update which changes\n    // that selection criteria (set), so we should use those values instead.\n    const fetch = { };\n    Object.keys(where).map(\n      key => fetch[key] = firstValue(set[key], where[key])\n    );\n    return this.oneRow(fetch, options);\n  }\n\n  //-----------------------------------------------------------------------------\n  // delete\n  //-----------------------------------------------------------------------------\n  async delete(where, options) {\n    this.debugData(\"delete()\", { where });\n    const criteria = await this.validateDelete(where, options)\n    const query = this\n      .build\n      .delete()\n      .from(this.table)\n      .where(criteria)\n    const sql = query.sql();\n    this.debugData(\"delete()\", { where, sql })\n    const result = await query.run();\n    return this.deleted(where, result, options)\n  }\n\n  async validateDelete(where, options) {\n    const [ , , criteria] = this.checkWhereColumns(where, options);\n    return criteria;\n  }\n\n  async deleted(where, result) {\n    return result;\n  }\n\n  //-----------------------------------------------------------------------------\n  // fetch - using where data\n  //-----------------------------------------------------------------------------\n  prepareFetch(where, options) {\n    const table = this.table;\n    const columns = options.columns || Object.keys(this.columns);\n    this.checkColumnNames(columns);\n    const [ , , criteria] = this.checkWhereColumns(where, options);\n    const query = this\n      .select({ table, columns })\n      .where(criteria)\n      .order(options.orderBy || options.order);\n    const sql = query.sql();\n    this.debugData(\"prepareFetch()\", { where, sql })\n    return query\n  }\n\n  async fetchOne(where, options={}) {\n    this.debugData(\"fetchOne()\", { where, options });\n    const row = await this.prepareFetch(where, options).one();\n    return this.loadedOne(row, options);\n  }\n\n  async fetchAny(where, options={}) {\n    this.debugData(\"fetchAny()\", { where, options });\n    const row = await this.prepareFetch(where, options).any();\n    return row\n      ? this.loadedOne(row, options)\n      : undefined;\n  }\n\n  async fetchAll(where, options={}) {\n    this.debugData(\"fetchAllRows()\", { where, options });\n    const rows = await this.prepareFetch(where, options).all();\n    return this.loadedAll(rows, options);\n  }\n\n  async fetchOneRecord(where, options) {\n    this.debugData(\"fetchOneRecord()\", { where, options });\n    return this.fetchOne(where, this.withRecordOption(options));\n  }\n\n  async fetchAnyRecord(where, options) {\n    this.debugData(\"fetchAnyRecord()\", { where, options });\n    return this.fetchAny(where, this.withRecordOption(options));\n  }\n\n  async fetchAllRecords(where, options) {\n    this.debugData(\"fetchAllRecords()\", { where, options });\n    return this.fetchAll(where, this.withRecordOption(options));\n  }\n\n  //-----------------------------------------------------------------------------\n  // Generic methods map onto equivalent fetch or select methods depending on\n  // first arguments.  If it's a query (string or builder) then it's forwarded\n  // to the select method, otherwise to the fetch method.\n  //-----------------------------------------------------------------------------\n  async oneRow(query, ...args) {\n    this.debugData(\"oneRow()\", { query, args });\n    return isQuery(query)\n      ? this.one(query, ...args)\n      : this.fetchOne(query, ...args)\n  }\n\n  async anyRow(query, ...args) {\n    this.debugData(\"anyRow()\", { query, ...args });\n    return isQuery(query)\n      ? this.any(query, ...args)\n      : this.fetchAny(query, ...args)\n  }\n\n  async allRows(query, ...args) {\n    this.debugData(\"allRows()\", { query, ...args });\n    return isQuery(query)\n      ? this.all(query, ...args)\n      : this.fetchAll(query, ...args)\n  }\n\n  async oneRecord(query, ...args) {\n    this.debugData(\"oneRecord()\", { query, args });\n    return isQuery(query)\n      ? this.one(query, args[0], this.withRecordOption(args[1]))\n      : this.fetchOne(query, this.withRecordOption(args[0]))\n  }\n\n  async anyRecord(query, ...args) {\n    this.debugData(\"anyRecord()\", { query, args });\n    return isQuery(query)\n      ? this.any(query, args[0], this.withRecordOption(args[1]))\n      : this.fetchAny(query, this.withRecordOption(args[0]))\n  }\n\n  async allRecords(query, ...args) {\n    this.debugData(\"allRecords()\", { query, args });\n    return isQuery(query)\n      ? this.all(query, args[0], this.withRecordOption(args[1]))\n      : this.fetchAll(query, this.withRecordOption(args[0]))\n  }\n\n  loaded(row, options={}) {\n    return options.record\n      ? this.record(row)\n      : row;\n  }\n\n  loadedOne(row, options={}) {\n    return this.loaded(row, options);\n  }\n\n  loadedAny(row, options={}) {\n    return row\n      ? this.loaded(row, options)\n      : undefined;\n  }\n\n  loadedAll(rows, options={}) {\n    return Promise.all(\n      rows.map( row => this.loaded(row, options) )\n    );\n  }\n\n  withReloadOption(options={}) {\n    return { ...options, reload: true };\n  }\n\n  withRecordOption(options={}) {\n    return { ...options, record: true };\n  }\n\n  //-----------------------------------------------------------------------------\n  // Column validation\n  //-----------------------------------------------------------------------------\n  checkColumnNames(names) {\n    const table = this.table;\n    splitList(names).forEach(\n      column => this.columns[column]\n          || throwColumnValidationError('unknown', { column, table })\n    )\n  }\n\n  checkColumns(data={}, options={}, cols=[], vals=[]) {\n    this.debugData(\"checkColumns()\", { data, options})\n    const table = this.table;\n    let result = { };\n    // check that all the values supplied correspond to valid columns\n    Object.keys(data).forEach(\n      column => {\n        const spec = this.columns[column];\n        if (spec) {\n          if (options.writable && spec.readonly) {\n            throwColumnValidationError('readonly', { column, table });\n          }\n          if (options.fixed && spec.fixed) {\n            throwColumnValidationError('fixed', { column, table });\n          }\n          // cols.push(options.tableColumn ? spec.tableColumn : spec.column);\n          cols.push(spec.column);\n          vals.push(data[column]);\n          result[spec.column] = data[column];\n        }\n        else if (! options.pick) {\n          throwColumnValidationError('unknown', { column, table });\n        }\n      }\n    )\n    this.debugData(\"checkColumns()\", { cols, vals })\n    return [cols, vals, result];\n  }\n\n  checkWritableColumns(data, options={}) {\n    return this.checkColumns(data, { ...options, writable: true })\n  }\n\n  checkUpdatableColumns(data, options={}) {\n    return this.checkColumns(data, { ...options, writable: true, fixed: true })\n  }\n\n  checkWhereColumns(where, options) {\n    return this.checkColumns(where, options)\n  }\n\n  checkRequiredColumns(data) {\n    const table = this.table;\n    this.required.forEach(\n      column => {\n        if (noValue(data[column])) {\n          throwColumnValidationError('required', { column, table });\n        }\n      }\n    );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Query builder methods\n  //-----------------------------------------------------------------------------\n  select(...args) {\n    if (args.length === 0) {\n      args.push({\n        table:   this.table,\n        columns: Object.keys(this.columns)\n      })\n    }\n    return this.build.select(...args).from(this.table)\n  }\n\n  //-----------------------------------------------------------------------------\n  // Record methods\n  //-----------------------------------------------------------------------------\n  newRecord(row) {\n    return recordProxy(\n      new this.recordClass(this, row, this.recordConfig)\n    );\n  }\n\n  record(row) {\n    this.debugData(\"record()\", { row });\n    return Promise.resolve(\n      this.newRecord(row)\n    );\n  }\n\n  records(rows) {\n    this.debugData(\"records()\", { rows });\n    return Promise.resolve(\n      rows.map(\n        row => this.newRecord(row)\n      )\n    );\n  }\n\n  //-----------------------------------------------------------------------------\n  // Utility methods\n  //-----------------------------------------------------------------------------\n  tableFragments() {\n    return this.tableFragments\n  }\n\n  identity(data) {\n    return this.keys.reduce(\n      (result, key) => {\n        result[key] = data[key]\n        return result\n      },\n      {}\n    );\n  }\n\n}\n\nexport default Table;\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Table.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 559,
    "kind": "variable",
    "name": "methodAliases",
    "memberof": "src/Table.js",
    "static": true,
    "longname": "src/Table.js~methodAliases",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{\"insertRow\": string, \"insertRows\": string, \"insertRecord\": string, \"insertRecords\": string, \"update\": string, \"updateRow\": string, \"fetch\": string, \"fetchRecord\": string, \"fetchRecords\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 560,
    "kind": "class",
    "name": "Table",
    "memberof": "src/Table.js",
    "static": true,
    "longname": "src/Table.js~Table",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Table}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/Queryable.js~Queryable"
    ]
  },
  {
    "__docId__": 561,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 562,
    "kind": "member",
    "name": "config",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#config",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 563,
    "kind": "member",
    "name": "database",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#database",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 564,
    "kind": "member",
    "name": "table",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#table",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 565,
    "kind": "member",
    "name": "columns",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#columns",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 566,
    "kind": "member",
    "name": "readonly",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#readonly",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "member",
    "name": "required",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#required",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 568,
    "kind": "member",
    "name": "keys",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#keys",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "member",
    "name": "id",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#id",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 570,
    "kind": "member",
    "name": "recordClass",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#recordClass",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 571,
    "kind": "member",
    "name": "recordConfig",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#recordConfig",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "member",
    "name": "queries",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#queries",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "member",
    "name": "fragments",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#fragments",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "member",
    "name": "relations",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#relations",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 575,
    "kind": "member",
    "name": "build",
    "memberof": "src/Table.js~Table",
    "static": false,
    "longname": "src/Table.js~Table#build",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "configure",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#configure",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 577,
    "kind": "method",
    "name": "prepareFragments",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#prepareFragments",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [
      {
        "name": "config",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "insert",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insert",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "prepareInsert",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#prepareInsert",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "validateInsert",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#validateInsert",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "insertOne",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertOne",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "insertAll",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertAll",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 583,
    "kind": "method",
    "name": "insertOneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertOneRow",
    "access": "public",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "insertAllRows",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertAllRows",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "insertOneRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertOneRecord",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 586,
    "kind": "method",
    "name": "insertAllRecords",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertAllRecords",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 587,
    "kind": "method",
    "name": "inserted",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#inserted",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      },
      {
        "name": "output",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 588,
    "kind": "method",
    "name": "insertReload",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#insertReload",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      },
      {
        "name": "output",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "prepareUpdate",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#prepareUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "validateUpdate",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#validateUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "updateOne",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateOne",
    "access": "public",
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "updateAny",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateAny",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "updateAll",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateAll",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "updateOneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateOneRow",
    "access": "public",
    "description": null,
    "lineNumber": 203,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "updateAnyRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateAnyRow",
    "access": "public",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "updated",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updated",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "updateReload",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#updateReload",
    "access": "public",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "set",
        "types": [
          "*"
        ]
      },
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "delete",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#delete",
    "access": "public",
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "validateDelete",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#validateDelete",
    "access": "public",
    "description": null,
    "lineNumber": 248,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "deleted",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#deleted",
    "access": "public",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 601,
    "kind": "method",
    "name": "prepareFetch",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#prepareFetch",
    "access": "public",
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 602,
    "kind": "method",
    "name": "fetchOne",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchOne",
    "access": "public",
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 603,
    "kind": "method",
    "name": "fetchAny",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchAny",
    "access": "public",
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 604,
    "kind": "method",
    "name": "fetchAll",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchAll",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 605,
    "kind": "method",
    "name": "fetchOneRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchOneRecord",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 606,
    "kind": "method",
    "name": "fetchAnyRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchAnyRecord",
    "access": "public",
    "description": null,
    "lineNumber": 299,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 607,
    "kind": "method",
    "name": "fetchAllRecords",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#fetchAllRecords",
    "access": "public",
    "description": null,
    "lineNumber": 304,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "method",
    "name": "oneRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#oneRow",
    "access": "public",
    "description": null,
    "lineNumber": 314,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "anyRow",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#anyRow",
    "access": "public",
    "description": null,
    "lineNumber": 321,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "allRows",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#allRows",
    "access": "public",
    "description": null,
    "lineNumber": 328,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "oneRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#oneRecord",
    "access": "public",
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "anyRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#anyRecord",
    "access": "public",
    "description": null,
    "lineNumber": 342,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "allRecords",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Table.js~Table#allRecords",
    "access": "public",
    "description": null,
    "lineNumber": 349,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "loaded",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#loaded",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "loadedOne",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#loadedOne",
    "access": "public",
    "description": null,
    "lineNumber": 362,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "loadedAny",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#loadedAny",
    "access": "public",
    "description": null,
    "lineNumber": 366,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "loadedAll",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#loadedAll",
    "access": "public",
    "description": null,
    "lineNumber": 372,
    "undocument": true,
    "params": [
      {
        "name": "rows",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 618,
    "kind": "method",
    "name": "withReloadOption",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#withReloadOption",
    "access": "public",
    "description": null,
    "lineNumber": 378,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "{...options: Object, \"reload\": boolean}"
      ]
    }
  },
  {
    "__docId__": 619,
    "kind": "method",
    "name": "withRecordOption",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#withRecordOption",
    "access": "public",
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "{...options: Object, \"record\": boolean}"
      ]
    }
  },
  {
    "__docId__": 620,
    "kind": "method",
    "name": "checkColumnNames",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkColumnNames",
    "access": "public",
    "description": null,
    "lineNumber": 389,
    "undocument": true,
    "params": [
      {
        "name": "names",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 621,
    "kind": "method",
    "name": "checkColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkColumns",
    "access": "public",
    "description": null,
    "lineNumber": 397,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "cols",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      },
      {
        "name": "vals",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 622,
    "kind": "method",
    "name": "checkWritableColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkWritableColumns",
    "access": "public",
    "description": null,
    "lineNumber": 426,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "checkUpdatableColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkUpdatableColumns",
    "access": "public",
    "description": null,
    "lineNumber": 430,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 624,
    "kind": "method",
    "name": "checkWhereColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkWhereColumns",
    "access": "public",
    "description": null,
    "lineNumber": 434,
    "undocument": true,
    "params": [
      {
        "name": "where",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 625,
    "kind": "method",
    "name": "checkRequiredColumns",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#checkRequiredColumns",
    "access": "public",
    "description": null,
    "lineNumber": 438,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "select",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#select",
    "access": "public",
    "description": null,
    "lineNumber": 452,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "newRecord",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#newRecord",
    "access": "public",
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 628,
    "kind": "method",
    "name": "record",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#record",
    "access": "public",
    "description": null,
    "lineNumber": 471,
    "undocument": true,
    "params": [
      {
        "name": "row",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "records",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#records",
    "access": "public",
    "description": null,
    "lineNumber": 478,
    "undocument": true,
    "params": [
      {
        "name": "rows",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 630,
    "kind": "method",
    "name": "tableFragments",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#tableFragments",
    "access": "public",
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 631,
    "kind": "method",
    "name": "identity",
    "memberof": "src/Table.js~Table",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Table.js~Table#identity",
    "access": "public",
    "description": null,
    "lineNumber": 494,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 632,
    "kind": "file",
    "name": "src/Tables.js",
    "content": "import { isFunction } from \"@abw/badger-utils\";\nimport { addDebugMethod } from \"./Utils/Debug.js\";\n\nexport class Tables {\n  constructor(tables={}) {\n    this.tables = tables;\n    addDebugMethod(this, 'tables');\n  }\n\n  async table(name) {\n    const config = this.tables[name];\n    if (isFunction(config) && isFunction(config.constructor)) {\n      // table config can be a class\n      return { tableClass: config };\n    }\n    return config;\n  }\n}\n\nexport default Tables;",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Tables.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 633,
    "kind": "class",
    "name": "Tables",
    "memberof": "src/Tables.js",
    "static": true,
    "longname": "src/Tables.js~Tables",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Tables}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 634,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Tables.js~Tables",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Tables.js~Tables#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true
  },
  {
    "__docId__": 635,
    "kind": "member",
    "name": "tables",
    "memberof": "src/Tables.js~Tables",
    "static": false,
    "longname": "src/Tables.js~Tables#tables",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 636,
    "kind": "method",
    "name": "table",
    "memberof": "src/Tables.js~Tables",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Tables.js~Tables#table",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "file",
    "name": "src/Transaction.js",
    "content": "import { addDebugMethod, missing, TransactionError } from \"./Utils/index.js\";\n\nexport class Transaction {\n  constructor(engine, config={}) {\n    this.engine       = engine || missing('engine')\n    this.completed    = false\n    this.autoCommit   = config.autoCommit\n    this.autoRollback = config.autoRollback\n    addDebugMethod(this, 'transaction', config)\n  }\n\n  async run(proxy, code) {\n    this.debug(\"run()\");\n    const commit   = this.commit.bind(this);\n    const rollback = this.rollback.bind(this);\n    try {\n      // acquire a database connection\n      await this.acquire();\n\n      // begin a transaction\n      await this.begin();\n\n      // run the code\n      await code(proxy, commit, rollback)\n      this.debug(\"code complete\")\n\n      // check that commit() or rollback() has been called\n      if (! this.completed) {\n        if (this.autoCommit) {\n          this.debug(\"autoCommit\");\n          await this.commit();\n        }\n        else if (this.autoRollback) {\n          this.debug(\"autoRollback\");\n          await this.rollback();\n        }\n        else {\n          this.fail('Transaction was not committed or rolled back');\n        }\n      }\n    }\n    catch(e) {\n      // if commit() or rollback() hasn't already been called then rollback\n      // the transaction and rethrow the error\n      if (! this.completed) {\n        this.debug(\"caught error, rolling back transaction\");\n        await this.rollback();\n      }\n      throw(e);\n    }\n    finally {\n      // release the database connection\n      await this.release();\n    }\n  }\n\n  async acquire() {\n    this.debug(\"acquire()\")\n    if (this.connection) {\n      this.fail('Transaction has already acquired a connection');\n    }\n    this.connection = await this.engine.acquire();\n  }\n\n  async release() {\n    this.debug(\"release()\")\n    if (! this.connection) {\n      this.fail('Transaction does not have a connection to release');\n    }\n    await this.engine.release(this.connection);\n    delete this.connection;\n  }\n\n  async begin() {\n    this.debug(\"begin()\")\n    this.engine.begin(this)\n  }\n\n  async commit() {\n    this.debug(\"commit()\")\n    this.complete('commit')\n    await this.engine.commit(this)\n  }\n\n  async rollback() {\n    this.debug(\"rollback()\")\n    this.complete('rollback');\n    await this.engine.rollback(this)\n  }\n\n  complete(action) {\n    if (this.completed) {\n      throw new TransactionError(`Cannot ${action} transaction - ${this.completed}() has already been called`)\n    }\n    this.completed = action;\n  }\n\n  fail(...args) {\n    throw new TransactionError(args.join(''));\n  }\n}\n\nexport default Transaction\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Transaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 638,
    "kind": "class",
    "name": "Transaction",
    "memberof": "src/Transaction.js",
    "static": true,
    "longname": "src/Transaction.js~Transaction",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{Transaction}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 639,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Transaction.js~Transaction#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 4,
    "undocument": true
  },
  {
    "__docId__": 640,
    "kind": "member",
    "name": "engine",
    "memberof": "src/Transaction.js~Transaction",
    "static": false,
    "longname": "src/Transaction.js~Transaction#engine",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 641,
    "kind": "member",
    "name": "completed",
    "memberof": "src/Transaction.js~Transaction",
    "static": false,
    "longname": "src/Transaction.js~Transaction#completed",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 642,
    "kind": "member",
    "name": "autoCommit",
    "memberof": "src/Transaction.js~Transaction",
    "static": false,
    "longname": "src/Transaction.js~Transaction#autoCommit",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 643,
    "kind": "member",
    "name": "autoRollback",
    "memberof": "src/Transaction.js~Transaction",
    "static": false,
    "longname": "src/Transaction.js~Transaction#autoRollback",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "run",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#run",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "proxy",
        "types": [
          "*"
        ]
      },
      {
        "name": "code",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "acquire",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#acquire",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 646,
    "kind": "member",
    "name": "connection",
    "memberof": "src/Transaction.js~Transaction",
    "static": false,
    "longname": "src/Transaction.js~Transaction#connection",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "release",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#release",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "begin",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#begin",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "commit",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#commit",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "rollback",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Transaction.js~Transaction#rollback",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "complete",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Transaction.js~Transaction#complete",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "action",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "fail",
    "memberof": "src/Transaction.js~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Transaction.js~Transaction#fail",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 654,
    "kind": "file",
    "name": "src/Utils/Article.js",
    "content": "// TODO: move this into badger-utils\nexport const article = noun =>\n  noun.match(/^[aeiou]/i)\n    ? 'an'\n    : 'a'\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Article.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 655,
    "kind": "function",
    "name": "article",
    "memberof": "src/Utils/Article.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Article.js~article",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{article}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "params": [
      {
        "name": "noun",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 656,
    "kind": "file",
    "name": "src/Utils/Color.js",
    "content": "import { color } from \"@abw/badger\";\n\nexport const red     = color('red');\nexport const green   = color('green');\nexport const blue    = color('blue');\nexport const yellow  = color('yellow');\nexport const cyan    = color('cyan');\nexport const magenta = color('magenta');",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Color.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 657,
    "kind": "variable",
    "name": "red",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~red",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{red}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 658,
    "kind": "variable",
    "name": "green",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~green",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{green}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 659,
    "kind": "variable",
    "name": "blue",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~blue",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{blue}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 660,
    "kind": "variable",
    "name": "yellow",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~yellow",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{yellow}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 661,
    "kind": "variable",
    "name": "cyan",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~cyan",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{cyan}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 662,
    "kind": "variable",
    "name": "magenta",
    "memberof": "src/Utils/Color.js",
    "static": true,
    "longname": "src/Utils/Color.js~magenta",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{magenta}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 663,
    "kind": "file",
    "name": "src/Utils/Columns.js",
    "content": "import { fail, isArray, isObject, isString, objMap, splitList } from \"@abw/badger-utils\";\nimport { bitSplitter, defaultIdColumn } from \"../Constants.js\";\nimport { throwColumnValidationError } from \"./Error.js\";\n\n\n/**\n * Function to prepare column definitions for a table.  If the columns specified\n * are a string of whitespace delimited tokens then they are first split into an\n * array.  An array is converted to a hash object by splitting each item on the\n * first colon, e.g. `id:required` has the column name `id` and flags of `required`.\n * Each value is then converted to an object, e.g. `required` becomes `{ required: true }`.\n * Then end result is an object where the keys are the column names and corresponding\n * values are objects containing any flags defined for the column.\n * @param {!Object} schema - scheme containing table properties\n * @param {!String} [schema.table] - the database table name\n * @param {String|Array|Object} [schema.columns] - the table columns\n * @return {Object} a column specification object\n * @example\n * const columns = prepareColumns({\n *   table:   'artists',\n *   columns: 'id name'\n * })\n * @example\n * const columns = prepareColumns({\n *   table:   'artists',\n *   columns: 'id:readonly name:required'\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: ['id:readonly', 'name:required']\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: {\n *     id:   'readonly',\n *     name: 'required'\n *   }\n * })\n * @example\n * const columns = prepareColumns({\n *   table: 'artists',\n *   columns: {\n *     id:   { readonly: true },\n *     name: { required: true }\n *   }\n * })\n */\nexport const prepareColumns = (schema) => {\n  const columns = schema.columns\n    || throwColumnValidationError('noColumns', { table: schema.table });\n\n  if (isString(columns)) {\n    return prepareColumnsString(columns, schema);\n  }\n  else if (isArray(columns)) {\n    return prepareColumnsArray(columns, schema);\n  }\n  else if (isObject(columns)) {\n    return prepareColumnsHash(columns, schema);\n  }\n  else {\n    return throwColumnValidationError('invalidColumns', { table: schema.table, columns });\n  }\n}\n\nconst prepareColumnsString = (columns, schema) => {\n  return prepareColumnsArray(splitList(columns), schema);\n}\n\nconst prepareColumnsArray = (columns, schema) => {\n  let index = { };\n  columns.forEach(\n    item => {\n      const bits  = item.split(bitSplitter);\n      const name  = bits.shift();\n      index[name] = prepareColumnBits(name, bits, schema);\n    }\n  )\n  return prepareColumnsHash(index, schema);\n}\n\nconst prepareColumnsHash = (columns, schema) => {\n  return objMap(\n    columns,\n    (value, name) => {\n      if (isString(value)) {\n        return prepareColumnBits(name, value.split(bitSplitter), schema)\n      }\n      else if (isObject(value)) {\n        // column name can be defined in column spec as 'column' in case\n        // the database column name doesn't match the name you want to use\n        const column = value.column || (value.column = name);\n        // tableColumn is the full \"table.column\"\n        value.tableColumn = schema.table + '.' + column;\n        return value;\n      }\n      else {\n        fail(`Invalid \"${name}\" columns specified in ${schema.table} table: ${value}`)\n      }\n    }\n  )\n}\n\n/**\n * @ignore\n * Internal function to convert an array of colon delimited parts from a column\n * specification string to an object.\n */\nconst prepareColumnBits = (name, bits, schema) => {\n  return bits.reduce(\n    (result, bit) => {\n      const kv = bit.split('=', 2);\n      const key = kv.shift();\n      result[key] = kv.length ? kv[0] : true;\n      return result\n    },\n    { column: name, tableColumn: schema.table + '.' + name }\n  );\n}\n\n\n/**\n * Function to determine the id and/or keys columns for a table.\n * If the keys are explicitly listed in the schema then they are used.\n * Otherwise it looks for each column that defines the `key` flag.\n * If the `id` column is set in the schema, or as an `id` flag on a\n * column then that is assumed to be both the id and single key.\n * If no keys or id is defined then we assume it's an `id` column.\n * @param {!Object} schema - scheme containing table properties\n * @param {!String} [schema.table] - the database table name\n * @param {Object} columns - the table columns\n * @return {Array} - an array of keys\n */\nexport const prepareKeys = (schema, columns={}) => {\n  let keys  = splitList(schema.keys);\n  const ids = Object.keys(columns).filter( key => columns[key].id );\n  if (ids.length > 1) {\n    return throwColumnValidationError('multipleIds', { table: schema.table });\n  }\n  if (keys.length === 0) {\n    keys = Object.keys(columns).filter( key => columns[key].key );\n  }\n  if (schema.id) {\n    keys.unshift(schema.id);\n  }\n  else if (ids.length) {\n    schema.id = ids[0];\n    keys.unshift(schema.id);\n  }\n  else if (keys.length === 0) {\n    schema.id = defaultIdColumn;\n    keys.unshift(schema.id);\n  }\n  return keys;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Columns.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 664,
    "kind": "function",
    "name": "prepareColumns",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumns",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{prepareColumns}",
    "description": "Function to prepare column definitions for a table.  If the columns specified\nare a string of whitespace delimited tokens then they are first split into an\narray.  An array is converted to a hash object by splitting each item on the\nfirst colon, e.g. `id:required` has the column name `id` and flags of `required`.\nEach value is then converted to an object, e.g. `required` becomes `{ required: true }`.\nThen end result is an object where the keys are the column names and corresponding\nvalues are objects containing any flags defined for the column.",
    "examples": [
      "const columns = prepareColumns({\n  table:   'artists',\n  columns: 'id name'\n})",
      "const columns = prepareColumns({\n  table:   'artists',\n  columns: 'id:readonly name:required'\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: ['id:readonly', 'name:required']\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: {\n    id:   'readonly',\n    name: 'required'\n  }\n})",
      "const columns = prepareColumns({\n  table: 'artists',\n  columns: {\n    id:   { readonly: true },\n    name: { required: true }\n  }\n})"
    ],
    "lineNumber": 50,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "scheme containing table properties"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.table",
        "description": "the database table name"
      },
      {
        "nullable": null,
        "types": [
          "String",
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.columns",
        "description": "the table columns"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a column specification object"
    }
  },
  {
    "__docId__": 665,
    "kind": "function",
    "name": "prepareColumnsString",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsString",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 666,
    "kind": "function",
    "name": "prepareColumnsArray",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsArray",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 667,
    "kind": "function",
    "name": "prepareColumnsHash",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnsHash",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "columns",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 668,
    "kind": "function",
    "name": "prepareColumnBits",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareColumnBits",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 111,
    "ignore": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "bits",
        "types": [
          "*"
        ]
      },
      {
        "name": "schema",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 669,
    "kind": "function",
    "name": "prepareKeys",
    "memberof": "src/Utils/Columns.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Columns.js~prepareKeys",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{prepareKeys}",
    "description": "Function to determine the id and/or keys columns for a table.\nIf the keys are explicitly listed in the schema then they are used.\nOtherwise it looks for each column that defines the `key` flag.\nIf the `id` column is set in the schema, or as an `id` flag on a\ncolumn then that is assumed to be both the id and single key.\nIf no keys or id is defined then we assume it's an `id` column.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "scheme containing table properties"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "schema.table",
        "description": "the database table name"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "columns",
        "description": "the table columns"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "an array of keys"
    }
  },
  {
    "__docId__": 670,
    "kind": "file",
    "name": "src/Utils/Database.js",
    "content": "import { extract, hasValue, isString, remove } from \"@abw/badger-utils\";\nimport { invalid, missing } from \"./Error.js\";\n\n/**\n * @ignore\n * Regex to parse database string.\n */\nexport const databaseStringRegex = /^(\\w+):\\/\\/(?:(?:(\\w+)(?::(\\w+))?@)?(\\w+)(?::(\\d+))?\\/)?(\\w+)/;\n\n/**\n * @ignore\n * Lookup table mapping captures from above regex to configuration option.\n */\nexport const databaseStringElements = {\n  engine:   1,\n  user:     2,\n  password: 3,\n  host:     4,\n  port:     5,\n  database: 6,\n};\n\n/**\n * @ignore\n * Lookup table of aliases for configuration options.\n */\nexport const databaseAliases = {\n  username: 'user',\n  pass:     'password',\n  hostname: 'host',\n  file:     'filename',\n  name:     'database',\n};\n\n/**\n * Function to create and sanitize a database configuration.  If the argument\n * is a string then it is passed to {@link parseDatabaseString}.\n * @param {!(Object|String)} config - database connection string or configuration object\n * @param {!String} [config.engine] - database engine, one of `sqlite`, `mysql` or `postgres`\n * @param {?String} [config.username] - alias for `user` option\n * @param {?String} [config.user] - name of user to connect to database\n * @param {?String} [config.password] - password for user to connect to database\n * @param {?String} [config.pass] - alias for `password` option\n * @param {?String} [config.host] - database host name\n * @param {?String} [config.hostname] - alias for `host` option\n * @param {?String} [config.port] - database port\n * @param {?String} [config.database] - database name\n * @param {?String} [config.filename] - database filename for sqlite databases\n * @param {?String} [config.file] - alias for `filename` option\n * @return {Object} the database config object\n * @example\n * const config = databaseConfig('sqlite://dbfile.db')\n * @example\n * const config = databaseConfig('mysql://user:password@hostname:port//database')\n * @example\n * const config = databaseConfig('postgres://user:password@hostname:port//database')\n * @example\n * const config = databaseConfig({\n *   engine:   'sqlite',\n *   filename: 'dbfile.db'\n * })\n * @example\n * const config = databaseConfig({\n *   engine:   'postgres',\n *   database: 'musicdb',\n *   user:     'bobby',\n *   password: 'secret',\n *   host:     'mydbhost.com',\n *   port:     '5150'\n * })\n */\nexport const databaseConfig = config => {\n  if (config.env) {\n    Object.assign(config, configEnv(config.env, { prefix: config.envPrefix }))\n  }\n  let database = config.database || missing('database');\n\n  if (isString(database)) {\n    // parse connection string\n    config.database = database = parseDatabaseString(database);\n  }\n\n  // extract the engine name to top level config\n  config.engine ||= database.engine || missing('database.engine');\n  delete database.engine;\n\n  // fixup any aliases\n  Object.entries(databaseAliases).map(\n    ([key, value]) => {\n      if (hasValue(database[key])) {\n        database[value] ||= remove(database, key);\n      }\n    }\n  )\n\n  // merge in any engineOptions\n  if (config.engineOptions) {\n    Object.assign(database, remove(config, 'engineOptions'));\n  }\n\n  return config;\n}\n\nexport const configEnv = (env, options={}) => {\n  const prefix   = options.prefix || 'DATABASE'\n  const uscore   = prefix.match(/_$/) ? '' : '_';\n  const regex    = new RegExp(`^${prefix}${uscore}`);\n\n  // if there's an environment variable that exactly matches the prefix,\n  // e.g. DATABASE or MY_DATABASE then it's assumed to be a connection\n  // string.  Otherwise we extract all the environment variables that\n  // start with the prefix (and an underscore if there isn't already one)\n  // on the prefix), e.g. DATABASE_ENGINE, DATABASE_HOST, etc., and put\n  // them in an object\n  const database = env[prefix]\n    || extract(\n      env, regex,\n      { key: key => key.replace(regex, '').toLowerCase() }\n    );\n\n  return { database }\n}\n\n\n/**\n * Function to parse a database configuration string and return an object of\n * configuration options.\n * @param {!String} string - database connection string\n * @return {Object} a database config object parsed from the string\n * @example\n * config config = parseDatabaseString('postgresql://user:password@host:port/database')\n * @example\n * const config = parseDatabaseString('sqlite://filename.db')\n * @example\n * const config = parseDatabaseString('sqlite://:memory:')\n * @example\n * const config = parseDatabaseString('sqlite:memory')\n * @example\n */\nexport const parseDatabaseString = string => {\n  let config = { };\n  let match;\n\n  if (string.match(/^postgres(ql)?:/)) {\n    // special case for postgres which can handle a connectionString\n    // NOTE: we accept postgresql: or postgres: as prefixes and Do The\n    // Right Thing\n    config.engine = 'postgres';\n    config.connectionString = string.replace(/^postgres:/, 'postgresql:');\n  }\n  else if ((match = string.match(/^sqlite:\\/\\/(.*)/))) {\n    // special case for sqlite which only has a filename (or \":memory:\")\n    config.engine   = 'sqlite';\n    config.filename = match[1];\n  }\n  else if (string === 'sqlite:memory') {\n    // special case for sqlite allowing 'sqlite:memory' as short for 'sqlite://:memory:'\n    config.engine   = 'sqlite';\n    config.filename = ':memory:';\n  }\n  else if ((match = string.match(databaseStringRegex))) {\n    // all other cases (e.g. mysql)\n    Object.entries(databaseStringElements).map(\n      ([key, index]) => {\n        const value = match[index];\n        if (hasValue(value)) {\n          config[key] = value;\n        }\n      }\n    );\n  }\n  else {\n    invalid('database', string);\n  }\n  return config;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 671,
    "kind": "variable",
    "name": "databaseStringRegex",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseStringRegex",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseStringRegex}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "undefined"
      ]
    }
  },
  {
    "__docId__": 672,
    "kind": "variable",
    "name": "databaseStringElements",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseStringElements",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseStringElements}",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "{\"engine\": number, \"user\": number, \"password\": number, \"host\": number, \"port\": number, \"database\": number}"
      ]
    }
  },
  {
    "__docId__": 673,
    "kind": "variable",
    "name": "databaseAliases",
    "memberof": "src/Utils/Database.js",
    "static": true,
    "longname": "src/Utils/Database.js~databaseAliases",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseAliases}",
    "description": "",
    "lineNumber": 27,
    "ignore": true,
    "type": {
      "types": [
        "{\"username\": string, \"pass\": string, \"hostname\": string, \"file\": string, \"name\": string}"
      ]
    }
  },
  {
    "__docId__": 674,
    "kind": "function",
    "name": "databaseConfig",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~databaseConfig",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{databaseConfig}",
    "description": "Function to create and sanitize a database configuration.  If the argument\nis a string then it is passed to {@link parseDatabaseString}.",
    "examples": [
      "const config = databaseConfig('sqlite://dbfile.db')",
      "const config = databaseConfig('mysql://user:password@hostname:port//database')",
      "const config = databaseConfig('postgres://user:password@hostname:port//database')",
      "const config = databaseConfig({\n  engine:   'sqlite',\n  filename: 'dbfile.db'\n})",
      "const config = databaseConfig({\n  engine:   'postgres',\n  database: 'musicdb',\n  user:     'bobby',\n  password: 'secret',\n  host:     'mydbhost.com',\n  port:     '5150'\n})"
    ],
    "lineNumber": 72,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object",
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "database connection string or configuration object"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.engine",
        "description": "database engine, one of `sqlite`, `mysql` or `postgres`"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.username",
        "description": "alias for `user` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.user",
        "description": "name of user to connect to database"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.password",
        "description": "password for user to connect to database"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.pass",
        "description": "alias for `password` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.host",
        "description": "database host name"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.hostname",
        "description": "alias for `host` option"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.port",
        "description": "database port"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.database",
        "description": "database name"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.filename",
        "description": "database filename for sqlite databases"
      },
      {
        "nullable": true,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "config.file",
        "description": "alias for `filename` option"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "the database config object"
    }
  },
  {
    "__docId__": 675,
    "kind": "function",
    "name": "configEnv",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~configEnv",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{configEnv}",
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "params": [
      {
        "name": "env",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "{\"database\": *}"
      ]
    }
  },
  {
    "__docId__": 676,
    "kind": "function",
    "name": "parseDatabaseString",
    "memberof": "src/Utils/Database.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Database.js~parseDatabaseString",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{parseDatabaseString}",
    "description": "Function to parse a database configuration string and return an object of\nconfiguration options.",
    "examples": [
      "config config = parseDatabaseString('postgresql://user:password@host:port/database')",
      "const config = parseDatabaseString('sqlite://filename.db')",
      "const config = parseDatabaseString('sqlite://:memory:')",
      "const config = parseDatabaseString('sqlite:memory')",
      ""
    ],
    "lineNumber": 140,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "database connection string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a database config object parsed from the string"
    }
  },
  {
    "__docId__": 677,
    "kind": "file",
    "name": "src/Utils/Debug.js",
    "content": "import { addDebug, ANSIescape, ANSIreset } from \"@abw/badger\";\nimport { doNothing, fail, isBoolean, isObject } from \"@abw/badger-utils\";\n\n/**\n * @ignore\n * Default width for debugging prefix column.\n */\nconst debugWidth = 16;\n\n/**\n * @ignore\n * Default debugging options\n */\nexport let debug = {\n  database: {\n    debug:  false,\n    prefix: 'Database',\n    color:  'bright magenta',\n  },\n  engine: {\n    debug:  false,\n    prefix: 'Engine',\n    color:  'red',\n  },\n  query: {\n    debug:  false,\n    prefix: 'Query',\n    color:  'cyan',\n  },\n  tables: {\n    debug:  false,\n    prefix: 'Tables',\n    color:  'blue',\n  },\n  table: {\n    debug:  false,\n    prefix: 'Table',\n    color:  'bright cyan',\n  },\n  record: {\n    debug:  false,\n    prefix: 'Record',\n    color:  'green',\n  },\n  builder: {\n    debug:  false,\n    prefix: 'Builder',\n    color:  'yellow',\n  },\n  transaction: {\n    debug:  false,\n    prefix: 'Transaction',\n    color:  'bright red'\n  },\n  test: {\n    debug:  false,\n    prefix: 'Test',\n    color:  'green'\n  },\n}\n\n/**\n * @ignore\n * Function to throw an error for an invalid debug option\n */\nconst invalidDebugItem = item =>\n  fail(`Invalid debug item \"${item}\" specified`)\n\n/**\n * Function to set debugging options.  Each key in the `options` should be\n * one of the components that supports debugging: `database`, `engine`, `queries`,\n * `table` or `record`.  The corresponding values should be a boolean value to\n * enable or disable debugging for the option or an object containing a `debug`\n * flag, and optionally, a `prefix` and/or `color`.\n * @param {!Object} options - debugging options\n * @example\n * setDebug({ engine: true })\n * @example\n * setDebug({\n *   engine: {\n *     debug: true,\n *     prefix: 'Choo Choo!',\n *     color: 'green'\n *   }\n * })\n */\nexport const setDebug = options => {\n  Object.entries(options).map(\n    ([key, value]) => {\n      const set = debug[key] || invalidDebugItem(key);\n      if (isBoolean(value)) {\n        set.debug = value;\n      }\n      else if (isObject(value)) {\n        Object.assign(set, value);\n      }\n    }\n  )\n}\n\n/**\n * Function to get debugging options for one of the components that supports debugging:\n * `database`, `engine`, `queries`, `table` or `record`.  One or more additional\n * objects can be passed that contain further configuration options. The returned object\n * will contained a merged set of the defaults and those options.\n * @param {!String} name - debugging options\n * @param {...Object} configs - additional debugging options\n * @example\n * getDebug('engine')\n * @example\n * getDebug('engine', { debug: true })\n * @example\n * getDebug('engine', { debug: true, color: 'green' })\n * @example\n * getDebug('engine', { debug: true }, { color: 'green' })\n */\nexport const getDebug = (name, ...configs) => {\n  const defaults = debug[name] || invalidDebugItem(name);\n  return Object.assign(\n    {},\n    defaults,\n    ...configs\n  );\n}\n\n/**\n * Function to add the `debug()` and `debugData()` methods to an object.\n * `database`, `engine`, `queries`, `table` or `record`.  One or more additional\n * objects can be passed that contain further configuration options. The returned object\n * will contained a merged set of the defaults and those options.\n * @param {!Object} object - object to receive methods\n * @param {!String} name - name of component type\n * @param {...Object} configs - additional debugging options\n * @example\n * addDebugMethod(myObject, 'engine', { debug: true })\n * @example\n * getDebug(myObject, 'engine', { debug: true }, { color: 'green' })\n */\nexport const addDebugMethod = (object, name, ...configs) => {\n  const options = getDebug(name, ...configs);\n  const enabled = options.debug;\n  const prefix  = options.debugPrefix || options.prefix;\n  const color   = options.debugColor  || options.color;\n  const preline = prefix.length > debugWidth - 2\n    ? prefix + \"\\n\" + \"\".padEnd(debugWidth, '-') + '> '\n    : (prefix + ' ').padEnd(debugWidth, '-') + '> ';\n  addDebug(object, enabled, preline, color);\n  object.debugData = DataDebugger(enabled, preline, color);\n}\n\n/**\n * @ignore\n * Function to generate a debugData() method for the above.\n */\nfunction DataDebugger(enabled, prefix, color, length=debugWidth) {\n  return enabled\n    ? (message, data={}) => {\n        console.log(\n          '%s' + prefix + '%s' + message,\n          color ? ANSIescape(color) : '',\n          color ? ANSIreset() : ''\n        );\n        Object.entries(data).map(\n          ([key, value]) => console.log(\n            '%s' + key.padStart(length, ' ') + ':%s',\n            color ? ANSIescape(color) : '',\n            color ? ANSIreset() : '',\n            value\n          )\n        )\n      }\n    : doNothing;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Debug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 678,
    "kind": "variable",
    "name": "debugWidth",
    "memberof": "src/Utils/Debug.js",
    "static": true,
    "longname": "src/Utils/Debug.js~debugWidth",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 679,
    "kind": "variable",
    "name": "debug",
    "memberof": "src/Utils/Debug.js",
    "static": true,
    "longname": "src/Utils/Debug.js~debug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{debug}",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "type": {
      "types": [
        "{\"database\": *, \"engine\": *, \"query\": *, \"tables\": *, \"table\": *, \"record\": *, \"builder\": *, \"transaction\": *, \"test\": *}"
      ]
    }
  },
  {
    "__docId__": 680,
    "kind": "function",
    "name": "invalidDebugItem",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~invalidDebugItem",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 66,
    "ignore": true,
    "params": [
      {
        "name": "item",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 681,
    "kind": "function",
    "name": "setDebug",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~setDebug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{setDebug}",
    "description": "Function to set debugging options.  Each key in the `options` should be\none of the components that supports debugging: `database`, `engine`, `queries`,\n`table` or `record`.  The corresponding values should be a boolean value to\nenable or disable debugging for the option or an object containing a `debug`\nflag, and optionally, a `prefix` and/or `color`.",
    "examples": [
      "setDebug({ engine: true })",
      "setDebug({\n  engine: {\n    debug: true,\n    prefix: 'Choo Choo!',\n    color: 'green'\n  }\n})"
    ],
    "lineNumber": 87,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "debugging options"
      }
    ],
    "return": null
  },
  {
    "__docId__": 682,
    "kind": "function",
    "name": "getDebug",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~getDebug",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{getDebug}",
    "description": "Function to get debugging options for one of the components that supports debugging:\n`database`, `engine`, `queries`, `table` or `record`.  One or more additional\nobjects can be passed that contain further configuration options. The returned object\nwill contained a merged set of the defaults and those options.",
    "examples": [
      "getDebug('engine')",
      "getDebug('engine', { debug: true })",
      "getDebug('engine', { debug: true, color: 'green' })",
      "getDebug('engine', { debug: true }, { color: 'green' })"
    ],
    "lineNumber": 117,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "debugging options"
      },
      {
        "nullable": null,
        "types": [
          "...Object"
        ],
        "spread": true,
        "optional": false,
        "name": "configs",
        "description": "additional debugging options"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 683,
    "kind": "function",
    "name": "addDebugMethod",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~addDebugMethod",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{addDebugMethod}",
    "description": "Function to add the `debug()` and `debugData()` methods to an object.\n`database`, `engine`, `queries`, `table` or `record`.  One or more additional\nobjects can be passed that contain further configuration options. The returned object\nwill contained a merged set of the defaults and those options.",
    "examples": [
      "addDebugMethod(myObject, 'engine', { debug: true })",
      "getDebug(myObject, 'engine', { debug: true }, { color: 'green' })"
    ],
    "lineNumber": 139,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "object to receive methods"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of component type"
      },
      {
        "nullable": null,
        "types": [
          "...Object"
        ],
        "spread": true,
        "optional": false,
        "name": "configs",
        "description": "additional debugging options"
      }
    ],
    "return": null
  },
  {
    "__docId__": 684,
    "kind": "function",
    "name": "DataDebugger",
    "memberof": "src/Utils/Debug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Debug.js~DataDebugger",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": "",
    "lineNumber": 155,
    "ignore": true,
    "params": [
      {
        "name": "enabled",
        "types": [
          "*"
        ]
      },
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      },
      {
        "name": "color",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "debugWidth",
        "defaultValue": "debugWidth"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 685,
    "kind": "file",
    "name": "src/Utils/Error.js",
    "content": "import { fail } from \"@abw/badger-utils\"\nimport { format } from \"./Format.js\"\n\n//-----------------------------------------------------------------------------\n// General purpose error messages\n//-----------------------------------------------------------------------------\n/**\n * Function to throw a generic error used to report a missing configration item.\n * The error message will be of the form `No \"XXX\" specified`.\n * @param {!String} item - the name of the missing item\n * @example\n * missing('badger');   // throws error: No \"badger\" specified\n */\nexport const missing = (item) =>\n  fail(`No \"${item}\" specified`)\n\n/**\n * Function to throw a generic error used to report an invalid configration item.\n * The error message will be of the form `Invalid \"XXX\" specified: YYY`.\n * @param {!String} item - the name of the invalid item\n * @param value - the value of the invalid item\n * @example\n * invalid('badger', 99);   // throws error: Invalid \"badger\" specified: 99\n */\nexport const invalid = (item, value) =>\n  fail(`Invalid \"${item}\" specified: ${value}`)\n\n/**\n * Function to throw a generic error reporting that a method is not implemented.\n * This is used in base classes (e.g. {@link Engine}) where subclasses are\n * required to implement the method.\n * The error message will be of the form `METHOD is not implemented in MODULE`.\n * @param {!String} method - the name of the method\n * @param {!String} module - the name of the module\n * @example\n * notImplemented('wibble', 'FrussetPouch');  // throws error: wibble is not implemented in FrussetPouch\n */\nexport const notImplemented = (method, module) =>\n  fail(`${method} is not implemented in ${module}`)\n\n/**\n * Currying function used to generate a function that calls {@link notImplemented}\n * with the module name pre-defined.\n * @param {!String} module - the name of the module\n * @example\n * const thrower = notImplementedInModule('FrussetPouch');\n * throws('wibble');  // throws error: wibble is not implemented in FrussetPouch\n */\nexport const notImplementedInModule = module => method =>\n  notImplemented(method, module)\n\n/**\n * Wrapper around {@link notImplementedInModule} which provides a\n * more explicit error message for base classes.\n * @param {!String} module - the name of the module\n * @example\n * const thrower = notImplementedInModule('FrussetPouch');\n * throws('wibble');  // throws error: wibble is not implemented in the FrussetPouch base class\n */\nexport const notImplementedInBaseClass = module =>\n  notImplementedInModule(`the ${module} base class`)\n\n//-----------------------------------------------------------------------------\n// Custom error classes\n//-----------------------------------------------------------------------------\n/**\n * Error class for generating custom errors.\n */\nexport class CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class SQLParseError extends Error {\n  constructor(query, args) {\n    super(args.message);\n    this.name  = this.constructor.name;\n    this.query = query;\n    this.type  = args.type;\n    this.code  = args.code;\n    this.position = args.position;\n    if (args.stack) {\n      this.stack = args.stack;\n    }\n  }\n}\n\n/**\n * Error class for reporting failure to load engine driver\n */\nexport class EngineDriverError extends CustomError { }\nexport const throwEngineDriver = (module, error) => {\n  throw new EngineDriverError(\n    `Failed to load \"${module}\" engine driver module.  Have you installed it?\\nError: ` + error.message\n  )\n}\n\n/**\n * Error class for reporting unexpected number of rows returned by a\n * database query.\n */\nexport class UnexpectedRowCount extends CustomError { }\n\n/**\n * Error class for reporting columns validation errors, e.g. when\n * attempting to update a `readonly` column.\n */\nexport class ColumnValidationError extends CustomError { }\n\n/**\n * Error class for reporting validation errors when inserting a row.\n */\nexport class InsertValidationError extends CustomError { }\n\n/**\n * Error class for reporting attempts to update a deleted record.\n */\nexport class DeletedRecordError extends CustomError { }\n\n/**\n * Error class for reporting query builder errors\n */\nexport class QueryBuilderError extends CustomError { }\n\n/**\n * Error class for reporting transaction errors\n */\nexport class TransactionError extends CustomError { }\n\n/**\n * Function for throwing a {@link UnexpectedRowCount} error when multiple\n * rows were returned or updated when only one was expected.\n * @param {!Integer} n - the number of rows encountered\n * @param {String} [action=returned] - the action that was being performed.\n * @example\n * // throw UnexpectedRowCount error with message \"10 rows were returned when one was expected\"\n * unexpectedRowCount(10);\n * @example\n * // throw UnexpectedRowCount error with message \"10 rows were updated when one was expected\"\n * unexpectedRowCount(10, 'updated');\n */\nexport function unexpectedRowCount(n, action='returned') {\n  throw new UnexpectedRowCount(`${n} rows were ${action} when one was expected`)\n}\n\n/**\n * Function to contruct a function for throwing errors of a particular type\n * using message formats.  The function returned expects a format name and\n * an optional object containing values to insert into the message format.\n * @param {!Object} formats - an object mapping short names to message formats\n * @param {Error} [error=Error] - the error type\n * @example\n * const hurl = thrower({ oops => 'Unexpected <animal> encountered });\n * hurl('oops', 'badger');  // throws error: Unexpected badger encountered\n */\nexport const thrower = (formats, error=Error) =>\n  (fmt, data) => {\n    const message = format(\n      formats[fmt] || fail(\"Invalid message format: \", fmt),\n      data\n    );\n    throw new error(message)\n  }\n\n/**\n * Error throwing function for column validation errors.\n */\nexport const throwColumnValidationError = thrower(\n  {\n    unknown:        'Unknown \"<column>\" column in the <table> table',\n    readonly:       'The \"<column>\" column is readonly in the <table> table',\n    fixed:          'The \"<column>\" column is fixed in the <table> table',\n    required:       'Missing required column \"<column>\" for the <table> table',\n    multipleIds:    'Multiple columns are marked as \"id\" in the <table> table',\n    noColumns:      'No \"columns\" specified for the <table> table',\n    invalidColumns: 'Invalid \"columns\" specified for the <table> table: <columns>',\n  },\n  ColumnValidationError\n)\n\n/**\n * Error throwing function for deleted record errors.\n */\nexport const throwDeletedRecordError = thrower(\n  {\n    action: 'Cannot <action> deleted <table> record #<id>',\n  },\n  DeletedRecordError\n)\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 686,
    "kind": "function",
    "name": "missing",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~missing",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{missing}",
    "description": "Function to throw a generic error used to report a missing configration item.\nThe error message will be of the form `No \"XXX\" specified`.",
    "examples": [
      "missing('badger');   // throws error: No \"badger\" specified"
    ],
    "lineNumber": 14,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "the name of the missing item"
      }
    ],
    "return": null
  },
  {
    "__docId__": 687,
    "kind": "function",
    "name": "invalid",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~invalid",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{invalid}",
    "description": "Function to throw a generic error used to report an invalid configration item.\nThe error message will be of the form `Invalid \"XXX\" specified: YYY`.",
    "examples": [
      "invalid('badger', 99);   // throws error: Invalid \"badger\" specified: 99"
    ],
    "lineNumber": 25,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": "the name of the invalid item"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value of the invalid item"
      }
    ],
    "return": null
  },
  {
    "__docId__": 688,
    "kind": "function",
    "name": "notImplemented",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplemented",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplemented}",
    "description": "Function to throw a generic error reporting that a method is not implemented.\nThis is used in base classes (e.g. {@link Engine}) where subclasses are\nrequired to implement the method.\nThe error message will be of the form `METHOD is not implemented in MODULE`.",
    "examples": [
      "notImplemented('wibble', 'FrussetPouch');  // throws error: wibble is not implemented in FrussetPouch"
    ],
    "lineNumber": 38,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "the name of the method"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 689,
    "kind": "function",
    "name": "notImplementedInModule",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplementedInModule",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplementedInModule}",
    "description": "Currying function used to generate a function that calls {@link notImplemented}\nwith the module name pre-defined.",
    "examples": [
      "const thrower = notImplementedInModule('FrussetPouch');\nthrows('wibble');  // throws error: wibble is not implemented in FrussetPouch"
    ],
    "lineNumber": 49,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 690,
    "kind": "function",
    "name": "notImplementedInBaseClass",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~notImplementedInBaseClass",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{notImplementedInBaseClass}",
    "description": "Wrapper around {@link notImplementedInModule} which provides a\nmore explicit error message for base classes.",
    "examples": [
      "const thrower = notImplementedInModule('FrussetPouch');\nthrows('wibble');  // throws error: wibble is not implemented in the FrussetPouch base class"
    ],
    "lineNumber": 60,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "module",
        "description": "the name of the module"
      }
    ],
    "return": null
  },
  {
    "__docId__": 691,
    "kind": "class",
    "name": "CustomError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~CustomError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{CustomError}",
    "description": "Error class for generating custom errors.",
    "lineNumber": 69,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 692,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Utils/Error.js~CustomError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/Error.js~CustomError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true
  },
  {
    "__docId__": 693,
    "kind": "member",
    "name": "name",
    "memberof": "src/Utils/Error.js~CustomError",
    "static": false,
    "longname": "src/Utils/Error.js~CustomError#name",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 694,
    "kind": "class",
    "name": "SQLParseError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~SQLParseError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{SQLParseError}",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 695,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true
  },
  {
    "__docId__": 696,
    "kind": "member",
    "name": "name",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#name",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 697,
    "kind": "member",
    "name": "query",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#query",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 698,
    "kind": "member",
    "name": "type",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#type",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 699,
    "kind": "member",
    "name": "code",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#code",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 700,
    "kind": "member",
    "name": "position",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#position",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 701,
    "kind": "member",
    "name": "stack",
    "memberof": "src/Utils/Error.js~SQLParseError",
    "static": false,
    "longname": "src/Utils/Error.js~SQLParseError#stack",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 702,
    "kind": "class",
    "name": "EngineDriverError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~EngineDriverError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{EngineDriverError}",
    "description": "Error class for reporting failure to load engine driver",
    "lineNumber": 93,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 703,
    "kind": "function",
    "name": "throwEngineDriver",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~throwEngineDriver",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwEngineDriver}",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "params": [
      {
        "name": "module",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 704,
    "kind": "class",
    "name": "UnexpectedRowCount",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~UnexpectedRowCount",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{UnexpectedRowCount}",
    "description": "Error class for reporting unexpected number of rows returned by a\ndatabase query.",
    "lineNumber": 104,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 705,
    "kind": "class",
    "name": "ColumnValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~ColumnValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{ColumnValidationError}",
    "description": "Error class for reporting columns validation errors, e.g. when\nattempting to update a `readonly` column.",
    "lineNumber": 110,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 706,
    "kind": "class",
    "name": "InsertValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~InsertValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{InsertValidationError}",
    "description": "Error class for reporting validation errors when inserting a row.",
    "lineNumber": 115,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 707,
    "kind": "class",
    "name": "DeletedRecordError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~DeletedRecordError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{DeletedRecordError}",
    "description": "Error class for reporting attempts to update a deleted record.",
    "lineNumber": 120,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 708,
    "kind": "class",
    "name": "QueryBuilderError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~QueryBuilderError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{QueryBuilderError}",
    "description": "Error class for reporting query builder errors",
    "lineNumber": 125,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 709,
    "kind": "class",
    "name": "TransactionError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~TransactionError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{TransactionError}",
    "description": "Error class for reporting transaction errors",
    "lineNumber": 130,
    "interface": false,
    "extends": [
      "CustomError"
    ]
  },
  {
    "__docId__": 710,
    "kind": "function",
    "name": "unexpectedRowCount",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~unexpectedRowCount",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{unexpectedRowCount}",
    "description": "Function for throwing a {@link UnexpectedRowCount} error when multiple\nrows were returned or updated when only one was expected.",
    "examples": [
      "// throw UnexpectedRowCount error with message \"10 rows were returned when one was expected\"\nunexpectedRowCount(10);",
      "// throw UnexpectedRowCount error with message \"10 rows were updated when one was expected\"\nunexpectedRowCount(10, 'updated');"
    ],
    "lineNumber": 144,
    "params": [
      {
        "nullable": false,
        "types": [
          "Integer"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "the number of rows encountered"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "returned",
        "defaultRaw": "returned",
        "name": "action",
        "description": "the action that was being performed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 711,
    "kind": "function",
    "name": "thrower",
    "memberof": "src/Utils/Error.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Error.js~thrower",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{thrower}",
    "description": "Function to contruct a function for throwing errors of a particular type\nusing message formats.  The function returned expects a format name and\nan optional object containing values to insert into the message format.",
    "examples": [
      "const hurl = thrower({ oops => 'Unexpected <animal> encountered });\nhurl('oops', 'badger');  // throws error: Unexpected badger encountered"
    ],
    "lineNumber": 158,
    "params": [
      {
        "nullable": false,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "formats",
        "description": "an object mapping short names to message formats"
      },
      {
        "nullable": null,
        "types": [
          "Error"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Error",
        "defaultRaw": "Error",
        "name": "error",
        "description": "the error type"
      }
    ],
    "return": null
  },
  {
    "__docId__": 712,
    "kind": "variable",
    "name": "throwColumnValidationError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~throwColumnValidationError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwColumnValidationError}",
    "description": "Error throwing function for column validation errors.",
    "lineNumber": 170,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 713,
    "kind": "variable",
    "name": "throwDeletedRecordError",
    "memberof": "src/Utils/Error.js",
    "static": true,
    "longname": "src/Utils/Error.js~throwDeletedRecordError",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{throwDeletedRecordError}",
    "description": "Error throwing function for deleted record errors.",
    "lineNumber": 186,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 714,
    "kind": "file",
    "name": "src/Utils/Format.js",
    "content": "import { fail, noValue } from \"@abw/badger-utils\";\n\n/**\n * Function to format strings by inserting values into placeholder locations.\n * @param {!String} msg - the source string\n * @param {Object} data - data items to insert into the string\n * @returns {String} - the expanded string\n * @example\n * format('Hello <name>!', { name: 'World'});  // Hello World!\n */\nexport const format = (msg, data) =>\n  msg.replace(\n    /<(\\w+)>/g,\n    (_, key) => {\n      const val = data[key];\n      if (noValue(val)) {\n        fail(`Invalid variable expansion <${key}> in message format: ${msg}`);\n      }\n      return val;\n    }\n  );\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Format.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 715,
    "kind": "function",
    "name": "format",
    "memberof": "src/Utils/Format.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Format.js~format",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{format}",
    "description": "Function to format strings by inserting values into placeholder locations.",
    "examples": [
      "format('Hello <name>!', { name: 'World'});  // Hello World!"
    ],
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String} - the expanded string"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "the source string"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "data items to insert into the string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the expanded string"
    }
  },
  {
    "__docId__": 716,
    "kind": "file",
    "name": "src/Utils/Methods.js",
    "content": "import { fail } from \"@abw/badger-utils\";\n\nexport const aliasMethods = (object, aliases) =>\n  Object.entries(aliases).map(\n    ([alias, method]) => object[alias] = object[method]\n      || fail(`Invalid alias \"${alias}\" references non-existent method \"${method}\"`)\n  )\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Methods.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 717,
    "kind": "function",
    "name": "aliasMethods",
    "memberof": "src/Utils/Methods.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Methods.js~aliasMethods",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{aliasMethods}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "object",
        "types": [
          "*"
        ]
      },
      {
        "name": "aliases",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 718,
    "kind": "file",
    "name": "src/Utils/Queries.js",
    "content": "import Builder from \"../Builder.js\";\nimport { fail, isString } from \"@abw/badger-utils\";\n\nexport const isQuery = query =>\n  isString(query) || (query instanceof Builder)\n\nexport const expandFragments = (query, queryable, maxDepth=16) => {\n  query = query.trim();\n  let sql = query;\n  let runaway = 0;\n  let expanded = [ ];\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let replaced = false;\n    sql = sql.replace(\n      /<(\\w+?)>/g,\n      (match, word) => {\n        replaced = true;\n        expanded.push(word);\n        return queryable.fragment(word);\n      }\n    );\n    if (! replaced) {\n      break;\n    }\n    if (++runaway >= maxDepth) {\n      fail(\n        \"Maximum SQL expansion limit (maxDepth=\", maxDepth, \") exceeded: \",\n        expanded.join(' -> ', )\n      )\n    }\n  }\n  return sql;\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Queries.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 719,
    "kind": "function",
    "name": "isQuery",
    "memberof": "src/Utils/Queries.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Queries.js~isQuery",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{isQuery}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 720,
    "kind": "function",
    "name": "expandFragments",
    "memberof": "src/Utils/Queries.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Queries.js~expandFragments",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{expandFragments}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "queryable",
        "types": [
          "*"
        ]
      },
      {
        "name": "maxDepth",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 16,
        "defaultValue": "16"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 721,
    "kind": "file",
    "name": "src/Utils/Relation.js",
    "content": "import { fail, hasValue, isString, noValue, remove } from \"@abw/badger-utils\";\n\nconst relationStringRegex = /^(\\w+)\\s*([-~=#]>)\\s*(\\w+)\\.(\\w+)$/;\nconst relationType = {\n  '~>': 'any',\n  '->': 'one',\n  '=>': 'many',\n  '#>': 'map',\n};\nconst relationAliases = {\n  localKey:   'from',\n  local_key:  'from',\n  remoteKey:  'to',\n  remote_key: 'to',\n  orderBy:    'order',\n  order_by:   'order',\n};\n\n/**\n * Function to prepare a relation definition.\n * @param {!String} table - the table name\n * @param {!String} name - the relation name\n * @param {!String|Object} config - the relation configuration\n * @return {Object} a relation specification object\n * @example\n * const relation = relationConfig(\n *   'artists', 'albums', 'id => albums.artist_id'\n * })\n * @example\n * const relation = relationConfig(\n *   'artists', 'albums',\n *   {\n *     from:  'id',\n *     type:  'many',\n *     table: 'albums',\n *     to:    'artist_id'\n *    }\n * )\n */\nexport const relationConfig = (table, name, config) => {\n  if (isString(config)) {\n    config = parseRelationString(config);\n  }\n  else if (isString(config.relation)) {\n    config = {\n      ...parseRelationString(config.relation),\n      ...config\n    }\n  }\n\n  // fix up any aliases\n  Object.entries(relationAliases).map(\n    ([key, value]) => {\n      if (hasValue(config[key])) {\n        config[value] ||= remove(config, key);\n      }\n    }\n  );\n\n  // check for missing parameters\n  if (! config.load) {\n    ['type', 'table', 'to', 'from'].forEach(\n      key => {\n        if (noValue(config[key])) {\n          fail(`Missing \"${key}\" in ${name} relation for ${table} table`);\n        }\n      }\n    );\n  }\n\n  // set the name\n  config.name = `${table}.${name}`;\n\n  return config;\n}\n\n/**\n * Function to parse a relation definition string\n * @param {!String} string - the relation definition string\n * @return {Object} a relation specification object\n * @example\n * const relation = parseRelationString(\n *   'id => albums.artist_id'\n * })\n */\nexport const parseRelationString = string => {\n  let match;\n  return ((match = string.match(relationStringRegex)))\n    ? {\n        from:  match[1],\n        type:  relationType[match[2]] || fail('Invalid type \"', match[2], '\" specified in relation: ', string),\n        table: match[3],\n        to:    match[4],\n      }\n    : fail(\"Invalid relation string specified: \", string);\n}\n\nexport const whereRelation = (record, spec) => {\n  const lkey  = spec.from;\n  const rkey  = spec.to;\n  let where   = spec.where || { };\n  if (lkey && rkey) {\n    where[rkey] = record.row[lkey];\n  }\n  return where\n}\n",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Relation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 722,
    "kind": "variable",
    "name": "relationStringRegex",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationStringRegex",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 723,
    "kind": "variable",
    "name": "relationType",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationType",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "{\"~>\": string, \"->\": string, \"=>\": string, \"#>\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 724,
    "kind": "variable",
    "name": "relationAliases",
    "memberof": "src/Utils/Relation.js",
    "static": true,
    "longname": "src/Utils/Relation.js~relationAliases",
    "access": "public",
    "export": false,
    "importPath": "@abw/badger-database",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "{\"localKey\": string, \"local_key\": string, \"remoteKey\": string, \"remote_key\": string, \"orderBy\": string, \"order_by\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 725,
    "kind": "function",
    "name": "relationConfig",
    "memberof": "src/Utils/Relation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Relation.js~relationConfig",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{relationConfig}",
    "description": "Function to prepare a relation definition.",
    "examples": [
      "const relation = relationConfig(\n  'artists', 'albums', 'id => albums.artist_id'\n})",
      "const relation = relationConfig(\n  'artists', 'albums',\n  {\n    from:  'id',\n    type:  'many',\n    table: 'albums',\n    to:    'artist_id'\n   }\n)"
    ],
    "lineNumber": 40,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "table",
        "description": "the table name"
      },
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the relation name"
      },
      {
        "nullable": false,
        "types": [
          "String",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "the relation configuration"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a relation specification object"
    }
  },
  {
    "__docId__": 726,
    "kind": "function",
    "name": "parseRelationString",
    "memberof": "src/Utils/Relation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Relation.js~parseRelationString",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{parseRelationString}",
    "description": "Function to parse a relation definition string",
    "examples": [
      "const relation = parseRelationString(\n  'id => albums.artist_id'\n})"
    ],
    "lineNumber": 86,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "the relation definition string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "a relation specification object"
    }
  },
  {
    "__docId__": 727,
    "kind": "function",
    "name": "whereRelation",
    "memberof": "src/Utils/Relation.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Relation.js~whereRelation",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{whereRelation}",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "record",
        "types": [
          "*"
        ]
      },
      {
        "name": "spec",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 728,
    "kind": "file",
    "name": "src/Utils/Space.js",
    "content": "import { blank, lparen, rparen, space } from \"../Constants.js\";\n\nexport const spaceAfter = string =>\n  (string && string.length)\n    ? string + space\n    : blank\n\nexport const spaceBefore = string =>\n  (string && string.length)\n    ? space + string\n    : blank\n\nexport const spaceAround = string =>\n  (string && string.length)\n    ? space + string + space\n    : blank\n\nexport const parens = string =>\n  (string && string.length)\n    ? lparen + string + rparen\n    : blank",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Space.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 729,
    "kind": "function",
    "name": "spaceAfter",
    "memberof": "src/Utils/Space.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Space.js~spaceAfter",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{spaceAfter}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 730,
    "kind": "function",
    "name": "spaceBefore",
    "memberof": "src/Utils/Space.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Space.js~spaceBefore",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{spaceBefore}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 731,
    "kind": "function",
    "name": "spaceAround",
    "memberof": "src/Utils/Space.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Space.js~spaceAround",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{spaceAround}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 732,
    "kind": "function",
    "name": "parens",
    "memberof": "src/Utils/Space.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Space.js~parens",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{parens}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 733,
    "kind": "file",
    "name": "src/Utils/Tags.js",
    "content": "export const sql = sql => ({ sql })",
    "static": true,
    "longname": "/Users/abw/js/badger-database-js/src/Utils/Tags.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 734,
    "kind": "function",
    "name": "sql",
    "memberof": "src/Utils/Tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Utils/Tags.js~sql",
    "access": "public",
    "export": true,
    "importPath": "@abw/badger-database",
    "importStyle": "{sql}",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# Badger Database\n\nThe is the documentation site for the `@abw/badger-database` Javascript library.\n\nIt is a simple but powerful database management tool that allows you to\nbuild database abstraction layers for your Javascript projects. It has\nsupport for accessing Postgres, MySQL and Sqlite databases.\n\nRead the [manual](manual) for a step-by-step look at the functionality provided.\n\nConsult the [API documentation](identifiers) for details of the various classes,\nmethods and other functions provided.\n\n",
    "longname": "/Users/abw/js/badger-database-js/docs/index.md",
    "name": "./docs/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@abw/badger-database\",\n  \"version\": \"1.1.27\",\n  \"description\": \"Javascript database abstraction layer\",\n  \"type\": \"module\",\n  \"main\": \"dist/badger-database.cjs.js\",\n  \"module\": \"dist/badger-database.esm.js\",\n  \"exports\": \"./dist/badger-database.esm.js\",\n  \"author\": \"Andy Wardley\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/abw/badger-database-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/abw/badger-database-js/issues\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup -c\",\n    \"dev\": \"rollup -c -w\",\n    \"lint\": \"eslint 'src/**/*'\",\n    \"docs:build\": \"esdoc\",\n    \"docs:serve\": \"serve docs\",\n    \"test\": \"ava --serial\",\n    \"pretest\": \"pnpm run build\"\n  },\n  \"keywords\": [\n    \"badger\",\n    \"database\",\n    \"sql\"\n  ],\n  \"devDependencies\": {\n    \"@itsjamie/esdoc-cli\": \"^0.5.0\",\n    \"@itsjamie/esdoc-core\": \"^0.5.0\",\n    \"@itsjamie/esdoc-importpath-plugin\": \"^0.5.0\",\n    \"@itsjamie/esdoc-inject-style-plugin\": \"^0.5.0\",\n    \"@itsjamie/esdoc-standard-plugin\": \"^0.5.0\",\n    \"@rollup/plugin-commonjs\": \"^11.1.0\",\n    \"@rollup/plugin-json\": \"^4.1.0\",\n    \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n    \"ava\": \"^4.3.3\",\n    \"better-sqlite3\": \"^7.6.2\",\n    \"dotenv\": \"^16.0.3\",\n    \"eslint\": \"^8.33.0\",\n    \"mysql2\": \"^3.1.1\",\n    \"pg\": \"^8.9.0\",\n    \"rollup\": \"^2.79.1\",\n    \"rollup-plugin-sourcemaps\": \"^0.6.3\",\n    \"rollup-plugin-terser\": \"^7.0.2\",\n    \"source-map-support\": \"^0.5.21\",\n    \"sqlite3\": \"^5.1.4\"\n  },\n  \"dependencies\": {\n    \"@abw/badger\": \"^1.0.10\",\n    \"@abw/badger-utils\": \"^1.0.16\",\n    \"proxymise\": \"^1.0.2\",\n    \"tarn\": \"^3.0.2\"\n  }\n}\n",
    "longname": "/Users/abw/js/badger-database-js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "content": "# badger-database\n\n<img src=\"./images/badger2.svg\" width=\"300\"/>\n\nThis is the manual for the `badger-database` Javascript module.\n\n## Table of Contents\n\n* [Installation](manual/installation.html) - installing the library\n* [Connecting](manual/connecting.html) - connecting to a database\n* [Basic Queries](manual/basic_queries.html) - performing basic SQL queries\n* [Named Queries](manual/named_queries.html) - defining named SQL queries for abstraction and reusability\n* [Query Fragments](manual/query_fragments.html) - defining named SQL fragments for embedding into queries\n* [Query Builder](manual/query_builder.html) - building SQL queries programmatically\n* [Query Builder Methods](manual/builder_method.html) - methods for building SQL queries\n* [Tables](manual/tables.html) - using tables to automatically generate basic queries\n* [Table Columns](manual/table_columns.html) - defining table columns\n* [Table Methods](manual/table_methods.html) - calling table methods\n* [Table Queries](manual/table_queries.html) - defining named queries for tables\n* [Table Class](manual/table_class.html) - defining custom table classes\n* [Records](manual/records.html) - using records\n* [Record Methods](manual/record_methods.html) - calling record methods\n* [Record Class](manual/record_class.html) - defining custom record classes\n* [Relations](manual/relations.html) - defining relations between tables\n* [Transactions](manual/transactions.html) - using database transactions\n* [Model](manual/model.html) - accessing database tables in a simpler form\n* [Waiter](manual/waiter.html) - chaining together asynchronous operations\n* [Debugging](manual/debugging.html) - enabling debugging messages\n* [Implementation](manual/implementation.html) - understanding how the library is implemented\n* [Extending](manual/extending.html) - extending badger-database to add your own functionality\n* [Limitations](manual/limitations.html) - coping with the limitations of badger-database\n* [Examples](manual/examples.html) - working examples using badger-database\n\n## Method Reference\n\nThis is a brief summary of the object methods available.\n\n### Database Methods\n\n| Method | Description\n|-|-|\n| [connect(options)](manual/connecting.html) | Connect to the database and return a `Database` object|\n| [disconnect()](manual/connecting.html#disconnecting) | Disconnect from the database |\n| [run(query, values, options)](manual/basic_queries.html#run-query--values--options-) | Run a raw SQL query or named query |\n| [one(query, values, options)](manual/basic_queries.html#one-query--values--options-) | Run a raw SQL query or named query to fetch exactly one row |\n| [any(query, values, options)](manual/basic_queries.html#any-query--values--options-) | Run a raw SQL query or named query to fetch any single row |\n| [all(query, values, options)](manual/basic_queries.html#all-query--values--options-) | Run a raw SQL query or named query to fetch all rows |\n| [build](manual/query_builder.html) | Start a query builder chain |\n| [select(columns)](manual/query_builder.html#select-queries) | Start a `SELECT` query builder chain with a column selection |\n| [insert(columns)](manual/query_builder.html#insert-queries) | Start an `INSERT` query builder chain with a column selection |\n| [update(table)](manual/query_builder.html#update-queries) | Start an `UPDATE` query builder chain with a table name |\n| [delete(columns)](manual/query_builder.html#delete-queries) | Start an `DELETE` query builder chain with optional column specification |\n| [transaction(code)](manual/transactions.html) | Execute queries in the scope of a transaction |\n| [table(name)](manual/tables.html) | Lookup a named table and return a `Table` object|\n\n### Table Query Methods\n\n| Method | Description\n|-|-|\n| [run(query, values, options)](manual/table_queries.html#run-query--values--options-) | Run a raw SQL query or named query |\n| [one(query, values, options)](manual/table_queries.html#one-query--values--options-) | Run a raw SQL query or named query to fetch exactly one row |\n| [any(query, values, options)](manual/table_queries.html#any-query--values--options-) | Run a raw SQL query or named query to fetch any single row |\n| [all(query, values, options)](manual/table_queries.html#all-query--values--options-) | Run a raw SQL query or named query to fetch all rows |\n\n### Table Insert Methods\n\n| Method | Description\n|-|-|\n| [insert(data, options)](manual/table_methods.html#insert-data--options-) | Insert one or more rows of data |\n| [insertOne(data, options)](manual/table_methods.html#insertone-data--options-) | Insert a single row of data |\n| [insertAll(array, options)](manual/table_methods.html#insertall-array--options-) | Insert multiple rows of data |\n| [insertOneRow(data, options)](manual/table_methods.html#insertonerow-data--options-) | Insert a single row of data and return the reloaded row|\n| [insertAllRows(array, options)](manual/table_methods.html#insertallrows-array--options-) | Insert multiple rows of data and return an array of reloaded rows|\n| [insertRow(data, options)](manual/table_methods.html#insertonerow-data--options-) | Alias for [insertOneRow()](manual/table_methods.html#insertonerow-data--options-) |\n| [insertRows(array, options)](manual/table_methods.html#insertallrows-array--options-) | Alias for [insertAllRows()](manual/table_methods.html#insertallrows-array--options-) |\n| [insertOneRecord(data, options)](manual/table_methods.html#insertonerecord-data--options-) | Insert a single row of data and return a record |\n| [insertAllRecords(array, options)](manual/table_methods.html#insertallrecords-array--options-) | Insert multiple rows of data and return an array of records |\n| [insertRecord(data, options)](manual/table_methods.html#insertonerecord-data--options-) | Alias for [insertOneRecord()](manual/table_methods.html#insertonerecord-data--options-) |\n| [insertRecords(array, options)](manual/table_methods.html#insertallrecords-array--options-) | Alias for [insertAllRecords()](manual/table_methods.html#insertallrecords-array--options-) |\n\n### Table Update Methods\n\n| Method | Description\n|-|-|\n| [update(set, where, options)](manual/table_methods.html#update-set--where--options-) | Update one or more rows to set new values where matching criteria |\n| [updateOne(set, where, options)](manual/table_methods.html#updateone-set--where--options-) | Update exactly one row to set new values where matching criteria |\n| [updateAny(set, where, options)](manual/table_methods.html#updateany-set--where--options-) | Update any row to set new values where matching criteria |\n| [updateAll(set, where, options)](manual/table_methods.html#updateall-set--where--options-) | Update all rows to set new values where matching criteria |\n| [updateOneRow(set, where, options)](manual/table_methods.html#updateonerow-set--where--options-) | Update exactly one row with reload option to return updated row |\n| [updateAnyRow(set, where, options)](manual/table_methods.html#updateanyrow-set--where--options-) | Update any row with reload option to return updated row |\n| [updateRow(set, where, options)](manual/table_methods.html#updateonerow-set--where--options-) | Alias for [updateOneRow()](manual/table_methods.html#updateonerow-set--where--options-) |\n\n### Table Delete Method\n\n| Method | Description\n|-|-|\n| [delete(where)](manual/table_methods.html#delete-where-) | Delete all rows where matching criteria |\n\n### Table Fetch Methods\n\n| Method | Description\n|-|-|\n| [fetch(where, options)](manual/table_methods.html#fetch-where--options-) | Fetch rows where matching criteria |\n| [fetchOne(where, options)](manual/table_methods.html#fetchone-where--options-) | Fetch exactly one row where matching criteria |\n| [fetchAny(where, options)](manual/table_methods.html#fetchany-where--options-) | Fetch any row where matching criteria |\n| [fetchAll(where, options)](manual/table_methods.html#fetchall-where--options-) | Fetch all rows where matching criteria |\n| [fetchOneRecord(where, options)](manual/table_methods.html#fetchonerecord-where--options-) | Fetch exactly one row where matching criteria and return as a record|\n| [fetchAnyRecord(where, options)](manual/table_methods#fetchanyrecord-where--options-) | Fetch any row where matching criteria and return as a record|\n| [fetchAllRecords(where, options)](manual/table_methods#fetchallrecords-where--options-) | Fetch all rows where matching criteria and return as a record|\n| [fetchRecord(where, options)](manual/table_methods#fetchonerecord-where--options-) | Alias for [fetchOneRecord()](manual/table_methods#fetchonerecord-where--options-) |\n| [fetchRecords(where, options)](manual/table_methods#fetchallrecords-where--options-) | Alias for [fetchAllRecords()](manual/table_methods#fetchallrecords-where--options-) |\n| [oneRow(query, args)](manual/table_queries.html#onerow-query--args-) | Select exactly one row using [fetchOne()](manual/table_methods.html#fetchone-where--options-) or [one()](manual/table_queries.html#one-query--values--options-) as appropriate|\n| [anyRow(query, args)](manual/table_queries.html#anyrow-query--args-) | Select any single row using [fetchAny()](manual/table_methods.html#fetchany-where--options-) or [any()](manual/table_queries.html#any-query--values--options-) as appropriate|\n| [allRows(query, args)](manual/table_queries.html#allrows-query--args-) | Select all rows using [fetchAll()](manual/table_methods.html#fetchall-where--options-) or [all()](manual/table_queries.html#all-query--values--options-) as appropriate|\n| [oneRecord(query, args)](manual/table_queries.html#onerecord-query--args-) | Select exactly one row using [fetchOne()](manual/table_methods.html#fetchone-where--options-) or [one()](manual/table_queries.html#one-query--values--options-) as appropriate and return as a record|\n| [anyRecord(query, args)](manual/table_queries.html#anyrecord-query--args-) | Select any single row using [fetchAny()](manual/table_methods.html#fetchany-where--options-) or [any()](manual/table_queries.html#any-query--values--options-) as appropriate and return as a record|\n| [allRecords(query, args)](manual/table_queries.html#allrecords-query--args-) | Select all rows using [fetchAll()](manual/table_methods.html#fetchall-where--options-) or [all()](manual/table_queries.html#all-query--values--options-) as appropriate and return as a record|\n\n### Other Table Methods\n\n| Method | Description\n|-|-|\n| [build](manual/table_queries.html#query-builder) | Start a query builder chain |\n| [select(columns)](manual/table_queries.html#query-builder) | Start a query builder chain with column selection and table pre-defined|\n| [record(row)](manual/table_methods.html#record-row-) | Convert a row to a record object |\n| [records(rows)](manual/table_methods.html#records-rows-) | Convert an array of rows to an array of record objects |\n\n### Record Methods\n| Method | Description\n|-|-|\n| [update(set)](manual/record_methods.html#update-set-) | Update the record to set new values |\n| [delete()](manual/record_methods.html#delete--)| Delete the corresponding row from the database |\n| [relation(name)](manual/record_methods.html#relation-name-) | Fetch record or records from a named relation |\n\n\n## Implementation Details\n\nThe library is implemented using ES6 modules.  A bundle for CJS is also provided.\n\nAll asynchronous functions and methods return promises.\n\n## Notes on Case Conventions\n\nThe Javascript convention is to use StudlyCaps for class names (e.g. `Artists`) and\ncamelCase for methods, function, variables, etc., (e.g. `albumTracks`).\n\nWhen it comes to database table and columns names you might want to adopt the same\nconvention.  That's fine.  However, be warned that many databases are case insensitive\nby default.  As a result you might find that the database you're using returns the\ndata with column names converted to lower case.  Most databases have an option to make\nit case sensitive so you might want to look into that.\n\nI prefer to avoid the problem altogether by defining my database tables and columns using\nsnake_case (e.g. `artists`, `artist_id`, `album_tracks`, etc). I typically use a number\nof other programming languages to access the same database in a project and many other\nlanguages (e.g. Rust, Perl, Python, PHP, etc.) use snake_case by convention.\n\nIn these examples I've adopted this convention because it's what works for me.  It doesn't\nbother me that I have to think in snake_case when I'm accessing row data, but camelCase\nwhen using method names.  In fact, I think it probably helps me to differentiate between\n\"raw\" data from the database and code.  You may disagree, and of course, you are free to\nadopt your own convention that does it differently.\n\n# Author\n\n[Andy Wardley](https://github.com/abw)\n",
    "longname": "/Users/abw/js/badger-database-js/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\nUse your favourite package manager to install the module\nfrom `@abw/badger-database`.  You should also install\nat least one of the database driver modules:\n\n* `pg` for Postgres\n* `mysql2` for Mysql or MariaDB\n* `better-sqlite3` for Sqlite.\n\n### npm\n\n    // postgres\n    npm install @abw/badger-database pg\n    // mysql\n    npm install @abw/badger-database mysql2\n    // sqlite\n    npm install @abw/badger-database better-sqlite3\n\n### pnpm\n\n    // postgres\n    pnpm add @abw/badger-database pg\n    // mysql\n    pnpm add @abw/badger-database mysql2\n    // sqlite\n    pnpm add @abw/badger-database better-sqlite\n\n### yarn\n\n    // postgres\n    yarn add @abw/badger-database pg\n    // mysql\n    yarn add @abw/badger-database mysql\n    // sqlite\n    yarn add @abw/badger-database better-sqlite\n\n## Where Next?\n\nOnce you've got it installed you're ready to [connect](manual/connecting.html)\nto a database.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/connecting.md",
    "name": "./manual/connecting.md",
    "content": "# Connecting\n\nThe `connect()` function is used to connect to a database.  It is the default\nexport from the `@abw/badger-database` module.\n\n```js\nimport connect from '@abw/badger-database'\n```\n\nYou can also use named imports.\n\n```js\nimport { connect } from '@abw/badger-database'\n```\n\nOr you can use `require()` if you're still using Common JS format.\n\n```js\nconst { connect } = require('@abw/badger-database')\n```\n\n## Connection String\n\nThe simplest way to connect to a database is using a connection string for the\n`database` parameter. This is a concept that should be familiar to Postgres users.\n\n```js\nconst db = connect({\n  database: 'postgresql://user:password@hostname:5432/database'\n})\n```\n\nInternally we use the slightly shorter name of `postgres` (no `ql` at the end)\nfor the Postgres engine name.  To avoid any chance of confusion, we also support\nthis in the connection string and automatically \"correct\" it for you.\n\n```js\nconst db = connect({\n  // 'postgres://...' works the same as 'postgresql://...'\n  database: 'postgres://user:password@hostname:5432/database'\n})\n```\n\nYou can use the same connection string format for Mysql databases:\n\n```js\nconst db = connect({\n  database: 'mysql://user:password@hostname:3306/database'\n})\n```\n\nMariaDB is a drop-in replacement for MySQL so you can use the exact\nsame `mysql` connection string for a MariaDB database.  You can use\nthe `maria` or `mariadb` prefix if you prefer as they're defined as\naliases for `mysql`.\n\n```js\nconst db = connect({\n  database: 'mariadb://user:password@hostname:3306/database'\n})\n```\n\nThe same connection string is also supported for Sqlite databases,\nalthough here the only parameter supported is the database filename.\n\n```js\nconst db = connect({\n  database: 'sqlite://database'\n})\n```\n\nFor an in-memory Sqlite database, use `:memory:` as the database name:\n\n```js\nconst db = connect({\n  database: 'sqlite://:memory:'\n})\n```\n\nOr if you find that a bit clunky, you can use the shortened version:\n\n```js\nconst db = connect({\n  database: 'sqlite:memory'\n})\n```\n\nMost of the elements are optional for Postgres and Mysql databases.\nHere are the minimal versions which assume the default host (`localhost`),\nport (`3306` for Mysql and `5432` for Postgres) and no username or password.\n\n```js\nconst db = connect({\n  database: 'postgresql://database'\n})\n```\n\n```js\nconst db = connect({\n  database: 'mysql://database'\n})\n```\n\nIf there are any additional configuration options that you want to pass to the\nunderlying database engine module (`better-sqlite3`, `mysql2/promise` or `pg`)\nthen you can provide them as `engineOptions`.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  engineOptions: {\n    verbose: console.log\n  }\n})\n```\n\n```js\nconst db = connect({\n  database: 'mysql://database',\n  engineOptions: {\n    dateStrings: true\n  }\n})\n```\n\n```js\nconst db = connect({\n  database: 'postgres://database',\n  engineOptions: {\n    queryTimeout: 3000\n  }\n})\n```\n\n## Connection Parameters\n\nThe connection strings shown in the previous sections are short-hand versions\nfor the more verbose form.  If your connection parameters are stored in a file,\nloaded via an API call, or fetched in some other way then it may be more\nconvenient to use this form.\n\n```js\nconst db = connect({\n  // \"postgres://badger:s3cr3t@dbhost.com:5433/animals\" is short for:\n  database: {\n    engine:   'postgres',   // or 'postgresql'\n    user:     'badger',\n    password: 's3cr3t',\n    host:     'dbhost.com',\n    port:     '5433',\n    database: 'animals',\n  }\n})\n```\n\nThe same configuration options apply to Mysql.  The only difference is that\nyou should use `mysql` (or `mariadb`) as the engine name.\n\n```js\nconst db = connect({\n  // \"mysql://badger:s3cr3t@dbhost.com:5433/animals\" is short for:\n  database: {\n    engine:   'mysql',   // or 'maria' / 'mariadb'\n    user:     'badger',\n    password: 's3cr3t',\n    host:     'dbhost.com',\n    port:     '5433',\n    database: 'animals',\n  }\n})\n```\n\nFor Sqlite the only supported option is `filename`.\n\n```js\nconst db = connect({\n  database: {\n    engine:   'sqlite',\n    filename: 'animals.db',\n  }\n})\n```\n\nYou can also use `:memory:` as the `filename` for an in-memory database.\n\n```js\nconst db = connect({\n  database: {\n    engine:   'sqlite',\n    filename: ':memory:',\n  }\n})\n```\n\nWhen using this expanded format, any additional configuration options for the engine\nmodule can be included directly in the `database` specification.\n\n```js\nconst db = connect({\n  database: {\n    engine:   'sqlite',\n    filename: ':memory:',\n    verbose:  console.log\n  }\n})\n```\n\n```js\nconst db = connect({\n  database: {\n    engine:      'mysql',\n    database:    'animals',\n    dateStrings: true\n  }\n})\n```\n\n```js\nconst db = connect({\n  database: {\n    engine:       'postgres',\n    database:     'animals',\n    queryTimeout: 3000\n  }\n})\n```\n\n## Connection Parameter Aliases\n\nWhenever I'm writing the code to connect to a database there's a good chance I'll get\nat least one of the parameter names wrong.  Is it `user` or `username`? `pass` or\n`password`? `host` or `hostname`? `file` or `filename`?  I can never remember.\n\nTo save you from having to google it you can specify any of the \"incorrect\" parameters\nand they will be automatically corrected.\n\nFor example, if you specify `file` instead of `filename` for a Sqlite database, we'll\nsilently correct it.\n\n```js\nconst db = connect({\n  database: {\n    engine: 'sqlite',\n    file:   'animals.db',   // converted to 'filename'\n  }\n})\n```\n\nThis also just works:\n\n```js\nconst db = connect({\n  database: {\n    engine:   'postgres',\n    database: 'animals',\n    user:     'badger',\n    pass:     's3cr3t',     // converted to 'password'\n    host:     'dbhost.com',\n    port:     '5433',\n  }\n})\n```\n\nAnd this works too:\n\n```js\nconst db = connect({\n  database: {\n    engine:   'postgres',\n    database: 'animals',\n    username: 'badger',     // converted to 'user'\n    password: 's3cr3t',\n    hostname: 'dbhost.com', // converted to 'host'\n    port:     '5433',\n  }\n})\n```\n\nYou can also use `name` as an alias for `database`:\n\n```js\nconst db = connect({\n  database: {\n    engine:   'postgres',\n    name:     'animals',\n  }\n})\n```\n\n## Environment Variables\n\nYou can configure the database using environment variables.\nA database connection string should be defined as the `DATABASE`\nenvironment variable.\n\nFor example, you could define `DATABASE` in a `.env` file:\n\n```bash\nDATABASE=sqlite:memory\n```\n\nYou can load the environment variables from the `.env` file\nusing [dotenv](https://www.npmjs.com/package/dotenv) or a similar\nmodule. The environment variables will then be defined in `process.env`.\nPass these to the `connect` function as `env`.\n\n```js\nimport dotenv from 'dotenv'\nimport process from 'node:process'\nimport connect from '@abw/badger-database'\n\n// load the .env file\ndotenv.config();\n\nconst db = connect({\n  env: process.env\n});\n```\n\nYou can also define different database parameters using the `DATABASE_`\nprefix.  For example, for a Sqlite in-memory database:\n\n```bash\nDATABASE_ENGINE=sqlite\nDATABASE_FILENAME=:memory:\n```\n\nOr for a Mysql database:\n\n```bash\nDATABASE_ENGINE=mysql\nDATABASE_NAME=animals\nDATABASE_USER=badger\nDATABASE_PASSWORD=s3cr3t\n```\n\nIf you want to use a different environment variable name or prefix, then\ndefine it using the `envPrefix` option.\n\n```js\nconst db = connect({\n  env: process.env\n  envPrefix: 'MY_DB'\n});\n```\n\nThen you can define the database connection string like so:\n\n```\nMY_DB=sqlite:memory\n```\n\nOr using separate environment variables like this:\n\n```bash\nMY_DB_ENGINE=mysql\nMY_DB_NAME=animals\nMY_DB_USER=badger\nMY_DB_PASSWORD=s3cr3t\n```\n\nWhen using environment variables any additional configuration options for the\ndatabase engine should be provided in the `engineOptions` configuration item.\n\n```js\nconst db = connect({\n  env: process.env\n  envPrefix: 'MY_DB',\n  engineOptions: {\n    verbose: console.log\n  }\n});\n```\n\n## Pool Options\n\nThe Postgres and Mysql database engines use a connection pool for efficiency.\nBy default, the minimum number of connections is 2 and the maximum is 10.  You\ncan change these values using the `pool` option.\n\n```js\nconst db = connect({\n  database: { ... },\n  pool: {\n    min: 5,\n    max: 20\n  }\n})\n```\n\nThe Sqlite engine uses [better-sqlite3](https://github.com/WiseLibs/better-sqlite3)\nwhich uses synchronous functions.  This is because Sqlite serialises all queries\nand there is nothing to gain (and the potential for problems) by using a connection\npool and/or asynchronous function (for further information about this from the author\nof better-sqlite3, see [here](https://github.com/WiseLibs/better-sqlite3/issues/32)).\n\nAs such, the pool is effectively disabled for Sqlite by setting the `min` and `max`\nvalues to 1.\n\n## Disconnecting\n\nWhen you're finished using the database you should call the `disconnect()` method on\nit.\n\n```js\ndb.disconnect()\n```\n\n## Where Next?\n\nOnce you're connected to a database you're ready to run some [basic queries](manual/basic_queries.html).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/basic_queries.md",
    "name": "./manual/basic_queries.md",
    "content": "# Basic Queries\n\nIn these examples we'll look at some of the basic functionality of the\nlibrary using a database of users.\n\nThis first example shows how to connect to a database, create a table,\ninsert a row and then fetch it out again.\n\n```js\nimport connect from '@abw/badger-database'\n\nasync function main() {\n  // connect to a Sqlite database\n  const db = connect({ database: 'sqlite://test.db' });\n\n  // create a table\n  await db.run(\n    `CREATE TABLE users (\n      id    INTEGER PRIMARY KEY ASC,\n      name  TEXT,\n      email TEXT\n    )`\n  );\n\n  // insert a row\n  const insert = await db.run(\n    'INSERT INTO users (name, email) VALUES (?, ?)',\n    ['Bobby Badger', 'bobby@badgerpower.com']\n  );\n  console.log(\"Inserted ID:\", insert.lastInsertRowid);\n\n  // fetch a row\n  const bobby = await db.one(\n    'SELECT * FROM users WHERE email=?',\n    ['bobby@badgerpower.com']\n  );\n  console.log(\"Fetched row:\", bobby);\n\n  // cleanup\n  db.disconnect();\n}\n\nmain()\n```\n\nNote that most of the database functions are asynchronous and return\npromises.  In these examples we've wrapped the code in an `async` function\ncalled `main()` so that we can use the `await` keyword to wait for requests\nto complete. You can, of course, use `.then(...)` if you prefer.\n\n```js\nimport connect from '@abw/badger-database'\n\nconst db = connect({ database: 'sqlite://test.db' });\n\ndb.run(\n  `CREATE TABLE users (\n    id    INTEGER PRIMARY KEY ASC,\n    name  TEXT,\n    email TEXT\n  )`\n).then(\n  () => db.run(\n    'INSERT INTO users (name, email) VALUES (?, ?)',\n    ['Bobby Badger', 'bobby@badgerpower.com']\n  )\n).then(\n  insert => console.log(\"Inserted ID:\", insert.lastInsertRowid)\n).then(\n  () => db.one(\n    'SELECT * FROM users WHERE email=?',\n    ['bobby@badgerpower.com']\n  )\n).then(\n  bobby => console.log(\"Fetched row:\", bobby)\n).then(\n  () => db.disconnect()\n)\n```\n\n## Query Methods\n\n### run(query, values, options)\n\nThe `run()` method is used to execute a query where you're not expecting\nto return any rows from the database.  However, the method does return some\ndata include the number of rows changed, and in the case of `INSERT` queries,\nthe generated id for the record.\n\nDifferent database engines return different values here.  For Sqlite it's\n`changes` for the number of rows affected and `lastInsertRowid` for the id\nof the insert row.  For Mysql it's `affectedRows` and `insertId`.  For\nPostgres it's `rowCount` and if you want to get the id then you must add\n`RETURNING id` to the end of the query.\n\nWe'll see in later examples using `tables` how the badger-database library\nautomatically standardises this response so that you always get back `changes`\nand `id` (or whatever your id column is called) regardless of the database\nengine.  But if you really can't wait until then, the trick is to pass a third\nargument to the `run()` method as an object containing the `sanitizeResult`\nkey set to a `true` value.  Then you will always get back `changes` and `id`\nfor all database engines.\n\n```js\n// insert a row\nconst insert = await db.run(\n  'INSERT INTO users (name, email) VALUES (?, ?)',\n  ['Bobby Badger', 'bobby@badgerpower.com'],\n  { sanitizeResult: true }\n);\nconsole.log(\"Rows changed:\", insert.changes);\nconsole.log(\"Inserted ID:\", insert.id);\n```\n\n### one(query, values, options)\n\nThe `one()` method should be used when you're expecting to fetch *exactly*\none row from the database.  The first argument is an SQL query string.  If\nyou  have any parameters to include in the query then they should be embedded\nin the SQL using placeholders (`?` for Mysql and Sqlite, `$1`, `$2`, `$3`, etc.,\nfor Postgres).  Then pass the parameter values in an array as the second\nargument.\n\n```js\nconst bobby = await db.one(\n  'SELECT * FROM users WHERE email=?',\n  ['bobby@badgerpower.com']\n);\nconsole.log(\"Fetched row:\", bobby);\n```\n\nThe `one()` method will throw an `UnexpectedRowCount` exception if no rows, or\nmore than one row is returned with a message of the form\n`N rows were returned when one was expected`.\n\n### any(query, values, options)\n\nThe `any()` method can be used if you want to get one row which may or may not exist.\n\n```js\nconst bobby = await db.any(\n  'SELECT * FROM users WHERE email=?',\n  ['bobby@badgerpower.com']\n);\nif (bobby) {\n  console.log(\"Fetched row:\", bobby);\n}\nelse {\n  console.log(\"Bobby Badger has gone missing!\");\n}\n```\n\n### all(query, values, options)\n\nThe `all()` method can be used to return multiple rows.\n\n```js\nconst bobbies = await db.all(\n  'SELECT * FROM users WHERE name=?',\n  ['Bobby Badger']\n);\nif (bobbies.length) {\n  console.log(\"Fetched %s users called 'Bobby Badger':\", bobbies.length);\n}\nelse {\n  console.log(\"There aren't any users called 'Bobby Badger'\");\n}\n```\n\n## Where Next?\n\nRead on to find out how to define reusable [named queries](manual/named_queries.html)\nso that you don't have to litter your application code with SQL queries.\n\nIf you prefer to generate SQL queries programmatically then the\n[query builder](manual/query_builder.html) might also be of interest.\n\n\n\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/named_queries.md",
    "name": "./manual/named_queries.md",
    "content": "# Named Queries\n\nInstead of embedding SQL queries directly into your code, you can\ndefine them as named queries.  This allows you to hide away some of the\ndetails of the database implemenentation so that your application code\ncan be simpler and clearer.\n\nTo keep things simple, this example has all the code in one file,\nwhich isn't really hiding anything at all.  In practice, you would usually\nmove the database definition into a separate module.\n\n```js\nimport connect from '@abw/badger-database'\n\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  queries: {\n    createUsersTable:`\n      CREATE TABLE users (\n        id INTEGER PRIMARY KEY ASC,\n        name TEXT,\n        email TEXT\n      )`,\n    insertUser:\n      'INSERT INTO users (name, email) VALUES (?, ?)',\n    selectUserByEmail:\n      'SELECT * FROM users WHERE email=?'\n  }\n};\n\nasync function main() {\n  // connect to the database\n  const db = connect(dbConfig);\n\n  // create the users table using a named query\n  await db.run('createUsersTable');\n\n  // insert a row using a named query\n  const insert = await db.run(\n    'insertUser',\n    ['Bobby Badger', 'bobby@badgerpower.com']\n  );\n  console.log(\"Inserted ID:\", insert.lastInsertRowid);\n\n  // fetch a row using a named query\n  const bobby = await db.one(\n    'selectUserByEmail',\n    ['bobby@badgerpower.com']\n  );\n  console.log(\"Fetched row:\", bobby);\n}\n\nmain()\n```\n\n## Where Next?\n\nIn the next section we'll look at how you can define reusable\n[query fragments](manual/query_fragments.html) that can be\nembedded into your named queries.\n\nYou can also define named queries using the\n[query builder](manual/query_builder.html).",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/query_fragments.md",
    "name": "./manual/query_fragments.md",
    "content": "# Query Fragments\n\nYou might want to define a number of different queries for fetching user\nrows using different search terms.  For example, to select a user by\n`email` or `name`.\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  queries: {\n    selectUserByEmail:\n      'SELECT * FROM users WHERE email=?',\n    selectUserByName:\n      'SELECT * FROM users WHERE name=?'\n  }\n};\n```\n\nTo avoid repetition, you can define named SQL `fragments` that can be embedded\ninto other queries.  Named fragments can be embedded into queries inside angle\nbrackets, e.g. `<fragmentName>`.\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  fragments: {\n    selectUser:\n      'SELECT * FROM users'\n  },\n  queries: {\n    selectUserByEmail:\n      '&lt;selectUser&gt; WHERE email=?',\n    selectUserByName:\n      '&lt;selectUser&gt; WHERE name=?'\n  }\n};\n```\n\nFragments can reference other fragments.  This can be useful when you're building\nmore complex queries, as shown in this somewhat contrived example:\n\n```js\nconst dbConfig = {\n  database: 'sqlite://test.db',\n  fragments: {\n    selectUserCompany:\n      'SELECT users.*, companies.* FROM users',\n    joinUserCompany:\n      'JOIN companies on users.company_id=companies.id',\n    selectEmployee:\n      '&lt;selectUserCompany&gt; &lt;joinUserCompany&gt;',\n  },\n  queries: {\n    selectEmployeeByEmail:\n      '&lt;selectEmployee&gt; WHERE email=?',\n    selectEmployeeByName:\n      '&lt;selectEmployee&gt; WHERE name=?'\n  }\n};\n```\n\nYou can also embed fragments into ad-hoc queries passed to the\n`run()`, `one()`, `any()` and `all()` methods.  For example,\ngiven the above configuration you could write a custom query that\nincludes the `selectEmployee` fragment like so:\n\n```js\nconst badgers = await db.all(\n  '&lt;selectEmployee&gt; WHERE companies.name=?',\n  ['Badgers Inc.']\n);\n```\n\nIf you want to see how a query is expanded you can call the `sql()`\nmethod.  This will return the expanded SQL query.\n\n```js\ndb.sql('&lt;selectEmployee&gt; WHERE companies.name=?');\n// -> SELECT users.*, companies.* FROM users\n//    JOIN companies on users.company_id=companies.id\n//    WHERE companies.name=?\n```\n\n## Where Next?\n\nYou can also generate SQL queries using the\n[query builder](manual/query_builder.html).",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/query_builder.md",
    "name": "./manual/query_builder.md",
    "content": "# Query Builder\n\nThis page gives a general introduction to generating and running queries\nusing the SQL Query Builder.\n\n* [Introduction](#introduction)\n* [Getting Started](#getting-started)\n* [Select Queries](#select-queries)\n* [Insert Queries](#insert-queries)\n* [Update Queries](#update-queries)\n* [Delete Queries](#delete-queries)\n* [Embedding Raw SQL](#embedding-raw-sql)\n* [Placeholder Values](#placeholder-values)\n* [Running Queries](#running-queries)\n* [The Importance of Being Idempotent](#the-importance-of-being-idempotent)\n* [Named Queries Using a Query Builder](#named-queries-using-a-query-builder)\n\n## Introduction\n\nThe philosophy of the badger-database library is that ORMs and\nSQL query generators are considered *Mostly Harmful*, especially\nif they're employed as an alternative to using SQL.  But that's\nnot to say that they don't have some benefits.  We like to think\nthat this implementation has some of those best bits and not too\nmany of the not-so-good bits.\n\n* Correctness - table and column names are automatically quoted to\navoid any conflict with reserved words.\n\n* Syntactic sugar - you can specify multiple tables, columns, etc.,\nusing a single string for conciseness. You don't need to worry about\ndefining them as an array, quoting every word or putting commas between\neach item.  As long as there's no ambiguity then we take care of that\nfor you.\n\n* Flexibility - queries can be constructed out of sequence, or you\ncan call the same methods multiple times.  The query builder makes\nsure everything ends up in the right order.  Placeholders are\nautomatically inserted for user-supplied values to prevent SQL injection\nattacks, and in the case of Postgres that uses numbered\nplaceholders (`$1`, `$2`, `$3`, etc), the query builder takes care\nof generating them for you so you don't have to worry about getting\nthem in the wrong order, repeating a number or skipping one.\n\n* Reusability - unlike some query builders we could mention, these\nqueries are idempotent.  That is, they generate the same SQL query\neach time they are run (although they won't necessarily return the\nsame rows from the database if you provide different values for\nplaceholders or your database has been updated in the interim).\nCalling a method on a query builder chain doesn't change any of the\nelements that precede it.  This means that you can create partial\nqueries which you can then use to build multiple different queries\nthat are variations of it.\n\nThe query builder is intended to be used to generate simpler queries\nthat can be automated, or are otherwise tedious to write by hand.\nFor example, the [tables](manual/tables.html) use the query builder\nto automatically generate queries for selecting, inserting, updating\nand deleting records.  In addition, they provide some extra data\nvalidation.  You can mark table columns as `required` and/or `readonly`\nand the method calls will be sanity checked for you.  An error will\nbe thrown if you try to insert or update `readonly` columns, or\ninsert records with missing `required` columns.\n\nIt is possible to use the query builder to generate more complex\nqueries involving multi-table joins, sub-queries, and so on.  However,\nyou should exercise caution when doing so.  Make sure to check the\ngenerated output using the [sql()](manual/builder_methods.html#sql--) method to convince yourself that it's\ngenerating the SQL that you expect.  In the long run you may find it easier\nand more reliable to write complex queries as raw SQL that you can test\n(on a sacrificial copy of your production database, of course) and\nthen define as a [named queries](manual/named_queries.html).\n\nThe query builder has some limitations in that it doesn't support all\nthe SQL elements that you could possibly want to put in a query.\nThis is *probably* deliberate.  We've tried to cover the things that\nyou're likely to need most often, and provide an easy way to embed raw\nSQL for those times when you need something else.  This library does\nnot try to discourage you from using SQL when you need to.  In fact,\nit positively encourages you to do so.\n\nBefore we get into too much detail, let's look at some examples.\n\n## Getting Started\n\nWe'll start off by importing the `connect` and `sql` functions\nand connecting to a database.  The wrapper code would look something\nlike this:\n\n```js\nimport { connect, sql } from '@abw/badger-database'\n\nasync function main() {\n  const db = connect({ database: 'sqlite:memory' });\n\n  // examples go here\n}\n\nmain()\n```\n\nThe database object provides four methods for creating different\nquery types:\n\n* [select()](manual/builder_methods.html#select-columns-)\n* [insert()](manual/builder_methods.html#insert-columns-)\n* [update()](manual/builder_methods.html#update-table-)\n* [delete()](manual/builder_methods.html#delete--)\n\nHere's a [select()](manual/builder_methods.html#select-columns-) query.\n\n```js\nconst row = await db\n  .select('name email')\n  .from('users')\n  .where({ id: 12345 })\n  .one();\n```\n\nHere's an [insert()](manual/builder_methods.html#insert-columns-) query.\n\n```js\nawait db\n  .insert('name email')\n  .into('users')\n  .values('Bobby Badger', 'bobby@badgerpower.com')\n  .run();\n```\n\nHere's an [update()](manual/builder_methods.html#update-table-) query.\n\n```js\nawait db\n  .update('users')\n  .set({ name: 'Roberto Badger' })\n  .where({ email: 'bobby@badgerpower.com' })\n  .run();\n```\n\nAnd here's a [delete()](manual/builder_methods.html#delete--) query.\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where({ email: 'bobby@badgerpower.com' })\n  .run();\n```\n\nWhen you create a query, or part of a query, you can call the\n[sql()](manual/builder_methods.html#sql--) method to see what the\ngenerated SQL looks like.\n\n```js\nconsole.log(\n  db.select('hello').from('world').sql()\n);  // -> SELECT \"hello\" FROM \"world\"\n```\n\nIn these examples we'll omit the `console.log()` and\n[sql()](manual/builder_methods.html#sql--) calls for brevity.\n\n## Select Queries\n\nThe main database object has a\n[select()](manual/builder_methods.html#select-columns-) method which\nallows you to start a query by specifying the columns you want to select.\nYou can then chain further methods onto it, e.g.\n[from()](manual/builder_methods.html#from-table-) to specify one or\nmore tables that you want to select from.\n\n```js\ndb.select('hello').from('world')\n// -> SELECT \"hello\" FROM \"world\"\n```\n\nTable and column names are both automatically quoted to avoid conflict\nwith reserved words.  Even if they're not reserved words *now*, there's\nalways the possibility that they could be in the *future*.  In fact this\nhappened to me on a project where we updated MySQL and discovered that\n`rank` had become a reserved word - we had numerous tables with a `rank`\ncolumn and it took several hours to go through all the various queries\nwe used to quote the column.  Lesson learned.\n\nWhen you pass a string to either of these methods (and many others),\nthe string will be split into individual table or columns names.  These\nwill then be quoted and put back together.\n\n```js\ndb.select('id name').from('users')\n// -> SELECT \"id\", \"name\" FROM \"users\"\n```\n\nYou can put commas between items (with optional trailing whitespace)\nand it works the same, e.g `id,name` and `id, name` are both treated\nthe same as `id name`.\n\n```js\ndb.select('id, name').from('users')\n// -> SELECT \"id\", \"name\" FROM \"users\"\n```\n\nYou can add table names to columns.  Both will be automatically quoted.\n\n```js\ndb.select('users.id users.name').from('users')\n// -> SELECT \"users\".\"id\", \"users\".\"name\" FROM \"users\"\n```\n\nGenerally speaking, it doesn't matter which order you call methods in.\nThe query builder will construct the SQL query in the correct order.\n\n```js\ndb.select('name').where({ id: 12345 }).from('users')\n// -> SELECT \"name\" FROM \"users\" WHERE id = ?\n```\n\nIf you want to start a query with anything other than\n[select()](manual/builder_methods.html#select-columns-),\n[insert()](manual/builder_methods.html#insert-columns-),\n[update()](manual/builder_methods.html#update-table-),  or\n[delete()](manual/builder_methods.html#delete--)\nthen you should prefix it with `.build`.\n\n```js\ndb.build.where('c').from('b').select('a')\n// -> SELECT \"a\" FROM \"b\" WHERE \"c\" = ?\n```\n\nYou can call methods multiple times.\n\n```js\ndb.select('id').select('name').from('users')\n// -> SELECT \"id\", \"name\" FROM \"users\"\n```\n\nYou can also pass multiple arguments to a method.  Each is processed\nin turn as if you had called the method multiple times.  We'll see how\nthis can be useful with more complex parameters.\n\n```js\ndb.select('id', 'name').from('users')\n// -> SELECT \"id\", \"name\" FROM \"users\"\n```\n\nFor example, the\n[select()](manual/builder_methods.html#select-columns-)\nmethod allows you to pass an array of\ntwo elements.  The first is the column name, the second is an alias.\n\n```js\ndb.select(['name', 'user_name']).from('users')\n// -> SELECT \"name\" AS \"user_name\" FROM \"users\"\n```\n\nThe [from()](manual/builder_methods.html#from-table-) method\nsupports the same syntax for creating a table alias.\n\n```js\ndb.select('name').from(['users', 'people'])\n// -> SELECT \"name\" FROM \"users\" AS \"people\"\n```\n\nYou can also pass objects to the methods to provide named parameters.\n\n```js\ndb.select({ column: 'name', as: 'user_name' }).from('users')\n// -> SELECT \"name\" AS \"user_name\" FROM \"users\"\n```\n\nHere's an example showing how you can automatically add the table name to\ncolumns and add a prefix to the returned values.\n\n```js\ndb.select({ table: 'users', columns: 'id name', prefix: 'user_' }).from('users')\n// -> SELECT \"users\".\"id\" AS \"user_id\", \"users\".\"name\" AS \"user_name\" FROM \"users\"\n```\n\nYou can use any of the argument types for a method and you can mix and match them\nin a single call.\n\n```js\ndb.select('id', { table: 'users', columns: 'name email', prefix: 'user_' }).from('users')\n// -> SELECT \"id\", \"users\".\"name\" AS \"user_name\", \"users.email\" as \"user_email\" FROM \"users\"\n```\n\n## Insert Queries\n\nUse the\n[insert()](manual/builder_methods.html#insert-columns-)\nmethod to start an `INSERT` query.  The arguments it expects are the names\nof the columns you're inserting.  You should follow that with the\n[into()](manual/builder_methods.html#into-table-) method to specify the table\nyou're inserting into.  Values for the columns can be provided via the\n[values()](manual/builder_methods.html#values-values-) method, either as\nseparate arguments or an array.\n\n```js\nawait db\n  .insert('name email')\n  .into('users')\n  .values('Bobby Badger', 'bobby@badgerpower.com')\n  .run();\n// -> INSERT INTO \"users\" (\"name\", \"email\")\n//    VALUES (?, ?)\n```\n\nOr you can pass an array of values as the first argument to the\n[run()](manual/builder_methods.html#run-values--options-) method.\nThis is useful when you want to reuse the query to insert multiple rows.\n\n```js\nconst insert = db\n  .insert('name email')\n  .into('users');\n\nawait insert.run(['Bobby Badger', 'bobby@badgerpower.com'])\nawait insert.run(['Brian Badger', 'brian@badgerpower.com'])\nawait insert.run(['Frank Ferret', 'frank@ferretfactory.com'])\n```\n\nThe second argument to the\n[run()](manual/builder_methods.html#run-values--options-) method can be\nan object containing options.  The `sanitizeResult` option is useful if\nyou want to inspect the result of the insert operation.\n\n```js\nconst result = await insert.run(\n  ['Bobby Badger', 'bobby@badgerpower.com'],\n  { sanitizeResult: true }\n);\nconsole.log(\"Changes:\", result.changes)\nconsole.log(\"Inserted ID:\", result.id)\n```\n\nIf you're using Postgres then you should use the\n[returning()](manual/builder_methods.html#returning-columns-) method\nto add a `RETURNING` clause on the end of the query to get the\ninserted ID returned.\n\n```js\nconst insert = await db\n  .insert('name email')\n  .into('users')\n  .returning('id')\n```\n\n## Update Queries\n\nUse the\n[update()](manual/builder_methods.html#update-table-) method to start an\n`UPDATE` query.  The argument it expects is the name of the table that you're\nupdating.  You should follow that with the\n[set()](manual/builder_methods.html#set-values-) method to specify the changes\nyou want to make, and optionally, a\n[where()](manual/builder_methods.html#where-criteria-) clause to define which\nrows you want to change.\n\nThe [set()](manual/builder_methods.html#set-values-) and\n[where()](manual/builder_methods.html#where-criteria-) methods can be passed a list\nof column names with the values being provided to the\n[run()](manual/builder_methods.html#run-values--options-) method:\n\n```js\nawait db\n  .update('users')\n  .set('name')\n  .where('email')\n  .run(['Robert Badger', 'bobby@badgerpower.com']);\n// -> UPDATE \"users\"\n//    SET name = ?\n//    WHERE email = ?\n```\n\nOr you can provide values directly to the\n[set()](manual/builder_methods.html#set-values-) and/or\n[where()](manual/builder_methods.html#where-criteria-) methods.  In both\ncases placeholders are used for the values so the SQL generated is identical.\n\n```js\nawait db\n  .update('users')\n  .set({ name: 'Robert Badger' })\n  .where({ email: 'bobby@badgerpower.com' })\n  .run();\n// -> UPDATE \"users\"\n//    SET name = ?\n//    WHERE email = ?\n```\n\n## Delete Queries\n\nUse the [delete()](manual/builder_methods.html#delete--) method to start a\n`DELETE` query.  It usually doesn't take any arguments but should be followed\nwith a [from()](manual/builder_methods.html#from-table-) call to set the\nname of the table that you're deleting from, and optionally, a\n[where()](manual/builder_methods.html#where-criteria-)\nclause to define which rows you want to delete.\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where({ email: 'bobby@badgerpower.com' })\n  .run()\n// -> DELETE FROM \"users\"\n//    WHERE \"email\" = ?\n```\n\nThis also allows you to define parameter values in the\n[where()](manual/builder_methods.html#where-criteria-) method, as\nshown above, or specify columns names in the\n[where()](manual/builder_methods.html#where-criteria-) method and pass all\nvalues as an array to the [run()](manual/builder_methods.html#run-values--options-)\nmethod.\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where('email')\n  .run(['bobby@badgerpower.com'])\n// -> DELETE FROM \"users\"\n//    WHERE \"email\" = ?\n```\n\n## Embedding Raw SQL\n\nThe query builder tries to hit the sweet spot by allowing you to generate\n*most* of the simpler queries you might need.  But it doesn't supporting\neverything that SQL has to offer because that would greatly increase the\ncomplexity and make it harder to reason about.\n\nAs a fallback plan, every method allows you to provide it with raw SQL.\nYou can pass an object with a single `sql` property:\n\n```js\ndb.select({ sql: 'COUNT(user.id) AS n_users' }).from('users')\n// -> SELECT COUNT(user.id) AS n_users FROM \"users\"\n```\n\nOr you can use the `sql` function to generate a tagged template literal.\n\n```js\ndb.select(sql`COUNT(user.id) AS n_users`).from('users')\n// -> SELECT COUNT(user.id) AS n_users FROM \"users\"\n```\n\nThe benefit here is that you can use SQL for some parts of a query when you\nneed it, but still rely on the convenience of automatic generation for\nother parts that don't.\n\n## Placeholder Values\n\nThe [where()](manual/builder_methods.html#where-criteria-) method is used to specify\nselection criteria.  Any user supplied values are embedded into the query using\nplaceholders.\n\nThe SQL query generated will use placeholders for any\n[where()](manual/builder_methods.html#where-criteria-) clauses included.\n\nFor example, this query:\n\n```js\ndb.select('id name')\n  .from('users')\n  .where('id')\n```\n\nWill generate a SQL query that looks like this:\n\n```sql\nSELECT \"id\", \"name\"\nFROM \"users\"\nWHERE \"id\"=?\n```\n\nYou can also define values in the [where()](manual/builder_methods.html#where-criteria-)\nclause.\n\n```js\nconst row = db\n  .select('id name')\n  .from('users')\n  .where({ id: 12345 })\n  .one();     // automatically uses placeholder values: [12345]\n```\n\nThe query generated will still use placeholders.  It will also\nautomatically keep track of the values that go with each placeholder.\n\nIf you want to see what placeholder values a query has collected then\nyou can call the [allValues()](manual/builder_methods.html#allvalues--) method.\n\n```js\nconst query = db\n  .select('id name')\n  .from('users')\n  .where({ id: 12345 })\n\nconsole.log(query.allValues())\n// -> [12345]\n```\n\nThe query builder also provides a [having()](manual/builder_methods.html#having-criteria-)\nmethod which works in a similar way.  The query builder collects placeholder values\nassociated with `WHERE` clauses separately from those associated with `HAVING` clauses.\nThis is because any `WHERE` clauses come before any `HAVING` clauses and the placeholder\nvalues must be ordered in that way.\n\nYou can call the [whereValues()](manual/builder_methods.html#wherevalues--) and\n[havingValues()](manual/builder_methods.html#havingvalues--) methods to see what values have\nbeen collected for them separately.\n\n```js\nconsole.log(query.whereValues())\n// -> [12345]\nconsole.log(query.havingValues())\n// -> []\n```\n\nIf you're building an [insert()](manual/builder_methods.html#insert-columns-)\nor [update()](manual/builder_methods.html#update-table-) query then you may also\nhave [setValues()](manual/builder_methods.html#setvalues--) defined.\nThis will contain placeholders values provided via\nthe [values()](manual/builder_methods.html#values-values-) or\n[set()](manual/builder_methods.html#set-values-) methods.\nFor [select()](manual/builder_methods.html#select-columns-)\nqueries this list will be empty.\n\n```js\nconsole.log(query.setValues())\n// -> [ ]\n```\n\nThe [allValues()](manual/builder_methods.html#allvalues--) method returns a\nconcatenated list of all the\n[setValues()](manual/builder_methods.html#setvalues--),\n[whereValues()](manual/builder_methods.html#wherevalues--) and\n[havingValues()](manual/builder_methods.html#havingvalues--),\n*in that order*.\n\nInstead of baking placeholder values into a query using the above methods you can\nprovider them all in one go when you run the query.\n\n## Running Queries\n\nWhen you've constructed a query you can call the\n[run()](manual/builder_methods.html#run-values--options-) method to execute\nthe query. This is used for queries that aren't expected to return any rows\nfrom the database, e.g. for `INSERT`, `UPDATE` or `DELETE` queries.  It's an\nasynchronous method (as are all the other execution methods) so you'll need\nto `await` the response (or use `.then(...)` if you prefer).\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where({ id: 12345 })\n  .run();\n```\n\nThe [all()](manual/builder_methods.html#all-values--options-) method can be used\nto fetch all rows matching the query.  It will return an array of objects containing\nthe data for each row.\n\n```js\nconst rows = await db\n  .select('id name')\n  .from('users')\n  .all();\nconsole.log(rows.length, 'rows returned')\n```\n\nThe [any()](manual/builder_methods.html#any-values--options-)\nmethod can be used to return a single row.  The method will return\nan object containing the row data or `undefined` if it doesn't match a row.\n\n```js\nconst row = await db\n  .select('id name')\n  .from('users')\n  .where({ id: 12345 })\n  .any();\nconsole.log(row ? 'got a row' : 'row not found')\n```\n\n\nIf you're expecting to get one and only one row returned then use the\n[one()](manual/builder_methods.html#one-values--options-) method instead.\nThis will throw an error if the row isn't found or if the query returns multiple rows.\n\n```js\nconst row = await db\n  .select('id name')\n  .from('users')\n  .where({ id: 12345 })\n  .any();\nconsole.log('got a row:', row)\n```\n\nYou can provide values for placeholders when you're building queries,\nas shown in the exampels above.  Or you can save them all up and pass\nthem as an array to the\n[run()](manual/builder_methods.html#run-values--options-),\n[one()](manual/builder_methods.html#one-values--options-),\n[any()](manual/builder_methods.html#any-values--options-) or\n[all()](manual/builder_methods.html#all-values--options-) methods.\n\n```js\nconst row = await db\n  .select('id name')\n  .from('users')\n  .where('id')\n  .any([12345]);\n```\n\nAlthough it's possible to provide some placeholder values in methods where\nyou're building the query (e.g. in [where()](manual/builder_methods.html#where-criteria-))\nand others when you run the query (e.g. in\n[all()](manual/builder_methods.html#all-values--options-)), you do have to be\ncareful to ensure the placeholder values end up in the right order.\n\nWhen the query is executed, the default order for placeholder values is the\nconcatenation of\n[setValues()](manual/builder_methods.html#setvalues--),\n[whereValues()](manual/builder_methods.html#wherevalues--),\n[havingValues()](manual/builder_methods.html#havingvalues--),\nand finally any values you provide to the execution methods:\n[run()](manual/builder_methods.html#run-values--options-),\n[one()](manual/builder_methods.html#one-values--options-),\n[any()](manual/builder_methods.html#any-values--options-) or\n[all()](manual/builder_methods.html#all-values--options-).\n\nIf you need to re-arrange the order of placeholder values then you can\npass a function to any of the query execution methods.  This will be\npassed three arrays: the\n[setValues()](manual/builder_methods.html#setvalues--),\n[whereValues()](manual/builder_methods.html#wherevalues--) and\n[havingValues()](manual/builder_methods.html#havingvalues--).  Your\nfunction should return an array containing the concatenated values\nincluding any other placeholder values you need to provide.\n\n```js\nconst row = await db\n  .select('id name')\n  .from('users')\n  .where('id')\n  .any(\n    // add any other placeholder values into the returned array\n    (sv, wv, hv) => [...sv, ...wv, ...hv]\n  );\n```\n\n## The Importance of Being Idempotent\n\nOne benefit of this implementation over some others is that the query\nbuilder chains are *idempotent*.  That's a fancy way of saying that\nadding new links in the chain doesn't affect any of the previous links.\n\nWhat this means in practice is that you can create a \"base\" query that\nyou can use to build other queries from.  Each query exists in its own\nindependent world and doesn't affect any other.\n\nConsider this query to fetch employees of a company by joining from the\n`users` table to the `employees` table and then onto the `companies` table.\n\n```js\nconst employees = db\n  .select(\n    'users.name employees.job_title',\n    ['companies.name', 'company_name']  // alias companies.name to company_name\n  )\n  .from('users')\n  .join('users.id=employees.user_id')\n  .join('employees.company_id=companies.id')\n```\n\nWe can then use that as the basis to construct a number of other queries.\nFor example, to fetch an employee by user id:\n\n```js\nconst row = await employees\n  .where('users.id')\n  .one([12345])\n```\n\nOr to fetch all employees for a company:\n\n```js\nconst rows = await employees\n  .where('companies.id')\n  .one([98765])\n```\n\nOr to fetch all employees with a particular job title:\n\n```js\nconst rows = await employees\n  .where('employees.job_title')\n  .all(['Chief Badger'])\n```\n\nEach query is entirely independent from the others.\n\nFurthermore, the fact that the query builder allows you to call methods\nout of sequence means that you're not limited to tagging new method calls\nonto the end of the base query.  For example, you can\n[select()](manual/builder_methods.html#select-columns-) additional\ncolumns in one of the new queries if there's something extra you need that\nisn't in the base query.\n\n```js\nconst rows = await employees\n  .select('users.id')\n  .where('employees.job_title')\n  .all(['Chief Badger'])\n```\n\n\n## Named Queries Using a Query Builder\n\nYou can define [named queries](manual/named_queries.html) that use the query\nbuilder to generate the SQL.\n\nThe named query should be defined as a function.  It will be passed a reference\nto the database and should return a query generated using the query builder.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  queries: {\n    selectUserByName:\n      db => db\n        .select('name email')\n        .from('users')\n        .where('name')\n  }\n});\n```\n\nYou can then use the named query just like any other named query.\n\n```js\nconst bobby = await db.one(\n  'selectUserByName',\n  ['Bobby Badger']\n);\n```\n\nYou can use the `query()` method to fetch a named query.  If it's\nconstructed using the query builder then you can call further methods\non it to create a more specialised query.  Remember, the original named\nquery won't be affected so it's perfectly safe to do this.\n\n```js\nconst bobby = await db\n  .query('selectUserByName')\n  .select('id')   // also select user id\n  .one(['Bobby Badger']);\n```\n\nYou can even do this to create named queries based on other named queries.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  queries: {\n    // \"base\" query to select a user\n    selectUser:\n      db => db\n        .select('name email')\n        .from('users')  // SELECT \"name\", \"email\" FROM \"users\"\n\n    // specialised version to select a user by name\n    selectUserByName:\n      db => db\n        .query('selectUser')\n        .where('name')  // SELECT \"name\", \"email\" FROM \"users\" WHERE \"name\" = ?\n\n    // specialised version to select a user by email\n    selectUserByName:\n      db => db\n        .query('selectUser')\n        .where('email') // SELECT \"name\", \"email\" FROM \"users\" WHERE \"email\" = ?\n  }\n});\n\nconst bobby = db.one(\n  'selectUserByName',\n  ['Bobby Badger']\n);\n\nconst brian = db.one(\n  'selectUserByEmail',\n  ['brian@badgerpower.com']\n);\n```\n\nYou can provide parameters in named queries and they will be \"remembered\" when\nyou come to run the query.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  queries: {\n    fetchAllBadgers:\n      db => db\n        .select('name email')\n        .from('users')\n        .where({ animal: 'Badger' })\n  }\n});\n\nconst badgers = await db.all('fetchAllBadgers')\n```\n\nThe [sql()](manual/builder_methods.html#sql--) method can be used to view the SQL generated by a named\nquery builder.\n\n```js\ndb.sql('fetchAllBadgers')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"animal\" = ?\n```\n\nIf you want to see what placeholder values the query has got defined then\nyou can call the [allValues()](manual/builder_methods.html#allvalues--) method.\n\n```js\ndb.query('fetchAllBadgers').allValues()\n// -> ['Badger']\n```\n\nPlaceholder values are stored in three separate arrays internally: one\nfor any values being set via an [insert()](manual/builder_methods.html#insert-columns-)\nor [update()](manual/builder_methods.html#update-table-) query\n([setValues()](manual/builder_methods.html#setvalues--)),\nanother for any values set via [where()](manual/builder_methods.html#where-criteria-)\n([whereValues()](manual/builder_methods.html#wherevalues--)),\nand the third for values set via\n[having()](manual/builder_methods.html#having-criteria-)\n([havingValues()](manual/builder_methods.html#havingvalues--)).\nThe [allValues()](manual/builder_methods.html#allvalues--)\nmethod returns the concatenation of these three arrays.\n\n```js\nconst q = db.query('fetchAllBadgers')\nq.setValues()     // -> []\nq.whereValues()   // -> ['Badger']\nq.havingValues()  // -> []\n```\n\n## Where Next?\n\nIn the next section we'll go over the\n[query builder methods](manual/builder_methods.html) in detail.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/builder_methods.md",
    "name": "./manual/builder_methods.md",
    "content": "# Query Builder Methods\n\nThis page describes all the query builder methods in detail.\n\n* [Introduction](#introduction)\n* [Select Queries](#select-queries)\n  * [select(columns)](#select-columns-)\n  * [from(table)](#from-table-)\n  * [where(criteria)](#where-criteria-)\n  * [join(table)](#join-table-)\n  * [order(columns)](#order-columns-)\n  * [group(columns)](#group-columns-)\n  * [having(criteria)](#having-criteria-)\n  * [limit(n)](#limit-n-)\n  * [offset(n)](#offset-n-)\n  * [range(from, to)](#range-from--to-)\n  * [columns(columns)](#columns-columns-)\n  * [table(table)](#table-table-)\n  * [prefix(prefix)](#prefix-prefix-)\n* [Insert Queries](#insert-queries)\n  * [insert(columns)](#insert-columns-)\n  * [into(table)](#into-table-)\n  * [values(values)](#values-values-)\n  * [returning(columns)](#returning-columns-)\n* [Update Queries](#update-queries)\n  * [update(table)](#update-table-)\n  * [set(values)](#set-values-)\n* [Delete Queries](#delete-queries)\n  * [delete()](#delete--)\n* [Execution Methods](#execution-methods)\n  * [run(values, options)](#run-values--options-)\n  * [one(values, options)](#one-values--options-)\n  * [any(values, options)](#any-values--options-)\n  * [all(values, options)](#all-values--options-)\n  * [sql()](#sql--)\n* [Placeholder Value Methods](#placeholder-value-methods)\n  * [setValues()](#setvalues--)\n  * [whereValues()](#wherevalues--)\n  * [havingValues()](#havingvalues--)\n  * [allValues()](#allvalues--)\n\n## Introduction\n\nThe main query builder methods all work in a similar way with respect\nto the arguments they accept.  The short form is to pass a string which\nmay have some additional processing applied to it (typically splitting\na whitespace delimited string into multiple tokens).  Where there\nare two, three or four possible arguments, an array can be passed.\nOr an object can be passed with explicit properties for the different\nparameters.\n\nAll the methods can generate raw SQL.  This can be specified by\npassing an object with a single `sql` property:\n\n```js\ndb.select({ sql: 'COUNT(id) AS n' })\n```\n\nOr using the `sql` function to create a tagged template literal:\n\n```js\nimport { sql } from '@abw/badger-database'\n\ndb.select(sql`COUNT(id) AS n`)\n```\n\nAll of the methods can be called multiple times, or passed multiple\narguments.  They both have the same effect.  Generally speaking,\nyou can call the methods in any order and the query builder will\ngenerate the SQL query with them in the correct order.\n\nFor the sake of brevity these examples assume that you've already\nconnected to a database and stored the connection in the `db` variable.\n\n```js\nimport connect from '@abw/badger-database'\n\nasync function main() {\n  const db = connect({ database: 'sqlite:memory' });\n\n  // ...examples would go here\n}\n```\n\nThe examples show the SQL generated by the fragment.  In many cases they're\nnot complete queries and we've omitted the final `.sql()` method call\nwhich is called internally to generate the SQL.\n\nIn these example we're assuming that the database is Sqlite which\nquotes table and columns names using double quotes, e.g. `\"users\".\"id\"`.\nFor Mysql the names will be quoted using backticks.  Examples that\nshow placeholders also assume Sqlite (and Mysql) which uses question\nmarks, e.g. `?`.  For Postgress the placeholders are of the form `$1`,\n`$2`, `$3`, etc.\n\n## Select Queries\n\n### select(columns)\n\nThis method is used to specify one or more columns that you want to\nselect.\n\n```js\ndb.select('id');\n// -> SELECT \"id\"\n```\n\nYou can specify multiple columns using the shorthand syntax as a\nstring of whitespace delimited column names.\n\n```js\ndb.select('id email');\n// -> SELECT \"id\", \"email\"\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit column names.\n\n```js\ndb.select('id, email');\n// -> SELECT \"id\", \"email\"\n```\n\nColumns can have the table name included in them.  Both the table\nand columns names will be automatically quoted.\n\n```js\ndb.select('users.id users.email');\n// -> SELECT \"users\".\"id\", \"users\".\"email\"\n```\n\nYou can specify `*` to select all columns.  This will not be quoted.\n\n```js\ndb.select('*');\n// -> SELECT *\n```\n\nYou can also use `*` to select all columns from a table.  The table name\nwill be automatically quoted but the asterisk will not.\n\n```js\ndb.select('users.*');\n// -> SELECT \"users\".*\n```\n\nYou can pass an object to the method containing the `columns` property.\nThe format for the value is either a single column name or multiple columns\ndelimited with whitespace or commas/whitespace, as shown in the previous\nexamples.\n\n```js\ndb.select({ columns: 'id email company.*' });\n// -> SELECT \"id\", \"email\", \"company\".*\n```\n\nYou can also define the `table` as a property to have the table name automatically\nadded to the column names.\n\n```js\ndb.select({ table: 'users', columns: 'id email' });\n// -> SELECT \"users\".\"id\", \"users\".\"email\"\n```\n\nThe `prefix` property can be used to automatically create aliases for the columns.\nThe prefix will be attached to the front of each column name.\n\n```js\ndb.select({ columns: 'id email', prefix: 'user_' });\n// -> SELECT \"id\" AS \"user_id\", \"email\" AS \"user_email\"\n```\n\nThis also works in conjunction with the `table` property.\n\n```js\ndb.select({ table: 'users', columns: 'id email', prefix: 'user_' });\n// -> SELECT \"users\".\"id\" AS \"user_id\", \"users\".\"email\" AS \"user_email\"\n```\n\nAn object can also contain a `column` item.  In this case it is assumed to\nbe a single column name which is not split into separate columns.  The optional\n`as` property can be provided to create an alias for the column.\n\n```js\ndb.select({ column: 'email', as: 'email_address' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nThe `table` property can also be provided in this case.\n\n```js\ndb.select({ table: 'users', column: 'email', as: 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nOr you can include the table name in the column.\n\n```js\ndb.select({ column: 'users.email', as: 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nThe shorthand format for creating a column alias is to pass an array of\neither two elements (the column name and alias) or three (the table name,\ncolumn name and alias).\n\n```js\ndb.select(['email', 'email_address' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\n```js\ndb.select(['users', 'email', 'email_address' });\n// -> SELECT \"users\".\"email\" AS \"email_address\"\n```\n\nYou can use raw SQL to define the table columns.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb.select({ sql: '\"email\" AS \"email_address\"' });\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\ndb.select(sql`\"email\" AS \"email_address\"`);\n// -> SELECT \"email\" AS \"email_address\"\n```\n\nYou can call the method multiple times.  The column names will all be\ncollected after the `SELECT` keyword.\n\n```js\ndb.select('id email').select({ table: 'companies', column: 'name', as: 'company_name' });\n// -> SELECT \"id\", \"email\", \"companies\".\"name\" AS \"company_name\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.select('id email', { table: 'companies', column: 'name', as: 'company_name' });\n// -> SELECT \"id\", \"email\", \"companies\".\"name\" AS \"company_name\"\n```\n\n### from(table)\n\nThis method is used to specify one or more tables that you want to\nselect from.\n\n```js\ndb.from('users');\n// -> FROM \"users\"\n```\n\nYou can specify multiple tables using the shorthand syntax as a\nstring of whitespace delimited table names.\n\n```js\ndb.from('users companies');\n// -> FROM \"users\", \"companies\"\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit table names.\n\n```js\ndb.from('users, companies');\n// -> FROM \"users\", \"companies\"\n```\n\nYou can pass an object to the method containing the `tables` property.\nThe format for the value is either a single table name or multiple tables\ndelimited with either whitespace or commas, as shown in the previous\nexamples.\n\n```js\ndb.from({ tables: 'users, companies' });\n// -> FROM \"users\", \"companies\"\n```\n\nAn object can also contain a `table` item.  In this case it is assumed to\nbe a single table name is not split into separate table names.  The optional\n`as` property can be provided to create an alias for the table.\n\n```js\ndb.from({ table: 'users', as: 'people' });\n// -> FROM \"users\" AS \"people\"\n```\n\nThe shorthand format for creating a table alias is to pass an array of two\nelements: the table name and alias.\n\n```js\ndb.from(['users', 'people']);\n// -> FROM \"users\" AS \"people\"\n```\n\nYou can use raw SQL to define the table name.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb.from({ sql: '\"users\" AS \"people\"' });\n// -> FROM \"users\" AS \"people\"\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\ndb.from(sql`\"users\" AS \"people\"`);\n// -> FROM \"users\" AS \"people\"\n```\n\nYou can call the method multiple times.  The tables names will all be\ncollected after the `FROM` keyword.\n\n```js\ndb.from(['users', 'people']).from('companies').from({ table: 'employees' })\n// -> FROM \"users\" AS \"people\", \"companies\", \"employees\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.from(['users', 'people'], 'companies', { table: 'employees' })\n// -> FROM \"users\" AS \"people\", \"companies\", \"employees\"\n```\n\n### where(criteria)\n\nThis method can be used to specify the criteria for matching rows.\nYou can specify one or more columns that you want to match against.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where('id')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nThe query will be constructed with placeholders matching the specified\ncolumn or columns.\n\nValues for placeholders can be passed as an array to the\n[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.\n\n```js\nconst row = await db\n  .select('name email')\n  .from('users')\n  .where('id')\n  .one([12345])\n```\n\nYou can specify multiple columns using the shorthand syntax as a\nstring of whitespace delimited table names.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where('id name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ? AND \"name\" = ?\n```\n\nCommas (with optional whitespace following) can also be used to\ndelimit column names.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where('id, name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ? AND \"name\" = ?\n```\n\nColumns can have the table name included in them.  Both the table\nand columns names will be automatically quoted.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where('users.id')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"users\".\"id\" = ?\n```\n\nYou can pass an object to the method mapping column names to their respective values.\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where({ id: 12345 })\n  .one()      // automatically uses placeholder values: [12345]\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nThe query will still be constructed with placeholder values but all the values\nwill be collected and automatically provided to the\n[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.\nIn this case the values would be `[12345]`.\n\nYou can pass additional values to those method to provide any additional values.\nBe warned that they will always be added *after* values specified in the query.\n\nTo illustrate, this will work as intended:\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where({ id: 12345 })     // placeholder for id\n  .where('name')            // placeholder for name\n  .one(['Bobby Badger'])    // placeholder values are [12345, 'Bobby Badger']\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n//    AND \"name\" = ?\n```\n\nBut this won't:\n\n```js\n// DON'T DO THIS!\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where('name')            // placeholder for name\n  .where({ id: 12345 })     // placeholder for id\n  .one(['Bobby Badger'])    // WRONG! placeholder values are [12345, 'Bobby Badger']\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"name\" = ?\n//    AND \"id\" = ?\n```\n\nFor this reason it is usually best if you *either* specify all of the values in\nthe `where()` clauses, *or* pass them all into the `one()`, `any()` or `all()` methods.\nThis is also particularly relevant if you have a query that includes\n[having()](#having-criteria-) clauses as well.\n\nYou can also provide values as an array of `[column, value]`.\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where(['id', '12345'])\n  .one()            // automatically uses placeholder values: [12345]\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nIf you want to see what placeholder values have been collected in a query then you\ncan call the `allValues()` method.\n\n```js\nconst query = db\n  .select('id name')\n  .from('users')\n  .where({ id: 12345 })\n\nconsole.log(query.allValues())\n// -> [12345]\n```\n\nThe column can be raw SQL if necessary.  Either use the\n`sql` function to create a tagged template literal or\npass it as an object with a single `sql` property.\n\n```js\nconst row = await db\n  .select('id name email')\n  .from('users')\n  .where([sql`id + 100`, 102])\n  .one()            // automatically uses placeholder values: [102]\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE id + 100 = ?\n```\n\nBy default the comparison operator is `=`.  You can provide an array of three\nvalues to set a different comparison operator: `[column, operator, value]`.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where(['id', '>', '12345'])\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\nIf you want to provide a comparison operator but define the value later then\nset the third item to `undefined`.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where(['id', '>', undefined])\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\nOr you can define the operator in an array, either with or without a value.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where(['id', ['>', 12345]])\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where(['id', ['>']])\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\nYou can also set a comparison operator using an object by setting the value\nto a two element array: `[operator, value]`.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where({ id: ['>', '12345']})\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\nOr if you want to provide the value later then use a single element array: `[operator]`.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where({ id: ['>']})\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ?\n```\n\nYou can use raw SQL to define the criteria.  The explicit way is to\npass an object with a `sql` property.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where({ sql: 'id > ?' })\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE id > ?\n```\n\nOr you can use the `sql` function to create a tagged template literal.\n\n```js\ndb.select('id name email')\n  .from('users')\n  .where(sql`id > ?`)\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE id > ?\n```\n\nYou can call the method multiple times.  The criteria will all be\ncollected after the `WHERE` keyword and combined with `AND`.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where(['id', '>', 12345])\n  .where('name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ? AND \"name\" = ?\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.select('name email')\n  .from('users')\n  .where(['id', '>', 12345], 'name')\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" > ? AND \"name\" = ?\n```\n\n### join(table)\n\nThis method can be used to join tables.  A string can be passed as\na shorthand syntax of the form `from = table.to`, where `from` is the\ncolumn you're joining from, `table` is the table you're joining onto\nand `to` is the column in the joined table that should match the value\nin the `from` column.  Spaces are optional around the equals sign,\ne.g. `from=table.to` or `from = table.to` are both treated the same.\n\n```js\ndb.select('name email')\n  .select(['companies.name', 'company_name'])\n  .from('users')\n  .join('users.company_id = companies.id')\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nFor a left join, use a left pointing arrow, e.g. `from <= table.to`.\nFor a right join, use a right pointing arrow, e.g. `from => table.to`.\nFor a full join, use a double headed arrow, e.g. `from <=> table.to`.\nSpaces around the arrow are optional.\n\nYou can pass an array to the method containing 2, 3, or 4 elements.\nWhen using two elements, the first should be the table column you're\njoining from and the second should be the table column you're joining to.\n\n```js\ndb.select('name email')\n  .from('users')\n  .select(['companies.name', 'company_name'])\n  .join(['users.company_id', 'companies.id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nThe three element version has the destination table and column separated.\n\n```js\ndb.select('name email')\n  .from('users')\n  .select(['companies.name', 'company_name'])\n  .join(['users.company_id', 'companies', 'id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nThe four element version allows you to specify the join type at the\nbeginning.  Valid types are `left`, `right`, `inner` and `full`.\n\n```js\ndb.select('name email')\n  .from('users')\n  .select(['companies.name', 'company_name'])\n  .join(['left', 'users.company_id', 'companies', 'id'])\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nYou can pass an object to the method containing the `from`, `table`\nand `to` properties, and optionally the `type`.\n\n```js\ndb.select('name email')\n  .from('users')\n  .select(['companies.name', 'company_name'])\n  .join({ type: 'left', from: 'users.company_id', table: 'companies', to: 'id' })\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nOr you can combine the table name and column in the `to` property.\n\n```js\ndb.select('name email')\n  .from('users')\n  .select(['companies.name', 'company_name'])\n  .join({ type: 'left', from: 'users.company_id', to: 'companies.id' })\n// -> SELECT \"name\", \"email\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    LEFT JOIN \"companies\" ON \"users\".\"company_id\" = \"companies\".\"id\"\n```\n\nYou know the drill, right?  If the method doesn't do what you need then you\ncan use raw SQL to define the joins, either with an object containing a\n`sql` property:\n\n```js\ndb.select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .from('users')\n  .join({ sql: 'JOIN employees ON users.id=employees.user_id' })\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN employees ON users.id=employees.user_id\n```\n\nOr using the `sql` function to create a tagged template literal.\n\n```js\ndb.select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .from('users')\n  .join(sql`JOIN employees ON users.id=employees.user_id`)\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN employees ON users.id=employees.user_id\n```\n\nAnd just like the other methods, you can call the method multiple times.\n\n```js\ndb.select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .from('users')\n  .join('users.id = employees.user_id')\n  .join('employees.company_id = companies.id')\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"employees\" ON \"users\".\"id\" = \"employees\".\"user_id\"\n//    JOIN \"companies\" ON \"employees\".\"company_id\" = \"companies\".\"id\"\n```\n\nOr you can pass multiple arguments to a single method call.  Each argument\ncan be any of the values described above.\n\n```js\ndb.select('name email employee.job_title')\n  .select(['companies.name', 'company_name'])\n  .from('users')\n  .join('users.id = employees.user_id', 'employees.company_id = companies.id')\n// -> SELECT \"name\", \"email\", \"employee\".\"job_title\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\"\n//    JOIN \"employees\" ON \"users\".\"id\" = \"employees\".\"user_id\"\n//    JOIN \"companies\" ON \"employees\".\"company_id\" = \"companies\".\"id\"\n```\n\n### order(columns)\n\nThis method can be used to create an `ORDER BY` clause.  There's also an\n`orderBy()` alias for the method if you prefer something a little closer\nin name to the SQL it generates.\n\nA string can be passed containing one or more columns.\n\n```js\ndb.select('*')\n  .from('users')\n  .order('name')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\"\n```\n\nColumns can be delimited by whitespace or commas, as usual.\n\n```js\ndb.select('*')\n  .from('users')\n  .order('name, email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\"\n```\n\nColumns can include the table name for disambiguation.\n\n```js\ndb.select('*')\n  .from('users')\n  .order('users.name users.email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"users\".\"name\", \"users\".\"email\"\n```\n\nThe default order is `ASC` for \"ascending\".  To set a different sort\norder (e.g. `DESC` for \"descending\"), pass a two element array with the\ncolumns as the first element and `DESC` as the second.\n\n```js\ndb.select('*')\n  .from('users')\n  .order(['name email', 'DESC'])\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nYou can also pass an objecting containing the `column` or `columns` property.\nThe `column` is assumed to be a single column whereas `columns` can contain\nmultiple columns separated by whitespace or commas in the usual way.  In addition\nyou can specify either `asc` or `desc` as a boolean flag to set the sort direction\nto be ascending or descending, respectively.\n\n```js\ndb.select('*')\n  .from('users')\n  .order({ columns: 'name email', desc: true })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nOr use `direction` (or `dir` for short) set to either `ASC` or `DESC` if you prefer.\n\n```js\ndb.select('*')\n  .from('users')\n  .order({ columns: 'name email', dir: 'DESC' })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\", \"email\" DESC\n```\n\nOf course it also supports raw SQL, either using a `sql` property in an object.\n\n```js\ndb.select('*')\n  .from('users')\n  .order({ sql: 'name DESC, email' })\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY name DESC, email\n```\n\nOr using a tagged template literal.\n\n```js\ndb.select('*')\n  .from('users')\n  .order(sql`name DESC, email`)\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY name DESC, email\n```\n\nYou can call the method multiple times or pass multiple arguments to it.\n\n```js\ndb.select('*')\n  .from('users')\n  .order(['name', 'DESC'], 'email')\n// -> SELECT *\n//    FROM \"users\"\n//    ORDER BY \"name\" DESC, \"email\"\n```\n\n### group(columns)\n\nThis method can be used to create a `GROUP BY` clause.  There's also a\n`groupBy()` alias for it.\n\nA string can be passed containing one or more columns.\n\n```js\ndb.select(sql`company_id, COUNT(id) AS employees`)\n  .from('users')\n  .group('company_id')\n// -> SELECT company_id, COUNT(id) AS employees\n//    FROM \"users\"\n//    GROUP BY \"company_id\"\n```\n\nMultiple columns can be delimited by whitespace or commas and can contain\na table name.\n\n```js\ndb.select('*')\n  .from('users')\n  .group('users.company_id, users.start_year')\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"users\".\"company_id\", \"users\".\"start_year\"\n```\n\nYou can also pass an objecting containing the `column` or `columns` property.\nThe `column` is assumed to be a single column whereas `columns` can contain\nmultiple columns separated by whitespace or commas in the usual way.\n\n```js\ndb.select('*')\n  .from('users')\n  .group({ columns: 'company_id, year' })\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"company_id\", \"year\"\n```\n\nAs you might expect it also supports raw SQL, either using a `sql` property in an object.\n\n```js\ndb.select('*')\n  .from('users')\n  .group({ sql: 'company_id' })\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY company_id\n```\n\nOr using a tagged template literal.\n\n```js\ndb.select('*')\n  .from('users')\n  .group(sql`company_id`)\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY company_id\n```\n\nYou can call the method multiple times or pass multiple arguments to it.\n\n```js\ndb.select('*')\n  .from('users')\n  .order('company_id', 'start_year')\n// -> SELECT *\n//    FROM \"users\"\n//    GROUP BY \"company_id\", \"start_year\"\n```\n\n### having(criteria)\n\nThis method works exactly like [where()](#where-criteria-) but is used to specify the\ncriteria for matching rows with the `HAVING` keyword.\n\nOne important thing to note is that the `HAVING` clause always appears near the end\nof the generated query, coming after the `WHERE` clause.  When you are providing\nvalues for placeholders you should always put the `WHERE` values first followed\nby the `HAVING` values.\n\nThe query builder allows you to call methods in any order and will automatically\narrange them correctly when building the SQL query.  For example, it is perfectly\nvalid to call `having()` before `where()`, but you MUST provide the values for the\n`where()` clauses before those for the `having()` clauses.\n\n```js\ndb.select(...)\n  .from(...)\n  .having('x')\n  .where('y')\n  .all([yValue, xValue])\n// -> SELECT ...\n//    FROM ...\n//    WHERE \"y\" = ?\n//    HAVING \"x\" = ?\n```\n\nFor this reason it is recommended that you put all `where()` clauses before any\n`having()` clauses so that you don't confuse yourself.\n\nIf you provide values in the `where()` or `having()` clauses then you don't need\nto worry.  The query builder automatically collects all `where()` values separately\nfrom `having()` values and passed them to the database engine in the correct order.\n\n```js\ndb.select(...)\n  .from(...)\n  .having({ x: xValue })\n  .where({ y: yValue })\n  .all()            // placeholder values will be [yValue, xValue]\n```\n\nYou can see what placeholder values have been collected in a query, and the order\nthat they will appear, in by calling the `allValues()` method.  Note that regardless\nof the order of method calls, all `where()` placeholder values comes before `having()`\nvalues.\n\n```js\nconst query = db\n  .select('...')\n  .from('...')\n  .where({ a: 123 })\n  .having({ b: 789 })\n  .where({ a: 456 })\n\nconsole.log(query.allValues())\n// -> [123, 456, 789]\n```\n\nIn order to get the placeholder values in the right order, the query builder stores\n`where()` values separately from `having()` values.  The `whereValues()` and `havingValues()`\nmethods all you to inspect them.\n\n```js\nconsole.log(query.whereValues())\n// -> [123, 456]\nconsole.log(query.havingValues())\n// -> [789]\n```\n\nThe [insert()](#insert-columns-) and [update()](#update-table-) methods also have their\nown array for storing values which can be inspected by calling `setValues()`.\n\n### limit(n)\n\nThis method can be used to set a `LIMIT` for the number of rows returned.\n\nAn integer should be passed to it.\n\n```js\ndb.select('id name')\n  .from('users')\n  .limit(10)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 10\n```\n\nIf you call the method multiple times the previously set value will be overwritten.\n\n```js\ndb.select('id name')\n  .from('users')\n  .limit(10)\n  .limit(20)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 20\n```\n\n### offset(n)\n\nThis method can be used to set an `OFFSET` for the number of rows returned.\n\nAn integer should be passed to it.\n\n```js\ndb.select('id name')\n  .from('users')\n  .offset(10)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    OFFSET 10\n```\n\nIf you call the method multiple times the previously set value will be overwritten.\n\n```js\ndb.select('id name')\n  .from('users')\n  .offset(10)\n  .offset(20)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    OFFSET 20\n```\n\n### range(from, to)\n\nThis method allows you to set both the `LIMIT` and `OFFSET` at once.\n\nIt expects two integers representing the first row you want returned and\nthe last row.  Note that the numbers start at 0 and the range is *inclusive*.\n\n```js\ndb.select('id name')\n  .from('users')\n  .range(50, 59)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 10\n//    OFFSET 50\n```\n\nIf you pass one integer then it is assumed to be the first row you want returned\nand there will be no `LIMIT` to the number of rows returned.\n\n```js\ndb.select('id name')\n  .from('users')\n  .range(50)\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    OFFSET 50\n```\n\nYou can also provide an object containing `from` and/or `to`.\n\n```js\ndb.select('id name')\n  .from('users')\n  .range({ from: 50, to: 59 })\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 10\n//    OFFSET 50\n```\n\n```js\ndb.select('id name')\n  .from('users')\n  .range({ from: 50 })\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    OFFSET 50\n```\n\n```js\ndb.select('id name')\n  .from('users')\n  .range({ to: 49 })\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 50\n```\n\nYou can also use it to explicitly set the `limit` and/or `offset`.\n\n```js\ndb.select('id name')\n  .from('users')\n  .range({ limit: 10, offset: 50 })\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    LIMIT 10\n//    OFFSET: 50\n```\n\n```js\ndb.select('id name')\n  .from('users')\n  .range({ offset: 50 })\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    OFFSET 50\n```\n\n### columns(columns)\n\nThis is just like [select()](#select-columns-) with one important\ndistinction.  If you don't explicitly specify a table name then it\nwill automatically attach the column names to the most recently\nspecified table.\n\n```js\ndb.from('users')\n  .columns('id email');\n// -> SELECT \"users\".\"id\", \"users\".\"email\"\n//    FROM \"users\"\n```\n\nYou can interleave it with multiple calls to [from()](#from-table-)\nto access columns from different tables.\n\n```js\ndb.from('users')\n  .columns('id email');\n  .from('companies')\n  .columns('name');\n// -> SELECT \"users\".\"id\", \"users\".\"email\", \"companies\".\"name\"\n//    FROM \"users\"\n```\n\nIf you specify multiple table names in [from()](#from-table-) then the\nlast one will be used.\n\n```js\ndb.from('companies users')\n  .columns('id name');\n// -> SELECT \"users\".\"id\", \"users\".\"name\"\n//    FROM \"companies\", \"users\"\n```\n\nIf you specify a table with an alias then the alias will be used.\n\n```js\ndb.from({ table: \"users\", as: \"people\" })\n  .columns('id name');\n// -> SELECT \"people\".\"id\", \"people\".\"name\"\n//    FROM \"users\" AS \"people\"\n```\n\n### table(table)\n\nThis can be used in conjuction with [columns()](#columns-columns-) to select\na table to attach columns to.  The table should previously have been specified\nusing [from()](#from-table-).\n\n```js\ndb.from('users companies')\n  .table('users').columns('id name')\n  .table('companies').columns(['name', 'company_name'])\n// -> SELECT \"users\".\"id\", \"users\".\"name\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\", \"companies\"\n```\n\n### prefix(prefix)\n\nThis can be used in conjuction with [columns()](#columns-columns-) to define\na prefix for subsequent columns.\n\n```js\ndb.from('users companies')\n  .table('users').prefix('user_').columns('id name')\n  .table('companies').prefix('company_').columns('name')\n// -> SELECT \"users\".\"id\" AS \"user_id\", \"users\".\"name\" AS \"user_name\", \"companies\".\"name\" AS \"company_name\"\n//    FROM \"users\", \"companies\"\n```\n\nYou can clear the current prefix by calling `prefix()` without any arguments.\n\n## Insert Queries\n\n### insert(columns)\n\nThis method is used to generate an `INSERT` query.  The argument(s) specify\nthe columns that you want to insert.\n\n```js\ndb.insert('name email');\n```\n\nIt should be used in conjunction with [into()](#into-table-).\n\n### into(table)\n\nThis method is used to specify the name of the table that you want to insert into.\n\n```js\ndb.insert('name email')\n  .into('users');\n// -> INSERT INTO \"users\" (\"name\", \"email\") VALUES (?, ?)\n```\n\n### values(values)\n\nThis method can be used to provide values for an insert query.\nThey can be provided as individual arguments or passed as an\narray.\n\n```js\nawait db\n  .insert('name email')\n  .into('users')\n  .values('Brian Badger', 'brian@badgerpowercom')\n  .run();\n```\n\nIf you don't specify the values here then you should provide them\nas an array to the [run()](#run-values-) method.\n\n```js\nawait db\n  .insert('name email')\n  .into('users')\n  .run(['Brian Badger', 'brian@badgerpowercom'])\n```\n\n### returning(columns)\n\nThis methods generate a `RETURNING` clause for Postgres.  The\nargument should be one or more columns that the query should\nreturn.\n\n```js\ndb.insert('name email')\n  .into('users')\n  .returning('id');\n// -> INSERT INTO \"users\" (\"name\", \"email\")\n//    VALUES (?, ?)\n//    RETURING \"id\"\n```\n\nThe method works much like the [select()](#select-columns-) method.\nFor example, you can define an alias by passing a two element array.\n\n```js\ndb.insert('name email')\n  .into('users')\n  .returning(['id', 'user_id');\n// -> INSERT INTO \"users\" (\"name\", \"email\")\n//    VALUES (?, ?)\n//    RETURING \"id\" AS \"user_id\"\n```\n\n## Update Queries\n\n### update(table)\n\nThis method is used to start building an `UPDATE` query.  The argument is the\nname of the table you want to update.  It should be used in conjunction\nwith [set()](#set-values-).\n\n```js\ndb.update(\"users\")\n// -> UPDATE \"users\"\n```\n\n### set(values)\n\nThis method is used to specify the changes that you want to make in an `UPDATE`\nquery.  You can specify the values as column names and then provide the values\nwhen you call the [run()](#run-values-) method.\n\n```js\nawait db\n  .update(\"users\")\n  .set('name')\n  .where('id')\n  .run(['Brian the Badger', 12345])\n// -> UPDATE \"users\"\n//    SET \"name\" = ?, \"email\" = ?\n//    WHERE \"id\" = ?\n```\n\nOr you can provide the values to the `set()` method, in the same way that you can\nfor [where()](#where-criteria-).\n\n```js\nawait db\n  .update(\"users\")\n  .set({ name: 'Brian the Badger' })\n  .where({ id: 12345 })\n  .run()\n```\n\n## Delete Queries\n\n### delete()\n\nThe `delete()` method is used to start a `DELETE` query.  In the usual\ncase it doesn't take any arguments, but should be used in conjunction with\n[from()](#from-table-) to specify the table, and optionally [where()](#where-criteria-),\nto select the rows that you want to delete.\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where({ id: 12345 })\n  .run()\n// -> DELETE FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nAs usual, values can be specified in the [where()](#where-criteria-)\nmethod, as shown above, or passed to the [run()](#run-values-) method.\n\n```js\nawait db\n  .delete()\n  .from('users')\n  .where('id')\n  .run([12345])\n```\n\n## Execution Methods\n\n### run(values, options)\n\nThis method can be used to run query where you're not expecting to get\nany rows returned.  This is typically used for [insert()](#insert-queries),\n[update()](#update-queries) and [delete()](#delete-queries) queries.\n\nIf you have any placeholders in the query that you haven't already defined\nvalues for then you should provide them as an array.\n\n```js\nconst result = await db\n  .insert('name email')\n  .into('users')\n  .run(['Brian Badger', 'brian@badgerpower.com'])\n// -> INSERT INTO \"users\" (\"name\", \"email\")\n//    VALUES (?, ?)\n```\n\nAlthough this method doesn't return any rows from the database is does\nreturn a result.\n\nYou can pass a second argument to the `run()` method as an object containing\noptions.  The `sanitizeResult` option standardised the response for different\ndatabase types so that, for example, `changes` always contains the number of\nrows changed.\n\n```js\nconst result = await db\n  .insert('name email')\n  .into('users')\n  .run(\n    ['Brian Badger', 'brian@badgerpower.com'],\n    { sanitizeResult: true }\n  )\nconsole.log(\"changes: \", result.changes)\n```\n\nIf you specify any placeholder values in the query then these will automatically\nbe provided to the `run()` method.  For example, the `values()` method can be\nused to provide values to an `insert()` query.\n\n```js\nconst result = await db\n  .insert('name email')\n  .into('users')\n  .values('Brian Badger', 'brian@badgerpower.com')\n  .run()\n```\n\n### one(values, options)\n\nThis method will execute the query and return exactly one row.  If the query\nreturns more than one row or no rows then an error will be thrown.\n\nIf you have any placeholders in the query that you haven't already defined\nvalues for then you should provide them as an array.\n\nIn this query the value for `id` is specified in the `where()` method so\nyou don't need to pass anything to the `one()` method.\n\n```js\nconst row = await db\n  .select('name email')\n  .from('users')\n  .where({ id: 12345 })\n  .one()            // automatically receives placeholder values: [12345]\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nIn this query it isn't so you need to provide it to the `one()` method.\n\n```js\nconst row = await db\n  .select('name email')\n  .from('users')\n  .where('id')\n  .one([12345])     // manually provider placeholder values\n// -> SELECT \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"id\" = ?\n```\n\nAlthough it generally isn't recommended you can mix and match the two approaches.\nHowever you should note that all placeholder values that have been specified\nin `where()` clauses will be provided first, followed by any in `having()` clauses.\nAny additional values that you provide to the `one()` method will come last.  It\nis your responsibility to ensure that these are in the correct order for your query!\n\nIf you have a mixture of `where()` and `having()` calls, then you might find yourself\nin a tight spot if you've mixed and matched.\n\nConsider this somewhat contrived example:\n\n```js\ndb.select(...)\n  .from(...)\n  .where({ a: 10 })\n  .where('b')\n  .having({ c: 30 })\n  .having('d');\n// -> SELECT ...\n//    FROM ...\n//    WHERE \"a\" = ?\n//    AND \"b\" = ?\n//    HAVING \"c\" = ?\n//    AND \"d\" = ?\n```\n\nNow you've got a problem.  When you call the `one()` (or `any()`/`all()`) method\nyou need to provide values for `b` and `d`.  But the query has already got a list\nof values for `where()` clauses set to `[10]` (for `a`) and a list for `having()`\nclauses set to `[30]` (for `c`).  If you pass the values for `b` and `c` as `[20, 40]`\nthen you'll end up with a complete list of values set to `[10, 30, 20, 40]` which isn't\nin the correct order for the query.\n\nAt this point we could refer you back to the bit where we said that mixing up different\napproaches isn't recommended.  But you already know that.\n\nIf you need to jiggle around with the order of values then you can pass a function\nto the `any()` method.  This will received three lists of placeholder values:\n\n* `setValues` contains any placeholder values provided via the [values()](#values-values-)\nmethod as part of an [insert()](#insert-queries) query, or via the [set()](#set-values-)\nmethod as part of an [update()](#update-queries) query.\n\n* `whereValues` contains any placeholder values provided via the [where()](#where-criteria-)\nmethod.\n\n* `havingValues` contains any placeholder values provided via the [having()](#having-criteria-)\nmethod.\n\nthat have been collected from `where()` clauses and those that have been collected\nfrom `having()` clauses.  The function should return a new array containing the\nvalues in the right order.\n\n```js\ndb.select(...)\n  .from(...)\n  .where({ a: 10 })\n  .where('b')\n  .having({ c: 30 })\n  .having('d')\n  .one((where, having) => [...where, 20, ...having, 40])\n```\n\nNow the order of placeholder values will be correctly set to `[10, 20, 30, 40]`.\n\nIf you want to double-check you can call the `values()` method on a query to\ncheck that it returns them in the right order.\n\n```js\ndb.select(...)\n  .from(...)\n  .where({ a: 10 })\n  .where('b')\n  .having({ c: 30 })\n  .having('d')\n  .values((where, having) => [...where, 20, ...having, 40])\n// -> [10, 20, 30, 40]\n```\n\nYou can also call the `whereValues()` and `havingValues()` to see what the query\nhas got stored for them.\n\n### any(values, options)\n\nThis method will execute the query and return one row if it exists or `undefined`\nif it doesn't.  In all other respects it works exactly like [one()](#one-values-).\n\n### all(values, options)\n\nThis method will execute the query and return an array of all matching rows.\nThe array may be empty if no rows are matched.  In all other respects it works\nexactly like [one()](#one-values-).\n\n### sql()\n\nThis methods generates and returns the SQL for the query.\n\n## Placeholder Value Methods\n\n### setValues()\n\nThis returns any array of any placeholder values provided to the\n[values()](#values-values-) or\n[set()](#set-values-) methods.\n\n### whereValues()\n\nThis returns any array of any placeholder values provided to the\n[where()](#where-criteria-) method.\n\n### havingValues()\n\nThis returns any array of any placeholder values provided to the\n[having()](#having-criteria-) method.\n\n### allValues()\n\nThis returns an array of all placeholder values.  It is the concatenated\nlist of [setValues()](setvalues--), [whereValues()](wherevalues--)\nand [havingValues()](havingvalues--)\n\n## Where Next?\n\nIn the next section we'll look at [tables](manual/tables.html) which provide\nmethods to automatically generate queries to insert, update, fetch and delete\nrows.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/tables.md",
    "name": "./manual/tables.md",
    "content": "# Tables\n\nIt can quickly get tedious if you've got to write lots of different\nqueries for trivial operations like inserting, updating, selecting\nand deleting rows.\n\nIn this example we introduce table objects.  This allows you\nto specify the columns in each table and use higher level methods to\nautomatically insert, update, fetch and delete rows from the table.\n\nHere's a simple example. Note that we're using the same database from\nthe previous examples and assuming that the `users` table has already\nbeen created.\n\n```js\n// define the users table and the columns it contains\nconst db = connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n    }\n  }\n});\n```\n\nThe database `table()` method is used to fetch a table object, using\nthe name that you defined for it.  Note that it's an asynchronous\nfunction that returns a promise so you have to `await` it or use\n`.then()`.\n\n```js\n// fetch the users table\nconst users = await db.table('users');\n```\n\nThe name that you use for the table in your application (e.g. `users` in\nthis example) doesn't necessarily have to match the table name in the database.\nIf you want to refer to a table in your application using a plural name as\nI typically do (e.g. `users`, `products`, etc.) but the underlying database\ntable is named in the singular (e.g. `user`, `product`) then you can use the\n`table` option to set the database table name.\n\n```js\nconst db = connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {                // app code refers to table as \"users\"...\n      table:   'user',      // ...but the actual table name is \"user\"\n      columns: 'id name email'\n    }\n  }\n});\n```\n\nAny generated queries will use the database table name (e.g. `user` in this\nexample), rather than the name that you assigned to refer to the table\ncollection (e.g. `users`).  If you don't define the `table` option then\nit defaults to using the name you're indexing it by in `tables` (e.g. `users`).\n\nThere is no general consensus about whether tables should be named using the\n[singular or plural noun](https://stackoverflow.com/questions/338156/table-naming-dilemma-singular-vs-plural-names).  Most of the databases that\nI've worked with (some designed by me, some by other people) use singular\nnames.  The argument goes that it makes more sense when writing a\nquery, e.g. `...WHERE user.id = ?`, although the opposite case is also\ntrue when selecting from a table, e.g. `SELECT ... FROM users`.\n\nIn my application code I generally prefer to use plural names for the tables\nbecause they're conceptually a collection. So my tables will be defined as\n`users`, `products`, etc., even if the database table names are in the singular.\nThe same is true if I'm defining custom [table classes](manual/table_class.html)\nwhich will usually be in the plural (e.g. `Table/Users.js`, `Table/Products.js`).\nFor [record classes](manual/record_class.html) I use the singular as they\nrepresent a single record (e.g. `Record/User.js`, `Record/User.js`).\n\nHowever, you don't have to follow this convention and you can define your\ntables and records any way you like.\n\n## Insert, Update, Fetch and Delete\n\nThe table object provides methods to insert, update, fetch and delete\nrows.  These methods all accept one or more objects specifying the data\nthat you want to use.\n\n```js\nawait users.insert({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n\nawait users.update(\n  { name: 'Brian \"The Brains\" Badger' },  // set...\n  { email: 'brian@badgerpower.com' }      // where...\n);\n\nconst rows = await users.fetch({\n  email: 'brian@badgerpower.com'\n});\n\nawait users.delete({\n  email: 'brian@badgerpower.com'\n});\n```\n\nNote that we use `fetch()` rather than `select()` to fetch rows out of the database.\nThe `fetch()` method(s) generate queries based on the selection criteria that you pass\nan argument.  The [select()](manual/table_queries.html#query-builder) method (which\nthe `fetch()` method uses) is used to generate custom queries using the\n[query builder](manual/query_builder.html).\n\n```js\n// using fetch() - specify the selection criteria\nconst rows = await users.fetch({\n  email: 'brian@badgerpower.com'\n});\n// equivalent using select() - selection criteria are added via where()\nconst rows = await users.select().where({\n  email: 'brian@badgerpower.com'\n});\n```\n\nThe `insert()`, `update()`, `fetch()` and `delete()` methods have variants\nfor the cases where you're operating on a single row or multiple rows.\n\nFor example, the [insert()](manual/table_methods.html#insert-data--options-)\nmethod will call [insertOne()](manual/table_methods.html#insertone-data--options-)\nif you pass it an object as the first parameter, or\n[insertAll()](manual/table_methods.html#insertall-array--options-)\nif you pass it an array.  You can call the methods directly if you prefer.\n\n```js\n// insert a single row\nawait users.insertOne(\n  { name:  'Bobby Badger', email: 'bobby@badgerpower.com' }\n);\n// insert multiple rows\nawait users.insertAll([\n  { name:  'Bobby Badger', email: 'bobby@badgerpower.com' }\n  { name:  'Brian Badger', email: 'brian@badgerpower.com' }\n]);\n```\n\nThe [update()](manual/table_methods.html#update-set--where--options-) method\nis an alias for [updateAll()](manual/table_methods.html#updateall-set--where--options-).\nYou can call also call the [updateAny()](manual/table_methods.html#updateany-set--where--options-)\nmethod if you're expecting to update zero or one row,\nor [updateOne()](manual/table_methods.html#updateone-set--where--options-) if you're expecting\nto update exactly one row.  Both of these methods provide additional assertions to check\nthat the expected number of rows were updated (zero or one in the case of `updateAny()`, or\nexactly one row in the case of `updateOne()`).\n\nThe [fetch()](manual/table_methods.html#fetch-where--options-) method\nis an alias for [fetchAll()](manual/table_methods.html#fetchall-where--options-).\nThis returns an array of matching rows.  You can call also call the\n[fetchAny()](manual/table_methods.html#fetchany-where--options-) method which will return a\nsingle row if it exists or `undefined` if it doesn't. The\n[fetchOne()](manual/table_methods.html#fetchone-where--options-) method returns a single\nrow if it exists and will throw an error if the row isn't found or multiple rows are returned.\n\nThe insert and fetch methods also have variants that return rows as [record](manual/records.html)\nobjects.\n\n## Table Queries\n\nYou can also define table specific named queries, either as static SQL or\nusing the [query builder](manual/query_builder.html).  The table automatically\nprovides some pre-defined [query fragments](manual/query_fragments.html) to\nembed into queries (`<table>` and `<columns>`) and has some shortcuts that\ncan be used with the query builder, e.g. `.fetch` which automatically selects\nall the table columns and defines the table name.\n\n```js\nconst db = connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n      queries: {\n        selectByName:\n          // SQL query including table-specific fragments\n          'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE name = ?',\n        selectByEmail:\n          // query builder with email value to be supplied\n          t => t.select().where('email'),\n        allBadgers:\n          // query builder with pre-defined values\n          t => t.select().where({ animal: 'Badger' })\n      }\n    },\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n\n// calling named queries\nconst user1 = await users.one('selectByName', ['Bobby Badger']);\nconst user2 = await users.any('selectByEmail', ['brian@badgerpower.com']);\nconst user3 = await users.all('allBadgers');\n```\n\n## Where Next?\n\nIn the next few sections we'll look at how [table columns](manual/table_columns.html)\nare defined, the [table methods](manual/table_methods.html) that are provided, how to\ndefine and use [table queries](manual/table_queries.html), and how\nto define your own custom [table class](manual/table_class.html) where you can put\nadditional functionality relating to a table.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_columns.md",
    "name": "./manual/table_columns.md",
    "content": "# Table Columns\n\nFor simple cases you can define table columns using a whitespace delimited string,\ne.g. `id name email`.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id name email'\n    }\n  }\n});\nconst users = await db.table('users');\n```\n\nYou don't have to include all of the columns in the database table if you don't\nwant to for some reason.  If there are columns that you don't want or need to\naccess from your application code then you can omit them.  Just be warned that\nyou won't be able to access any columns that aren't defined here.\n\n## Column Flags\n\nYou can add flags to the column names.  These include `id` to denote the unique\nidentifier (this is optional if the column is already called `id` as we assume\nthat's the default name for the id column), `required` to indicate\nthat a column must be provided when a row is inserted, `readonly` to indicate\nthat a column cannot be inserted or updated, and `fixed` to indicated that the\ncolumn can be inserted but then can't be updated.  Multiple flags can be added,\neach separated by a colon.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id:readonly name:required email:required:fixed'\n    }\n  }\n});\n```\n\nIf you try to insert a row without providing any of the `required` columns\nthen an error will be throw.\n\n```js\n// Throws a ColumnValidationError: 'Missing required column \"email\" for the users table'\nawait users.insert({\n  name: 'Brian Badger',\n});\n```\n\nThe same thing will happen if you try to insert or update a `readonly` column.\n\n```js\n// Throws a ColumnValidationError: 'The \"id\" column is readonly in the users table'\nawait users.insert({\n  id:    999,\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com',\n});\n```\n\nIf a column is marked as `fixed` then you can insert it, but not update it.\n\n```js\n// Throws a ColumnValidationError: 'The \"email\" column is fixed in the users table'\nawait users.update(\n  { email: 'brian-the-badger@badgerpower.com' },\n  { id: 999 }\n);\n```\n\nThere may be times when you want to insert rows with pre-defined ids.  That's fine -\nyou don't have to define your id column as being `readonly` in this case.  However, you\nmight want to mark it as `fixed` so that it's not possible to update at any point in\nthe future.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'id:fixed name:required email:required'\n    }\n  }\n});\nconst users = await db.table('users');\n\n// This is fine - id isn't readonly\nawait users.insert({\n  id:    999,\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com',\n});\n```\n\nIf your unique ID column isn't called `id` then you can mark the relevant column\nusing the `id` tag.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: 'user_id:readonly:id name:required email:required'\n    }\n  }\n});\n```\n\nIn the rare cases where you don't have a unique id column and instead you have multiple\nkeys that are used to uniquely identify a row then you can mark them with the `key` tag.\nFor example, you might have an `employee` table which has rows that are uniquely identified\nby the `company_id` and `user_id` columns.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    employees: {\n      columns: 'company_id:key user_id:key job_title'\n    }\n  }\n});\n```\n\nNote that some databases (e.g. Sqlite) will automatically create an `id` for each\nrow regardless.  There certainly are valid cases where you might chose to NOT have\na unique id column in a database but they are generally few and far between.\nSee [this Stack Overflow post](https://stackoverflow.com/questions/1207983/in-general-should-every-table-in-a-database-have-an-identity-field-to-use-as-a) for\nfurther enlightenment.\n\n## Expanded Form\n\nDefining the columns using a string is a convenient short hand for simpler\ntables.  The more explicit form is to use an object with the column names as\nkeys.  The corresponding values can be strings containing any flags for the\ncolumns, or an empty string if there aren't any.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: {\n        user_id: 'readonly:id',\n        name:    'required',\n        email:   'required',\n        comment: '',\n    }\n  }\n});\n```\n\nOr you can fully expand them like so:\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tables: {\n    users: {\n      columns: {\n        user_id: {\n          readonly: true,\n          id:       true\n        },\n        name: {\n          required: true\n        }\n        email: {\n          required: true\n        }\n        comment: { }\n      }\n    }\n  }\n});\n```\n\n## Where Next?\n\nIn the section we'll look at the [table methods](manual/table_methods.html)\nwhich are provided to automatically generate queries to insert, update,\nfetch and delete rows.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_methods.md",
    "name": "./manual/table_methods.md",
    "content": "# Table Methods\n\nThe table object provides a number of methods for generating and running\nqueries on table rows.  These use the [table query builder](manual/table_queries.html#query-builder)\nto automatically generate and run queries for you based on the data\nyou provide as arguments.\n\nThere are numerous methods that provide minor variations on other methods.  These all\nconform to a naming convention where the first part of the name is the action (e.g.\n`insert`, `update`), followed by the number of rows that it operates on (e.g. `one`,\n`any`, `all`).  The `Row` suffix (e.g. `insertOneRow()`) indicates that that `reload`\noption is automatically set and the method returns the complete row (or rows) reloaded\nfrom the database.  The `Record` suffix (e.g. `insertOneRecord()`) indicates that\nthe `record` option is automatically set and the methods reloads the row (or rows)\nand returns it as a [record](manual/records.html) object (or array or objects).\n\n* [Insert Methods](#insert-methods)\n  * [insert(data, options)](#insert-data--options-)\n  * [insertOne(data, options)](#insertone-data--options-)\n  * [insertAll(array, options)](#insertall-array--options-)\n  * [insertOneRow(data, options)](#insertonerow-data--options-)\n  * [insertAllRows(array, options)](#insertallrows-array--options-)\n  * [insertOneRecord(data, options)](#insertonerecord-data--options-)\n  * [insertAllRecords(array, options)](#insertallrecords-array--options-)\n* [Update Methods](#update-methods)\n  * [update(set, where, options)](#update-set--where--options-)\n  * [updateOne(set, where, options)](#updateone-set--where--options-)\n  * [updateAny(set, where, options)](#updateany-set--where--options-)\n  * [updateAll(set, where, options)](#updateall-set--where--options-)\n  * [updateOneRow(set, where, options)](#updateonerow-set--where--options-)\n  * [updateAnyRow(set, where, options)](#updateanyrow-set--where--options-)\n* [Delete Method](#delete-method)\n  * [delete(where)](#delete-where-)\n* [Fetch Methods](#fetch-methods)\n  * [fetch(where, options)](#fetch-where--options-)\n  * [fetchOne(where, options)](#fetchone-where--options-)\n  * [fetchAny(where, options)](#fetchany-where--options-)\n  * [fetchAll(where, options)](#fetchall-where--options-)\n  * [fetchOneRecord(where, options)](#fetchonerecord-where--options-)\n  * [fetchAnyRecord(where, options)](#fetchanyrecord-where--options-)\n  * [fetchAllRecords(where, options)](#fetchallrecords-where--options-)\n* [Record Methods](#record-methods)\n  * [loaded(row, options)](#loaded-row--options-)\n  * [record(row)](#record-row-)\n  * [records(rows)](#records-rows-)\n\nAs per the previous examples, we'll assume the table definition looks\nsomething like this:\n\n```js\n// define the users table and the columns it contains\nconst db = connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name:required email:required'\n    }\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n```\n\n## Insert Methods\n\n### insert(data, options)\n\nThe `insert()` method will construct and run an `INSERT` SQL query to insert a\nrow from the column data that you provide.\n\n```js\nconst result = await users.insert({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\nconsole.log('Rows changed:', result.changes);\nconsole.log('Generated id:', result.id);\n```\n\nThe SQL query generated will look like this for Sqlite and Mysql:\n\n```sql\nINSERT INTO users (name, email)\nVALUES (?, ?)\n```\n\nNote the use of value placeholders `?` to prevent SQL injection attacks.\n\nThe format for placeholders in Postgres is slightly different but has the\nexact same effect:\n\n```sql\nINSERT INTO users (name, email)\nVALUES ($1, $2)\n```\n\nThe result returned from the `insert()` method is an object containing the\nnumber of rows affected as `changes` and the generated id, where applicable in\n`id`.  If you have defined a different id field (e.g. `user_id`) then this will\nbe returned instead.  Other data returned by the database engine may also be\ndefined.\n\nYou can insert multiple rows by passing an array of objects to the method.\n\n```js\nconst results = await users.insert([\n  {\n    name:  'Bobby Badger',\n    email: 'bobby@badgerpower.com'\n  },\n  {\n    name:  'Brian Badger',\n    email: 'brian@badgerpower.com'\n  }\n]);\nconsole.log('Generated id #1:', results[0].id )\nconsole.log('Generated id #2:', results[1].id )\n```\n\nThe return value will be an array of results the same as those returned by\ncalling the method to insert a single row.\n\nIn some cases you may want to immediately fetch the inserted row back out of the\ndatabase.  This can be the case when you have columns with default values that\nwill be generated by the database (e.g. a `created` timestamp) that you want to\ninspect.\n\nYou could easily do it yourself - the `insert()` method will return a result containing\nthe generated `id` (or other id field) which you can then use to fetch the record.\nBut why do it yourself when we can do it for you?  Pass a second argument to the method\nas an object containing the `reload` option set to a true value.\n\nAfter inserting a row the table `insert()` method will immediately reload it from the\ndatabase and return the data for the row.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com'\n  },\n  { reload: true }\n);\nconsole.log(frank.id);      // e.g. 3\nconsole.log(frank.name);    // Frank Ferret\nconsole.log(frank.email);   // frank@ferrets-r-us.com\n```\n\nThe same thing happens if you insert multiple rows and specify the `reload` options.\nThe only difference is that the return value will be an array of rows.\n\n```js\nconst animals = await users.insert(\n  [\n    {\n      name:  'Frank Ferret',\n      email: 'frank@ferrets-r-us.com'\n    },\n    {\n      name:  'Simon Stoat',\n      email: 'simon@stoats-r-superb.com'\n    },\n  ],\n  { reload: true }\n);\nconsole.log(animals.length);        // 2\nconsole.log(animals[0].id);         // e.g. 4\nconsole.log(animals[0].name);       // Frank Ferret\nconsole.log(animals[0].email);      // frank@ferrets-r-us.com\nconsole.log(animals[1].id);         // e.g. 5\nconsole.log(animals[1].name);       // Simon Stoat\nconsole.log(animals[1].email);      // simon@stoats-r-superb.com\n```\n\nAnother option that is supported by the insert methods is `record`.\nThis will reload the row from the database (as per the `reload` option)\nand return it as a record object.  We'll be talking more about\n[records](manual/records.html) shortly but for now you should know that\nit exists.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com'\n  },\n  { record: true }\n);\n// frank is a record object but it still behaves like a row\nconsole.log(frank.id);      // e.g. 3\nconsole.log(frank.name);    // Frank Ferret\nconsole.log(frank.email);   // frank@ferrets-r-us.com\n```\n\nThe final option is `pick`.  If you try and insert data containing fields\nthat aren't defined as table columns then a `ColumnValidationError` error\nwill be throw.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com',\n    feet:  4\n  }\n);\n// -> throws ColumnValidationError: Unknown \"feet\" column in the users table\n```\n\nIf you like to throw caution to the wind then you can specify the `pick` option\nto override this.  With it set to a true value, the method will pick out the\nvalues that are defined as columns and silently ignore everything else.\n\n```js\nconst frank = await users.insert(\n  {\n    name:  'Frank Ferret',\n    email: 'frank@ferrets-r-us.com',\n    feet:  4\n  },\n  { pick: true }\n);\n// -> silently ignores invalid \"feet\" column\n```\n\n### insertOne(data, options)\n\nInternally, the [insert()](#insert-data--options-) method calls either\n`insertAll()`, if the value passed is an array, or `insertOne()`\nif it's a single data object. You can call these methods directly if you prefer.\n\n```js\nconst result = await users.insertOne({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n```\n\n### insertAll(array, options)\n\nHere's an example explicitly calling the `insertAll()` method.  It's exactly the\nsame as calling [insert()](#insert-data--options-) with an array of rows to insert.\n\n```js\nconst results = await users.insertAll([\n  {\n    name:  'Frank Ferret',\n    email: 'frank@badgerpower.com'\n  }\n  {\n    name:  'Simon Stoat',\n    email: 'simon@badgerpower.com'\n  }\n]);\n```\n\n### insertOneRow(data, options)\n\nThis is a wrapper around the [insertOne()](#insertone-data--options-) method\nwhich automatically sets the `reload` option for you.  The result returned\nwill be the inserted row reloaded from the database instead of a result object.\n\n```js\nconst row = await users.insertOneRow({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\nconsole.log(row.id);     // e.g. 123\nconsole.log(row.name);   // Brian Badger\nconsole.log(row.email);  // brian@badgerpower.com\n```\n\nThe `insertRow()` method is provided as an alias for this method.\n\n### insertAllRows(array, options)\n\nThis is a wrapper around the [insertAll()](#insertall-array--options-) method\nwhich automatically sets the `reload` option for you.  The result returned\nwill be an array of rows reloaded from the database instead of an array of results.\n\n```js\nconst rows = await users.insertAllRows([\n  {\n    name:  'Bobby Badger',\n    email: 'bobby@badgerpower.com'\n  },\n  {\n    name:  'Brian Badger',\n    email: 'brian@badgerpower.com'\n  }\n]);\n// array of rows returned\nconsole.log(rows.length);     // 2\nconsole.log(rows[0].id);      // e.g. 123\nconsole.log(rows[0].name);    // Bobby Badger\nconsole.log(rows[0].email);   // bobby@badgerpower.com\nconsole.log(rows[1].id);      // e.g. 124\nconsole.log(rows[1].name);    // Brian Badger\nconsole.log(rows[1].email);   // brian@badgerpower.com\n```\n\nThe `insertRows()` method is provided as an alias for this method.\n\n### insertOneRecord(data, options)\n\nThis is a wrapper around the [insertOne()](#insertone-data--options-) method\nwhich automatically sets the `record` option for you.  The result returned\nwill be a record object instead of a result object.\n\n```js\nconst record = await users.insertOneRecord({\n  name:  'Brian Badger',\n  email: 'brian@badgerpower.com'\n});\n// a record object still behaves like a row\nconsole.log(record.name);   // Brian Badger\nconsole.log(record.email);  // brian@badgerpower.com\n```\n\nThe `insertRecord()` method is provided as an alias for this method.\n\n### insertAllRecords(array, options)\n\nThis is a wrapper around the [insertAll()](#insertall-array--options-) method\nwhich automatically sets the `record` option for you.  The result returned\nwill be an array of record objects instead of an array of results.\n\n```js\nconst records = await users.insertAllRecords([\n  {\n    name:  'Bobby Badger',\n    email: 'bobby@badgerpower.com'\n  },\n  {\n    name:  'Brian Badger',\n    email: 'brian@badgerpower.com'\n  }\n]);\n// array of records returned, but they behave like rows\nconsole.log(records.length); // 2\nconsole.log(records[0].name);    // Bobby Badger\nconsole.log(records[0].email);   // bobby@badgerpower.com\nconsole.log(records[1].name);    // Brian Badger\nconsole.log(records[1].email);   // brian@badgerpower.com\n```\n\nThe `insertRecords()` method is provided as an alias for this method.\n\n## Update Methods\n\n### update(set, where, options)\n\nThe `update()` method, as the name suggests, allows you to update rows.\nIt is an alias for the [updateAll()](#updateall-set--where--options-) method.\n\n```js\nawait users.update(\n  { name: 'Brian \"The Brains\" Badger' },  // SET...\n  { email: 'brian@badgerpower.com' }      // WHERE...\n);\n```\n\nThe first argument is an object containing the changes you want to make.\nThe second optional argument is the `WHERE` clause identifying the rows\nyou want to update.  You can omit the second argument if you want to update\nall rows.\n\nThe SQL generated for the method call shown above will look something like this:\n\n```sql\nUPDATE users\nSET    name=?\nWHERE  email=?\n```\n\nAgain, the format for Postgres is slightly different, using `$1` and `$2` for\nplaceholders instead of `?`, but works exactly the same.\n\nIf you want to use comparison operators (other than the default `=`) in the\n`WHERE` clause then specify the value as an array of `[operator, value]`.\n\nFor example, to update all rows where the email address isn't `brian@badgerpower.com`\n(I know, I know, this is a terrible example), then you could write:\n\n```js\nawait users.update(\n  { name: \"He's not the Messiah, he's a very naughty boy\" },\n  { email: ['!=', 'brian@badgerpower.com'] }\n);\n```\n\nThe SQL generated for this example will look something like this:\n\n```sql\nUPDATE users\nSET    name=?\nWHERE  email!=?\n```\n\nAny single value SQL operator can be used, e.g. `=`, `!=`, `<`, `<=`, `>`, `>=`.\nYou can't use operators that expect lists of values, e.g. `in (...)`.\n\nThis method, and the other update methods, will throw a `ColumnValidationError`\nif you specify a column in either the `set` or `where` data that isn't defined\nas a table column.  The `pick` option can be used to override this.  When set,\nthe methods will pick out the data items that do have table column definitions\nand silently ignore the rest.\n\n```js\nawait users.update(\n  // \"feet\" is not a valid column, but the pick\n  // option tells the method to ignore it\n  { name: 'Brian \"The Brains\" Badger', feet: 4 },\n  { email: 'brian@badgerpower.com' },\n  { pick: true }\n);\n```\n\nA `ColumnValidationError` will also be thrown if you attempt to update a column\nthat is marked as `readonly` or `fixed`.\n\n### updateOne(set, where, options)\n\nThis is a variant of the [update()](#update-set--where--options-) /\n[updateAll()](#updateall-set--where--options-) method that has an\nadditional assertion check that exactly one row is updated.  If zero or more\nrows are updated then an `UnexpectedRowCount` error will be thrown with a\nmessage of the form `N rows were updated when one was expected`.\n\nThis method also supports the `reload` option.  When set, the method will\nautomatically reload the row from the database after performing the update.\nThis can be useful if you've got a column which is automatically set when the\nrecord is updated, e.g. a `modified` column, which you want to inspect.\n\n```js\nconst row = await users.updateOne(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nconsole.log('updated row:', row);\n```\n\nThe `where` clause defaults to using the equality operator, `=`, but as described\nin the [update()](#update-set--where--options-) method, you can use other comparison\noperators by specifying the value as an an array, e.g. `{ year: ['>', 2000] }`\nto match all records where the `year` is greater than `2000`.\n\nOne thing to note: this uses the modification and selection criteria specified\nto reload the data.  If, for example, you change the email address of a row\nthen it will correctly reload the record using the new email address.\n\n```js\nconst row = await users.updateOne(\n  { email: 'brian-badger@badgerpower.com' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nconsole.log('new email address:', row.email); // brian-badger@badgerpower.com\n```\n\nHowever, there are edge cases where it's not possible to reload the same row that\nwas modified, based on the criteria provided.  Consider this somewhat contrived\nexample: if the users table has a `friends` column and there is exactly one record\nwhere the `friends` count is set to `0`.  You feel sorry for the poor user and\ndecide to modify their `friends` count to be `1`.  You'll be their friend, right?\n\n```js\nawait users.updateOne(\n  { friends: 1 },\n  { friends: 0 },\n  { reload: true }\n);\n```\n\nWhile there may have been exactly one user with `friends` set to `0` *before*\nthe update, once the update has been applied there may be multiple rows which have\nthe `friends` count set to `1`.  The reload will fail with an `UnexpectedRowCount`\nerror.  In these cases you should always provide some other unique attribute to ensure\nthat the correct row can be identified and reloaded:\n\n```js\nawait users.updateOne(\n  { friends: 1 },\n  { email: 'bobby@badger.com' },\n  { reload: true }\n);\n```\n\n### updateAny(set, where, options)\n\nThis is a variant of the [update()](#update-set--where--options-) /\n[updateAll()](#updateall-set--where--options-) method that has an\nadditional assertion check that no more than one row is updated.  If more\nthan one rows are updated then an `UnexpectedRowCount` error will be thrown\nwith a message of the form `N rows were updated when one was expected`.\n\nThis also supports the `reload` option.  If a row is updated then the complete\nrow data will be returned.  Otherwise it will return `undefined`.\n\n```js\nconst row = await users.updateAny(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n  { reload: true }\n);\nif (row) {\n  console.log(\"updated row:\", row);\n}\nelse {\n  console.log(\"could not update row - Brian not found!\")\n}\n```\n\nYou can also use other comparison operator as per the [update()](#update-set--where--options-)\nmethod, e.g. `{ year: ['>', 2000] }` to match all records where the `year` is greater\nthan `2000`.\n\n### updateAll(set, where, options)\n\nThe [update()](#update-set--where--options-) method is an alias for the\n`updateAll()` method.  If you want additional checks to be performed to\nensure that you're only updating one row, or if you want to automatically\nreload a row after an update then you can use the\n[updateOne()](#updateone-set--where--options-) or\n[updateAny()](#updateany-set--where--options-) methods.\n\n### updateOneRow(set, where, options)\n\nThis is a wrapper around the [updateOne()](#updateone-set--where--options-) method\nwhich automatically sets the `reload` option for you.  The result returned\nwill be the updated row reloaded from the database instead of a result object.\n\n```js\nconst row = await users.updateOneRow(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n);\nconsole.log('updated row:', row);\n```\n\nThe `updateRow()` method is provided as an alias for this method.\n\n### updateAnyRow(set, where, options)\n\nThis is a wrapper around the [updateAny()](#updateany-set--where--options-) method\nwhich automatically sets the `reload` option for you.  The result returned\nwill be the updated row reloaded from the database instead of a result object.\n\n```js\nconst row = await users.updateAnyRow(\n  { name: 'Brian \"The Brains\" Badger' },\n  { email: 'brian@badgerpower.com' },\n);\nif (row) {\n  console.log(\"updated row:\", row);\n}\nelse {\n  console.log(\"could not update row - Brian not found!\")\n}\n```\n\n## Delete Method\n\n### delete(where)\n\nYou can probably guess what the `delete()` method does.\n\n```js\nawait users.delete({\n  email: 'brian@badgerpower.com'\n});\n```\n\nThe object passed as the only argument identifies the rows that you want to delete.\n\nThe SQL generated will look something like this:\n\n```sql\nDELETE FROM users\nWHERE email=?\n```\n\nYou can omit the selection criteria if you want to delete all rows in the table.\n\n```js\nawait users.delete()\n```\n\nNaturally, you should use this method with caution.\n\nYou can also use other comparison operator in the `where` clause, as per the\n[update()](#update-set--where--options-) method, e.g. `{ year: ['>', 2000] }`\nto match all records where the `year` is greater than `2000`.\n\nIf you include any columns in the `where` specification that aren't recognised\nas table columns then the method will throw a `ColumnValidationError`.  Use the\n`pick` option to override this behaviour.\n\n```js\nawait users.delete(\n  // \"feet\" is not a valid table column, but the\n  // pick option tells the method to ignore it\n  { email: 'brian@badgerpower.com', feet: 4 },\n  { pick: true }\n);\n```\n\n## Fetch Methods\n\n### fetch(where, options)\n\nThere are three different methods for fetching rows from the table using\nselection criteria.  The [fetchOne()](#fetchone-where--options-) method is\nused when you're expecting to get exactly one row returned. The\n[fetchAny()](#fetchany-where--options-) method is for when you're expecting\nto get a single row that may or may not exist.  The\n[fetchAll()](#fetchall-where--options-) method returns an array of all matching\nrows that may be zero or more.\n\nThe `fetch()` method is an alias for the [fetchAll()](#fetchall-where--options-)\nmethod.\n\nAll of the methods will throw a `ColumnValidationError` if you specify a data\nitem in the `where` criteria that isn't defined as a table column.  Use the `pick`\noption to override this behavious, as per the [insert()](#insert-data--options-),\n[update()](#update-set--where--options) and [delete()](#delete-where-) methods.\n\n### fetchOne(where, options)\n\nThe `fetchOne()` method will return a single row.\nIf the row isn't found or multiple rows match the criteria then an\n`UnexpectedRowCount` error will be thrown with a message of\nthe form `N rows were returned when one was expected`.\n\n```js\n// returns a single row or throws an error\nconst brian = await users.fetchOne({\n  email: 'brian@badgerpower.com'\n});\nconsole.log('Brian:', brian);\n```\n\nThe `where` clause default to using the equality operator, `=`, but like the\n[update()](#update-set--where--options-) and [delete()](#delete-where-) methods,\nyou can use other comparison operators, e.g. `{ year: ['>', 2000] }` to match\nall records where the `year` is greater than `2000`.\n\nYou can pass a second argument which can contain various options to modify\nthe selection.  For example, the `columns` option can be used to specify\nthe columns that you want to select.  They can be specified as a string\ncontaining the columns names separated by whitespace:\n\n```js\nconst brian = await users.fetchOne(\n  { email: 'brian@badgerpower.com' },\n  { columns: 'id name' }\n);\n```\n\nOr as an array:\n\n```js\nconst brian = await users.fetchOne(\n  { email: 'brian@badgerpower.com' },\n  { columns: ['id', 'name'] }\n);\n```\n\nThe `record` option can be specified if you want the data returned as a\n[record](manual/record.html) instead of a row.\n\n```js\nconst brian = await users.fetchOne(\n  { email: 'brian@badgerpower.com' },\n  { record: true }\n);\n```\n\nThe generated SQL for this method (and also [fetchAny()](#fetchany-where--options-)\nand [fetchAll()](#fetchall-where--options-) will look something like this:\n\n```sql\nSELECT \"users\".\"id\", \"users\".\"name\" FROM users\nWHERE email=?\n```\n\n### fetchAny(where, options)\n\nThe `fetchAny()` method will return a single row if it exists or `undefined` if it doesn't.\n\n```js\n// returns a single row or undefined\nconst brian = await users.fetchAny({\n  email: 'brian@badgerpower.com'\n});\nif (brian) {\n  console.log('Brian:', brian);\n}\nelse {\n  console.log('Brian Badger was not found');\n}\n```\n\nThe `where` clause default to using the equality operator, `=`, but like numerous\nother methods described above, you can use other comparison operators e.g.\n`{ year: ['>', 2000] }` to match all records where the `year` is greater\nthan `2000`.\n\nAs per [fetchOne()](#fetchone-where--options-) you can pass an additional object\ncontaining options.  For example, to specify the columns you want returned:\n\n```js\nconst brian = await users.fetchAny(\n  { email: 'brian@badgerpower.com' },\n  { columns: 'id email' }\n);\n```\n\nOr to return the row as a record object:\n\n```js\nconst brian = await users.fetchAny(\n  { email: 'brian@badgerpower.com' },\n  { record: true }\n);\n```\n\n### fetchAll(where, options)\n\nThe `fetchAll()` method will return an array of all matching rows.\n\n```js\n// returns an array of all rows (possibly empty)\nconst bobbies = await users.fetchAll(\n  { name: 'Bobby Badger' }\n);\nif (bobbies.length) {\n  console.log(\"Fetched %s users called 'Bobby Badger':\", bobbies.length);\n}\nelse {\n  console.log(\"There aren't any users called 'Bobby Badger'\");\n}\n```\n\nIf you want to return all matching rows then you can omit the criteria or\nspecify an empty object.\n\n```js\nconst allUsers = await users.fetchAll();\n```\n\n```js\nconst allUsers = await users.fetchAll({ });\n```\n\nIt shouldn't surprise you to learn that you can use other comparison operators\nin the `where` clause, e.g. `{ year: ['>', 2000] }` to match all records where\nthe `year` is greater than `2000`.\n\nAs per [fetchOne()](#fetchone-where--options-) you can pass an additional objects\ncontaining options.  It supports the `columns` and `record` options.  You can\nalso provide `order` (or `orderBy` if you prefer to use a naming convention as\nclose as possible to the SQL equivalent of `ORDER BY`) to specify the order in\nwhich rows should be returned:\n\nThe `order` can contain multiple columns and each will be automatically quoted.\n\n```js\nconst allUsers = await users.fetchAll(\n  { },  // you can specify selection criteria or use an empty object to fetch all rows\n  { order: 'name, id' }   // -> ORDER BY \"name\", \"id\"\n);\n```\n\nIf you want to use a raw SQL order then define it as an object with a single `sql`\nproperty:\n\n```js\nconst allUsers = await users.fetchAll(\n  { },  // you can specify selection criteria or use an empty object to fetch all rows\n  { order: { sql: 'name DESC' } }\n);\n```\n\nOr use the `sql` function to generate it for you from a tagged template literal.\n\n```js\nimport { sql } from '@abw/badger-database'\n\nconst allUsers = await users.fetchAll(\n  { },  // you can specify selection criteria or use an empty object to fetch all rows\n  { order: sql`name DESC` }\n);\n```\n\n### fetchOneRecord(where, options)\n\nThis method is a wrapper around [fetchOne()](#fetchone-where--options-) which returns\nthe row as a record object.  It effectively sets the `record` option for you.\n\nRead more about records [here](manual/records.html).\n\nThe `fetchRecord()` method is provided as an alias for this method.\n\n### fetchAnyRecord(where, options)\n\nThis method is a wrapper around [fetchAny()](#fetchany-where--options-) which returns\nthe row as a record object.\n\n### fetchAllRecords(where, options)\n\nThis method is a wrapper around [fetchAll()](#fetchall-where--options-) which returns\nthe rows as an array of record objects.\n\nThe `fetchRecords()` method is provided as an alias for this method.\n\n## Record Methods\n\n### loaded(row, options)\n\nThis method is called whenever a row is loaded from the database (or reloaded\nin the case of updated rows when the `reload` option is set).  If the\n`options.record` flag is set then it passes the `row` to the\n[record()](#record-row-) method to convert it to a [record](manual/records.html)\nobject.  Otherwise the row is returned.\n\nYou can redefine this method in your own [table classes](manual/table_class.html)\nto perform any processing of the loaded data.  For example, if your database\nstores boolean values as numbers and you want them to be converted to boolean\nvalues whenever a record is loaded then you could do something like this.\n\n```js\nimport { Table } from '@abw/badger-database'\n\nexport class Users extends Table {\n  loaded(row, options) {\n    row.admin  = Boolean(row.admin);\n    return super.loaded(row, options);\n  }\n}\n```\n\nYou should always call the `super.loaded()` method after any processing\nand return the value that it returns, as show in this example.\n\n### record(row)\n\nThis methods converts a row of data to a [record](manual/records.html) object.\n\n### records(rows)\n\nThis methods converts an array of rows of data to a an array of [record](manual/records.html) objects.\n\n## Where Next?\n\nIn the section we'll look at how you can define your own custom\n[table queries](manual/table_queries.html).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_queries.md",
    "name": "./manual/table_queries.md",
    "content": "# Table Queries\n\n* [SQL Queries](#sql-queries)\n* [Named Queries](#named-queries)\n* [Query Fragments](#query-fragments)\n* [Query Builder](#query-builder)\n* [Query Methods](#query-methods)\n  * [run(query, values, options)](#run-query--values--options-)\n  * [one(query, values, options)](#one-query--values--options-)\n  * [any(query, values, options)](#any-query--values--options-)\n  * [all(query, values, options)](#all-query--values--options-)\n  * [oneRow(query, args)](#onerow-query--args-)\n  * [anyRow(query, args)](#anyrow-query--args-)\n  * [allRows(query, args)](#allrows-query--args-)\n  * [oneRecord(query, args)](#onerecord-query--args-)\n  * [anyRecord(query, args)](#anyrecord-query--args-)\n  * [allRecords(query, args)](#allrecords-query--args-)\n  * [sql(query)](#sql-query-)\n\n## SQL Queries\n\nTable objects implement the [run()](#run-query--values--options-),\n[one()](#one-query--values--options-), [any()](#any-query--values--options-)\nand [all()](#all-query--values--options-) method similar to those\ndefined on the main database for running [basic queries](manual/basic_queries.html).\n\n```js\nconst user = await users.one(\n  'SELECT \"name\" FROM \"users\" WHERE id = ?'\n  [12345]\n);\n```\n\n## Named Queries\n\nYou can define [named queries](manual/named_queries.html) in your\ntables. This allows you to scope queries more closely to the table that\nthey relate to, instead of piling everything into the main database\ndefinition.\n\n```js\nconst db = connect({\n  database: 'sqlite://users.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n      queries: {\n        selectNameById:\n          'SELECT \"name\" FROM \"users\" WHERE id = ?'\n      }\n    },\n  }\n});\nconst users = await db.table('users')\nconst user = await users.one(\n  'selectNameById'\n  [12345]\n);\n```\n\n## Query Fragments\n\nYou can define [query fragments](manual/query_fragments.html)\nthat can be embedded in your named queries or arbitrary SQL\nqueries.\n\n```js\nconst db = connect({\n  database: 'sqlite://users.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n      fragments: {\n        selectName:\n          'SELECT \"name\" FROM \"users\"'\n      }\n      queries: {\n        selectNameById:\n          '&lt;selectName&gt; WHERE id = ?'\n      }\n    },\n  }\n});\nconst users = await db.table('users')\n\n// named query with embedded fragments\nconst user1 = await users.one(\n  'selectNameById'\n  [12345]\n);\n\n// embed fragments directly into SQL query\nconst user2 = await users.one(\n  '&lt;selectName&gt; WHERE email = ?'\n  ['bobby@badgerpower.com']\n);\n```\n\nThe table pre-defines two fragments for each table: `<table>` is the quoted\ntable name (e.g. `\"users\"`) and `<columns>` is a list of all the columns\nin the table, scoped to the table name with both parts properly quoted\n(e.g. `\"users\".\"id\", \"users\".\"name\", \"users\".\"email\"`).\n\nThis allows you to write more succinct named queries where you want to include\nall the columns:\n\n```js\nconst db = connect({\n  database: 'sqlite://users.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n      queries: {\n        selectById:\n          'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE id = ?'\n      }\n    },\n  }\n});\nconst users = await db.table('users')\n\n// named query with embedded fragments\nconst user1 = await users.one(\n  'selectById'\n  [12345]\n);\n\n// embed fragments directly into SQL query\nconst user2 = await users.one(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE email = ?'\n  ['bobby@badgerpower.com']\n);\n```\n\nYou can also use any named queries or query fragments defined in the database\nconfiguration.  Queries defined in the database that include fragment references\nwill first try to resolve those fragments from the table definition before looking\nfor them in the database.\n\nFor example, that allows you to define a query or fragment in the database that\nincludes the `<columns>` or `<table>` fragments.  When the query is expanded it\nwill include the correct columns and table name for the table.\n\n```js\nconst db = connect({\n  database: 'sqlite://users.db',\n  fragments: {\n    allColumns: 'SELECT &lt;columns&gt; FROM &lt;table&gt;',\n    byId:       'WHERE id = ?'\n  },\n  tables: {\n    users: {\n      columns: 'id name email'\n      queries: {\n        selectById:\n          '&lt;allColumns&gt; &lt;byId&gt;'\n      }\n    },\n  }\n});\nconst users = await db.table('users')\nconsole.log( users.sql('selectById') )\n// -> SELECT \"users\".\"id\", \"users\".\"name\", \"users\".\"email\"\n//    FROM \"users\"\n//    WHERE id = ?\n```\n\n## Query Builder\n\nYou can use the [query builder](manual/query_builder.html) to generate\nqueries.  The `build` property contains a query builder node that you\ncan build queries on.\n\n```js\nconst byEmail = users\n  .build\n  .select('id name')\n  .from('users')\n  .where('email')\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    WHERE \"email\" = ?\nconst user = await byEmail.one(['bobby@badgerpower.com'])\n```\n\nThe `select()` method is a short hand which automatically selects the current\ntable (i.e. it calls `from(table.name)`) for you.  You can specify the columns\nthat you want to select as arguments.\n\n```js\nconst byEmail = users\n  .select('id name')\n  .where('email')\n// -> SELECT \"id\", \"name\"\n//    FROM \"users\"\n//    WHERE \"email\" = ?\nconst user = await byEmail.one(['bobby@badgerpower.com'])\n```\n\nIf you don't specify any columns to select then it will automatically select\nall columns.\n\n```js\nconst byEmail = users\n  .select()\n  .where('email')\n// -> SELECT \"id\", \"name\", \"email\"\n//    FROM \"users\"\n//    WHERE \"email\" = ?\nconst user = await byEmail.one(['bobby@badgerpower.com'])\n```\n\nYou can pass a query constructed using the query builder as the first argument\nto the [run()](#run-query--values--options-), [one()](#one-query--values--options-),\n[any()](#any-query--values--options-) or [all()](#all-query--values--options-) methods.\n\n```js\nconst user = await users.one(byEmail, ['bobby@badgerpower.com'])\n```\n\nYou can use the query builder to generate named queries.  The query\nshould be defined as a function that will receive a reference to the\ntable object and should return the query builder chain.\n\n```js\nconst db = connect({\n  database: 'sqlite://users.db',\n  tables: {\n    users: {\n      columns: 'id name email'\n      queries: {\n        selectByEmail:\n          // using the query builder with a placeholder for email\n          t => t.select().where('email'),\n        allBadgers:\n          // using the query builder with pre-defined values\n          t => t.select().where({ animal: 'Badger' })\n      }\n    },\n  }\n});\nconst users = await db.table('users');\nconst user1 = await db.one(\n  'selectByEmail',\n  ['bobby@badgerpower.com']\n);\nconst badgers = await db.all(\n  'allBadgers'\n);\n```\n\n## Query Methods\n\n### run(query, values, options)\n\nThis is a low-level method for running a named query, or indeed\nany arbitrary SQL query, where you're not expecting to fetch any rows.\n\nIt's just like the [run()](manual/basic_queries.html#run-query--values--options-)\nmethod on the database object.  The only difference is that the table-specific\nfragments for `<table>` and `<columns>` are pre-defined.\nAny other `fragments` that you've specified in your table definition\nwill also be available.\n\nAs a trivial example, you can embed the `<table>` fragment in a query like this:\n\n```js\nusers.run('DROP TABLE &lt;table&gt;')\n```\n\nOr you could define that as a named query called `drop` which you could run\nlike so:\n\n```js\nusers.run('drop')\n```\n\n### one(query, values, options)\n\nThere are three different methods for selecting rows from the table using\nSQL queries or named queries.  The `one()` method will return a single row.\nIf the row isn't found or multiple rows match the criteria then an\n`UnexpectedRowCount` error will be thrown with a message of\nthe form `N rows were returned when one was expected`.\n\nYou can call a named query by specifying the name as the\nfirst argument, followed by an array of any placeholder values.\n\n```js\n// returns a single row or throws an error\nconst bobby = await users.one(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\nYou can also use a raw SQL query string in place of a named query.\n\n```js\n// returns a single row or throws an error\nconst bobby = await users.one(\n  'SELECT * FROM users WHERE email = ?',\n  ['bobby@badgerpower.com']\n);\n```\n\nA SQL query can include references to query fragments.\n\n```js\nconst bobby = await users.one(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE email = ?',\n  ['bobby@badgerpower.com']\n);\n```\n\nYou can pass a third argument which can contain the `record` option if you\nwant the data returned as a [record](manual/record.html) instead of a row.\n\n```js\nconst brian = await users.one(\n  'selectByEmail', ['bobby@badgerpower.com'],\n  { record: true }\n);\n```\n\n### any(query, values, options)\n\nThe `any()` method is like [one()](#one-query--values--options-)\nbut will return a single row if it exists or `undefined` if it doesn't.\n\n```js\n// returns a single row or undefined\nconst bobby = await users.any(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\nif (bobby) {\n  console.log('Bobby:', bobby);\n}\nelse {\n  console.log('Bobby Badger was not found');\n}\n```\n\nYou can can use a SQL query string in place of a named query and this\ncan include query fragments.\n\n```js\nconst bobby = await users.any(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE email = ?',\n  ['bobby@badgerpower.com']\n);\n```\n\nYou can also pass an additional object containing the `record` option to\nreturn the row as a record object.\n\n```js\nconst bobby = await users.any(\n  'selectByEmail', ['bobby@badgerpower.com']\n  { record: true }\n);\n```\n\n### all(query, values, options)\n\nThe `all()` method will return an array of all matching rows.\n\n```js\n// returns an array of all rows (possibly empty)\nconst badgers = await users.all(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\nif (badgers.length) {\n  console.log(\"Fetched %s Bobby Badger records':\", badgers.length);\n}\nelse {\n  console.log(\"There aren't any badgers with that email address\");\n}\n```\n\nYou can can use a SQL query string in place of a named query and this\ncan include query fragments.\n\n```js\nconst badgers = await users.all(\n  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE animal=?',\n  ['Badger']\n);\nif (badgers.length) {\n  console.log(\"Fetched %s badgers':\", badgers.length);\n}\nelse {\n  console.log(\"There aren't any badgers\");\n}\n\n```\n\nYou can also pass an additional object containing the `record` option to\nreturn the rows as an array of record objects.\n\n```js\nconst brian = await users.all(\n  'selectByEmail', ['bobby@badgerpower.com']\n  { record: true }\n);\n```\n\n### oneRow(query, args)\n\nThis method is a multiplexer around\n[one()](#one-query--values--options-)\nand\n[fetchOne()](manual/table_methods#fetchone-where--options-).  If the first argument\nis a string or query builder object then it calls `one()`\notherwise it calls `fetchOne()`.\n\n```js\n// same as users.one()\nconst row = await users.one(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchOne()\nconst row = await users.one(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n### anyRow(query, args)\n\nThis method is a multiplexer around\n[any()](#any-query--values--options-)\nand\n[fetchAny()](manual/table_methods#fetchany-where--options-).  If the first argument\nis a string or query builder object then it calls `any()`,\notherwise it calls `fetchAny()`.\n\n```js\n// same as users.any()\nconst row = await users.anyRow(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchAny()\nconst row = await users.anyRow(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n### allRows(query, args)\n\nThis method is a multiplexer around\n[all()](#all-query--values--options-)\nand\n[fetchAll()](manual/table_methods#fetchall-where--options-).  If the first argument\nis a string or query builder object then it calls `all()`,\notherwise it calls `fetchAll()`.\n\n```js\n// same as users.all()\nconst rows = await users.allRows(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchAll()\nconst row = await users.allRows(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n### oneRecord(query, args)\n\nThis method is like [oneRow()](#onerow-query--args-) but returns the row as a record.\n\n```js\n// same as users.one() with the record option\nconst row = await users.oneRecord(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchOne() with the record option\nconst row = await users.oneRecord(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n### anyRecord(query, args)\n\nThis method is like [anyRow()](#anyrow-query--args-) but returns the row as a record.\n\n```js\n// same as users.any() with the record option\nconst row = await users.anyRecord(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchAny() with the record options\nconst row = await users.anyRecord(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n### allRecords(query, args)\n\nThis method is like [allRows()](#allrows-query--args-) but returns the rows as an\narray of records.\n\n```js\n// same as users.all() with the record option\nconst rows = await users.allRecords(\n  'selectByEmail', ['bobby@badgerpower.com']\n);\n```\n\n```js\n// same as users.fetchAll() with the record option\nconst row = await users.allRecords(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\n\n### sql(query)\n\nThis method can be used to view the expanded SQL of a named query or\nraw SQL query with embedded fragment references.\n\n```js\nconsole.log( users.sql('allBadgers') )\n// -> SELECT \"users\".\"id\", \"users\".\"name\", \"users\".\"email\", \"users\".\"animal\"\n//    FROM \"users\"\n//    WHERE \"animal\" = ?\n```\n\n## Where Next?\n\nIn the section we'll show how you can define your own\n[table classes](manual/table_class.html) to help organise larger\nprojects and provide custom table functionality.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/table_class.md",
    "name": "./manual/table_class.md",
    "content": "# Table Class\n\nYou can define your own custom table class for each table in the database.\nThis allows you to add your own methods for performing queries on the table.\nYou should extend the `Table` base class and then define it as the `tableClass`\noption in the table definition.\n\nHere's a complete example.\n\n```js\nimport { connect, Table } from '@abw/badger-database';\n\nexport class Users extends Table {\n  badgers() {\n    // custom method to fetch all badgers\n    return this.allRows({ animal: 'Badger' });\n  }\n}\n\nasync function main() {\n  const db = connect({\n    database: 'sqlite:memory',\n    tables: {\n      users: {\n        // bind in the custom table class\n        tableClass: Users,\n        // column definitions\n        columns: 'id name email animal',\n        // query definitions\n        queries: {\n          create: `\n            CREATE TABLE users (\n              id     INTEGER PRIMARY KEY ASC,\n              name   TEXT,\n              email  TEXT,\n              animal TEXT\n            )`\n        }\n      },\n    }\n  });\n\n  // fetch users table object\n  const users = await db.table('users');\n\n  // run the 'create' query to create the database table\n  await users.run('create');\n\n  // insert some rows\n  await users.insert([\n    {\n      name:   'Bobby Badger',\n      email:  'bobby@badgerpower.com',\n      animal: 'Badger'\n    },\n    {\n      name:   'Brian Badger',\n      email:  'brian@badgerpower.com',\n      animal: 'Badger'\n    },\n    {\n      name:   'Frankie Ferret',\n      email:  'frank@ferret.com',\n      animal: 'Ferret'\n    }\n  ]);\n\n  // now call the custom badgers() method to fetch all badgers\n  const badgers = await users.badgers();\n\n  console.log(badgers.length);    // 2\n  console.log(badgers[0].name);   // Bobby Badger\n  console.log(badgers[1].name);   // Brian Badger\n\n  // disconnect\n  db.disconnect();\n}\n\nmain()\n```\n\n## Table Configuration\n\nYou can define a `configure()` function to your table class\nto provide the configuration options.  It will be passed an\nobject containing any configuration options from the main\nconfiguration for the table.  You can then add in any other\nconfiguration options.\n\nYou can either update the `config` passed in as an argument,\nor create a new configuration based on it.  In the latter case\nyou need to make sure you return the new configuration options\nat the end of the method.\n\n```js\nexport class Users extends Table {\n  configure(config) {\n    config.columns = 'id:readonly name:required email:required animal:required',\n    config.queries = {\n      create: `\n        CREATE TABLE users (\n          id     INTEGER PRIMARY KEY ASC,\n          name   TEXT,\n          email  TEXT,\n          animal TEXT\n        )`\n    }\n  }\n  badgers() {\n    // custom method to fetch all badgers\n    return this.allRows({ animal: 'Badger' });\n  }\n}\n```\n\nWhen you define the `tables` for the database you then only need\nto specify the `tableClass`.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      tableClass: Users,\n    }\n  }\n});\n```\n\nIf you don't have any other table configuration options that you\nwant to specify then you can use a shortcut and point the `users`\ntable directly at your class.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: Users,\n  }\n});\n```\n\n## Where Next?\n\nIn the section we'll look at [records](manual/records.html) which to help organise larger\nprojects and provide custom table functionality.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/records.md",
    "name": "./manual/records.md",
    "content": "# Records\n\nVarious  [table methods](manual/table_methods.html) have the option\nto return a record object instead of a plain Javascript data object\ncontaining the row data.  Or, in the case\n[allRecords()](manual/table_methods.html#allrecords-where--options-) and\nsimilar methods, they return an array of record objects.\n\nThe record object implements a lightweight version of the Active Record\npattern.\n\n```js\nconst record = await users.oneRecord(\n  { email: 'bobby@badgerpower.com' }\n);\n```\n\nThe row data loaded from the database is stored in the `row` property.\nYou can access individual items or the row data as a whole.\n\n```js\nconsole.log(record.row.id);      // e.g. 1\nconsole.log(record.row.name);    // Bobby Badger\nconsole.log(record.row.email);   // bobby@badgerpower.com\nconsole.log(record.row);         // { id: 1, name: 'Bobby Badger', etc. }\n```\n\nTechnically speaking, the methods actually return a Proxy object wrapper\naround a record object (or an array of Proxy objects in the case of\n[allRecords()](manual/table_methods.html#allrecords-where--options-) et al).\nThe purpose of the Proxy object, among other things, is to give you access\nto row data items without needing to specify the `.row` property.\n\n```js\nconsole.log(record.id);          // e.g. 1\nconsole.log(record.name);        // Bobby Badger\nconsole.log(record.email);       // bobby@badgerpower.com\n```\n\nThis makes the record object look and feel just like a row of data, but with\nsome extra benefits.  For example, the [update()](manual/record_methods.html#update-set-)\nmethod allows you to update the record and corresponding row in the database.\n\n```js\nawait record.update({ name: 'Robert Badger' });\nconsole.log(record.name); // Robert Badger\n```\n\nThe Proxy object also gives you easy access to [relations](manual/relations.html)\nthat are defined for the table.  For example, if the `users` table defines `orders`\nas a relation then you can access them as `.orders`;\n\n```js\nconst orders = await record.orders;\n```\n\nNote that any other properties or methods defined for the record will take\npriority.  For example, `record.update` will resolve to the record\n[update()](manual/record_methods.html#update--) method so if you have a\ncolumn called `update` then you must access it as `record.row.update`.\n\n## Where Next?\n\nIn the next few sections we'll look at the [record methods](manual/record_methods.html)\nthat are provided, and how to define your own custom [record class](manual/record_class.html)\nwhere you can put additional functionality relating to a record.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/record_methods.md",
    "name": "./manual/record_methods.md",
    "content": "# Record Methods\n\nA record object is a wrapper around a row of data from a table.\n\nAs per the previous examples, we'll assume the table definition looks\nsomething like this:\n\n```js\n// define the users table and the columns it contains\nconst db = connect({\n  database: 'sqlite://test.db',\n  tables: {\n    users: {\n      columns: 'id name:required email:required'\n    }\n  }\n});\n\n// fetch the users table\nconst users = await db.table('users');\n\n// fetch a record from the users table\nconst record = await users.oneRecord({\n  email: 'bobby@badgerpower.com'\n})\n```\n\n## update(set)\n\nThe `update()` method allows you to update any columns in the row that the record\nrepresents.\n\n```js\nawait record.update({\n  name:  'Robert Badger, Esq.',\n  email: 'robert@badgerpower.com'\n})\n```\n\nThe data will be updated in both the database table row and the record object.\nAny other changes in the database row (e.g. a `modified` column that is set to\nthe current timestamp when a record is modified) will also be reflected in the\nrecord.\n\n```js\nconsole.log(record.name);       // Robert Badger, Esq.\n```\n\n## delete()\n\nThe `delete()` method allows you to delete the row in the table represented by\nthe record.\n\n```js\nawait record.delete();\nconsole.log(record.deleted)     // true\n```\n\nAfter deleting the record the `record.deleted` flag will be set `true`.  Any\nattempt to update the record (or delete it again) will throw a `DeletedRecordError`\nwith a message of the form `Cannot update deleted users record #123`.\n\n## relation(name)\n\nThis method allows you to access relations for a table.  Read more on that in\nthe [relations](manual/relations.html) manual page.\n\nFor example, if your `users` table has a `orders` relation defined then you can\naccess the related record(s) like so:\n\n```js\nconst orders = await record.relation('orders');\n```\n\nThe Proxy wrapper also allows you to access it more succinctly as:\n\n```js\nconst orders = await record.orders;\n```\n\n## Where Next?\n\nIn the next few section we'll look at how you can define your own\ncustom [record class](manual/record_class.html) where you can put\nadditional functionality relating to a record.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/record_class.md",
    "name": "./manual/record_class.md",
    "content": "# Record Class\n\nYou can define your own custom record class for each table in the database.\nThis allows you to add your own methods for performing queries on the record\ndata or other business logic.\n\nYou should extend the `Record` base class and then define it as the `recordClass`\noption in the table definition.\n\nHere's a complete example.\n\n```js\nimport { connect, Record } from '@abw/badger-database';\n\nexport class User extends Record {\n  hello() {\n    return 'Hello ' + this.row.name;\n  }\n}\n\nasync function main() {\n  const db = connect({\n    database: 'sqlite:memory',\n    tables: {\n      users: {\n        // bind in the custom record class\n        recordClass: User,\n        // column definitions\n        columns: 'id name email animal',\n        // query definitions\n        queries: {\n          create: `\n            CREATE TABLE users (\n              id     INTEGER PRIMARY KEY ASC,\n              name   TEXT,\n              email  TEXT,\n              animal TEXT\n            )`\n        }\n      },\n    }\n  });\n\n  // fetch users table object\n  const users = await db.table('users');\n\n  // run the 'create' query to create the database table\n  await users.run('create');\n\n  // insert a row\n  await users.insert({\n    name:   'Bobby Badger',\n    email:  'bobby@badgerpower.com',\n    animal: 'Badger'\n  });\n\n  // fetch a record\n  const user = await users.oneRecord({\n    email: 'bobby@badgerpower.com'\n  })\n\n  // now call the custom hello() method on the record\n  console.log(user.hello());    // Hello Bobby Badger\n}\n\nmain()\n```\n\n## Record Configuration Options\n\nIf you want to pass additional configuration options to the record\nobject then you can define them as the `recordConfig` configuration\noption in the corresponding table configuration.\n\n```js\nconst db = connect({\n  // ...database, etc.\n  tables: {\n    users: {\n      recordClass: User,\n      recordConfig: {\n        hello: 'Hiya'\n      }\n    },\n  }\n});\n```\n\nThe `recordConfig` parameters will then be available in the record\nobject as `this.config`.  For example, we can rewrite the `hello()`\nmethod to use the configuration value for `hello`:\n\n```js\nexport class User extends Record {\n  hello() {\n    return `${this.config.hello || 'Hello'} ${this.row.name}`;\n  }\n}\n```\n\nNow when the `hello()` method is called on a user record object\na different greeting will be returned:\n\n```js\nconsole.log(user.hello());    // Hiya Brian Badger\n```\n\nIf you want to perform any initialisation of the record then you can override\nthe constructor function.  It is passed three arguments: a reference to the\n`table` object, the `row` of data, and any configuration options.  Make sure\nyou call the `super()` constructor before you do anything else.\n\n```js\nexport class User extends Record {\n  constructor(table, row, config={}) {\n    super(table, row, config);\n    this.greeting = config.hello || 'Hello';\n  }\n  hello() {\n    return `${this.greeting} ${this.row.name}`;\n  }\n}\n```\n\n## Where Next?\n\nIn the next section we'll look at how you can define [relations](manual/relations.html)\nbetween different records in your database.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/relations.md",
    "name": "./manual/relations.md",
    "content": "# Relations\n\nRelations are, rather unsurprisingly, at the heart of relational databases.\n\n* [Introduction](#introduction)\n* [Relation Types](#relation-types)\n* [Defining Table Relations](#defining-table-relations)\n* [Fetching Relations](#fetching-relations)\n* [Additional Constraints](#additional-constraints)\n* [The Map Relation](#the-map-relation)\n* [Shorthand Syntax for Defining Relations](#shorthand-syntax-for-defining-relations)\n* [Custom Queries](#custom-queries)\n\n## Introduction\n\nTo demonstrate the concepts we're going to use an overly simple schema for\na music database.  We'll assume that the database tables have already been\ncreated and populated with some sample data.\n\nOne table will store the `artists`.\n\n```sql\nCREATE TABLE artists (\n  id   SERIAL,\n  name TEXT,\n  PRIMARY KEY (id)\n)\n```\n\nAnother will store the albums that they release, including the `year` and `title`.\nNote the `artist_id` which forms a relation to the artist that released the\nalbum.  In this simple example we're going to assume that only one artist can\nrelease an album.  This isn't the case in the real world if you consider things\nlike multi-artist collaborations and compilation albums, but we're just trying\nto demonstrate the basic concepts here, not build the next Spotify.\n\n```sql\nCREATE TABLE albums (\n  id        SERIAL,\n  year      INTEGER,\n  title     TEXT,\n  artist_id INTEGER,\n  PRIMARY KEY (id),\n  FOREIGN KEY (artist_id) REFERENCES artists(id)\n)\n```\n\nA third table will store the tracks on each album, include the track `title`,\nthe `album_id` linking it to the album that it appears on, and the `track_no`\nto indicate it's position in the track listing for the album.  The `bonus`\ncolumn is a boolean value which defaults to false, which is used to indicate\n\"bonus tracks\" that sometime appear on albums.\n\n```sql\nCREATE TABLE tracks (\n  id        SERIAL,\n  title     TEXT,\n  album_id  INTEGER,\n  track_no  INTEGER,\n  bonus     BOOLEAN DEFAULT false,\n  PRIMARY KEY (id),\n  FOREIGN KEY (album_id) REFERENCES albums(id)\n)\n```\n\nThere's a complete working example of this code in the\n[07_musicdb](https://github.com/abw/badger-database-js/tree/master/examples/07_musicdb/example.js)\nsection of the [github repository](https://github.com/abw/badger-database-js).\n\n## Relation Types\n\nThis example demonstrates two basic relation types: the \"many to one\" relation\nthat exists between artists and albums, and the \"one to many\" relation that\nexists between albums and track.\n\nEach artist can release many albums.  But in this simple example we're assuming\nthat an albums can only be released by one artist.  Therefore this is a \"many\nto one\" relation.\n\nEach album can have many tracks, but each track can only appear on a single album.\nTherefore this is a \"one to many\" relation.\n\nThese two relations are given the names `one` and `many`. The `one` relation implies\nthat there is exactly one related record, whereas `many` implies there can be multiple\nrelations, including zero.  If you have a relation that *may* have one related record\nthen you can use the `any` relation.\n\n|Name|Shorthand|Description|\n|-|-|-|\n|one|`from -> table.to`|Exactly one related record|\n|any|`from ~> table.to`|Maybe one related record|\n|many|`from => table.to`|Any number of related records (including zero)|\n|map|`from #> table.to`|Mapping any number of related records (including zero)|\n\nThe final type `map` is a variant of the `many` relation.  Instead of returning an array\nof related records, this relation returns them as an object mapping from the record id\n(or another key of your choosing) to the record (or a value within it).  See\n[The Map Relation](#the-map-relation) below for further information.\n\n## Defining Table Relations\n\nThe relations for each table should be added to the `tables` configuration\nas the `relations` object.  This is what our main database configuration\nshould look like.\n\n```js\nconst musicdb = connect({\n  database: 'postgres://musicdb',\n  tables: {\n    artists: {\n      columns: 'id name',\n      relations: {\n        albums: {\n          type:  'many',\n          from:  'id',\n          to:    'artist_id',\n          table: 'albums',\n        }\n      }\n    },\n    albums: {\n      columns: 'id year title artist_id',\n      relations: {\n        artist: {\n          type:   'one',\n          from:   'artist_id',\n          to:     'id',\n          table:  'artists',\n        },\n        tracks: {\n          type:   'many',\n          from:   'id',\n          to:     'album_id',\n          table:  'tracks',\n          order:  'track_no',\n        }\n      }\n    }\n    tracks: {\n      columns: 'id title album_id track_no bonus',\n      relations: {\n        album: {\n          type:   'one',\n          from:   'album_id',\n          to:     'id',\n          table:  'albums',\n        },\n      }\n    }\n})\n```\n\nThe `artists` table has an `albums` relation which can include many albums.\nThe relation goes from the `id` column on the `artists` table to the\n`artist_id` column on the `albums` table.\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  from:  'id',\n  to:    'artist_id',\n  table: 'albums',\n}\n```\n\nThe `albums` table has two relations.  The `artist` relation is one\nartist with the join going from the `artist_id` column on the `albums`\ntable to the `id` column on the `artists` table.  The `tracks` relation\nis many tracks with the join going from the `id` column on the `tracks`\ntable to the `album_id` column on the `albums` table.  The tracks in\nthis relation should be ordered by the `track_no` column.\n\n```js\n// tables.albums.relations...\nartist: {\n  type:   'one',\n  from:   'artist_id',\n  to:     'id',\n  table:  'artists',\n},\ntracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n}\n```\n\nThe `tracks` table has a single relation for the `album` that it appears on.\nThe join goes from the `album_id` column on the `tracks` table to the `id`\ncolumn on the `albums` table.\n\n```js\n// tables.tracks.relations...\nalbum: {\n  type:   'one',\n  from:   'album_id',\n  to:     'id',\n  table:  'albums',\n},\n```\n\n## Fetching Relations\n\nLet's assume we've got Pink Floyd defined as an artist, and their\nseminal albums \"The Dark Side of the Moon\" and \"Wish You Were Here\"\nhave already been added to the database.\n\nWe can start by fetching an artist record for Pink Floyd.\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist = await artists.oneRecord({ name: 'Pink Floyd' });\n```\n\nThe `relation()` method allows us to fetch all related records in\na relation.  The `albums` relation is defined as a `many` type, so\nit returns an array of records from the `albums` table.\n\n```js\nconst albums = await artist.relation('albums');\nconsole.log(albums[0].title);   // The Dark Side of the Moon\nconsole.log(albums[1].title);   // Wish You Were Here\n```\n\nThe record proxy object allows you to simplify this.  If there's a\nrelation defined for a record then you can access it as a property\nof the record.  Just remember that there's actually a method call\nand database access going on behind the scenes so you have to `await`\nthe result.\n\n```js\nconst albums = await artist.albums;\nconsole.log(albums[0].title);   // The Dark Side of the Moon\nconsole.log(albums[1].title);   // Wish You Were Here\n```\n\nWe can take one of those albums and use the `artist` relation\nto fetch the artist that recorded the album.\n\n```js\nconst dsotm = albums[0];\nconst artist = await dsotm.artist;\nconsole.log(artist.name);   // Pink Floyd\n```\n\nWe can also fetch the tracks on the album.  They will be automatically\nordered by the `track_no` column.\n\n```js\nconst tracks = await dsotm.tracks;\nconsole.log(tracks[0].title);  // Speak to Me / Breathe\nconsole.log(tracks[1].title);  // On the Run\nconsole.log(tracks[2].title);  // Time\nconsole.log(tracks[3].title);  // The Great Gig in the Sky\n// ...etc...\n```\n\nAnd finally, we can go the other way and, for a given track,\nwe can fetch the album that it appears on.\n\n```js\nconst time = tracks[2];\nconst album = await time.album;\nconsole.log(album.title);   // The Dark Side of the Moon\n```\n\n## Additional Constraints\n\nAdditional constraints for a relation can be defined using the\n`where` property.\n\nFor example, we might want to define the `tracks` relation\nto only return tracks that aren't bonus tracks, and define a\nnew `bonus_tracks` relation for those that are.\n\n```js\n// tables.albums.relations...\ntracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n  where:  { bonus: 0 }\n},\nbonus_tracks: {\n  type:   'many',\n  from:   'id',\n  to:     'album_id',\n  table:  'tracks',\n  order:  'track_no',\n  where:  { bonus: 1 }\n}\n```\n\nIf your copy of The Dark Side of the Moon has\n\"Us and Them (Richard Wright Demo)\" and \"Money (Roger Waters Demo)\"\nincluded as bonus tracks (you lucky thing!) then you could fetch them\nlike so.  Assuming, of course, that they're in the database and have\nthe `bonus` columns set to `true` (or `1` which databases treat as the\nsame thing).\n\n```js\nconst bonus = await dsotm.bonus_tracks;\nconsole.log(bonus[0].title);  // Us and Them (Richard Wright Demo)\nconsole.log(bonus[1].title);  // Money (Roger Waters Demo)\n```\n\n## The Map Relation\n\nThe `map` relation is a special case of the `many` relation.  Instead of returning\nan array of matching records, it returns an object mapping each record id to the record.\n\nFor example, if the `albums` relation for the `artists` table returns these records\nfor a particular artist:\n\n```js\n[\n  { id: 123, year: 1973, title: 'The Dark Side of the Moon' },\n  { id: 456, year: 1975, title: 'Wish You Were Here' },\n  { id: 789, year: 1970, title: 'Atom Heart Mother' },\n]\n```\n\nThen the same relation defined as a `map` instead of `many` would return:\n\n```js\n{\n  123: { id: 123, year: 1973, title: 'The Dark Side of the Moon' },\n  456: { id: 456, year: 1975, title: 'Wish You Were Here' },\n  789: { id: 789, year: 1970, title: 'Atom Heart Mother' },\n}\n```\n\nYou can specify an additional `key` which will be used as the object key\ninstead of the record id.  For example, you might want to index the albums\nby year:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'map',\n  from:  'id',\n  to:    'artist_id',\n  table: 'albums',\n  key:   'year',\n}\n```\n\nNow the relation will return:\n\n```js\n{\n  1973: { id: 123, year: 1973, title: 'The Dark Side of the Moon' },\n  1975: { id: 456, year: 1975, title: 'Wish You Were Here' },\n  1970: { id: 789, year: 1970, title: 'Atom Heart Mother' },\n}\n```\n\nYou can also specify a `value` property.  Instead of mapping to the whole record,\nit will extract that value from the record.  So if the relation is defined\nlike this:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'map',\n  from:  'id',\n  to:    'artist_id',\n  table: 'albums',\n  key:   'year',\n  value: 'title',\n}\n```\n\nThen the relation will return:\n\n```js\n{\n  1973: 'The Dark Side of the Moon',\n  1975: 'Wish You Were Here',\n  1970: 'Atom Heart Mother',\n}\n```\n\n## Shorthand Syntax for Defining Relations\n\nIf you've got a simple relation then you can define it as a string\nusing the shorthand syntax.  The general format for the `one` relation is:\n\n```js\nfrom -> table.to\n```\n\nFor an `any` relation it uses a \"squiggly arrow\" instead.\n\n```js\nfrom ~> table.to\n```\n\nFor a `many` relation it uses a \"fat arrow\".\n\n```js\nfrom => table.to\n```\n\nFor a `map` relation it uses a \"hash arrow\" (because another name for a object\nmapping keys to values is a \"hash array\").\n\n```js\nfrom #> table.to\n```\n\nFor example, the `album` relation defined for the `tracks` table looks\nlike this:\n\n```js\n// tables.tracks.relations...\nalbum: {\n  type:   'one',\n  from:   'album_id',\n  to:     'id',\n  table:  'albums',\n},\n```\n\nThat can be shortened to:\n\n```js\nalbum: 'album_id -> albums.id'\n```\n\nSimilarly, the `albums` relation for `artists` can be shortened from\nthis:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  table: 'albums',\n  from:  'id',\n  to:    'artist_id',\n}\n```\n\nTo this:\n\n```js\nalbums: 'id => albums.artist_id'\n```\n\nYou can't specify an `order` or additional `where` constraints using this\nsyntax.  If you need to specify those then you can either use the fully\nexpanded form:\n\n```js\n// tables.artists.relations...\nalbums: {\n  type:  'many',\n  table: 'albums',\n  from:  'id',\n  to:    'artist_id',\n  order: 'year',\n}\n```\n\nOr you can define the shorthand form as the `relation` item and add `order` and/or `where`\nas additional items.\n\n```js\n// tables.artists.relations...\nalbums: {\n  relation: 'id => albums.artist_id',\n  order:    'year',\n}\n```\n\nThe same applies for the `key` and `value` properties that go with the `map` relation.\n\n```js\n// tables.artists.relations...\nalbumsByYear: {\n  relation: 'id #> albums.artist_id',\n  key:      'year',\n  value:    'title',\n}\n```\n\n## Custom Queries\n\nIf you want to define a more complex relation then you can provide your own\n`load` function to take care of it.\n\nFor example, suppose we want to fetch all the album tracks for a particular\nartist, ordered by the album year and then the track number.\n\nWe can define a custom query in the `queries` section of the `artists` table\ndefinition to load the relevant rows:\n\n```js\n// tables.artists...\nqueries: {\n  album_tracks: `\n    SELECT    tracks.*, albums.title as album, albums.year\n    FROM      albums\n    JOIN      tracks\n    ON        tracks.album_id=albums.id\n    WHERE     albums.artist_id=$1\n    ORDER BY  albums.year,tracks.track_no\n  `\n}\n```\n\nThen we can add an `album_tracks` relation in the `relations` section of the same\n`artists` table that looks something like this:\n\n```js\n// tables.artists...\nrelations: {\n  album_tracks: {\n    load: async (record) => {\n      const artists = record.table;\n      const rows = await artists.all(\n        'album_tracks',\n        [record.row.id]\n      )\n      return artists.records(rows);\n    }\n  }\n}\n```\n\nThe `load` function is passed a reference to the current record (an artist\nin this case).  Each record has a reference to the `table` object that it\ncame from.  Through that we can fetch all the relevant rows using the\n`album_tracks` query, passing the current artist id as the value for the\nplaceholder variable.\n\nYou can return the `rows` as they are, but in this example we'll convert them\nto records by calling the `records()` method on the table.  This ensures\nthey're returned as record object in case we want to perform any further\nrecord-based operations on them.\n\nHere's the complete definition for the `artists` table:\n\n```js\n// tables...\nartists: {\n  columns: 'id name',\n  queries: {\n    album_tracks: `\n      SELECT    tracks.*, albums.title as album, albums.year\n      FROM      albums\n      JOIN      tracks\n      ON        tracks.album_id=albums.id\n      WHERE     albums.artist_id=$1\n      ORDER BY  albums.year,tracks.track_no\n    `\n  },\n  relations: {\n    albums: 'id => albums.artist_id',\n    album_tracks: {\n      load: async (record) => {\n        const artists = record.table;\n        const rows = await artists.all(\n          'album_tracks',\n          [record.row.id]\n        )\n        return artists.records(rows);\n      }\n    }\n  }\n```\n\nAnd here's how we can use it.\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist  = await artists.oneRecord({ name: 'Pink Floyd' });\nconst tracks  = await artist.album_tracks;\n\n// we should now have all the tracks from The Dark Side of the Moon\n// followed by all those from Wish You Were Here\nconsole.log(tracks[0].album);  // The Dark Side of the Moon\nconsole.log(tracks[0].year);   // 1973\nconsole.log(tracks[0].title);  // Speak to Me / Breathe\n\nconsole.log(tracks[1].album);  // The Dark Side of the Moon\nconsole.log(tracks[1].year);   // 1973\nconsole.log(tracks[1].title);  // On the Run\n\n// ...etc...\n\nconsole.log(tracks[13].album);  // Wish You Were Here\nconsole.log(tracks[13].year);   // 1975\nconsole.log(tracks[13].title);  // Shine On You Crazy Diamond (Parts I-V)\n```\n\nThere are other ways to achieve a similar result.  For example, you could define\nyour own [record class](manual/record_class.html) for the artists table and add\nan `albumTracks` method:\n\n```js\nexport class Artist extends Record {\n  async albumTracks() {\n    const artists = this.table;\n    const rows = await artists.all(\n      'album_tracks',\n      [this.row.id]\n    )\n    return artists.records(rows);\n  }\n}\n```\n\nThe usage would be almost identical:\n\n```js\nconst artists = await musicdb.table('artists');\nconst artist  = await artists.oneRecord({ name: 'Pink Floyd' });\nconst tracks  = await artist.albumTracks();\n// ...as before\n```\n\nIf you've already defined a record class for a table then this might be the\neasier approach.  On the other hand, if you don't already have a record\nclass then it might be slightly easier to define a custom relation with a\n`load` method to achieve the same effect.\n\n## Where Next?\n\nThe next few sections cover some miscellaneous features,\ninclude the the [model](manual/model.html) and [waiter](manual/waiter.html).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/transactions.md",
    "name": "./manual/transactions.md",
    "content": "# Transactions\n\nTransactions allow you to write a sequence of queries that can\nbe committed to the database in one go.  If any single query fails,\nthen all changes can be rolled back.  The classic example is in\na banking application where money is debited from one account and\ncredited to another.  Both queries must successfully complete, or\nneither of them should.\n\nWe'll start by connecting to a database in the usual way.\n\n```js\nimport connect from '@abw/badger-database'\n\nconst db = connect({ database: 'sqlite:memory' });\n```\n\nA transaction is run by calling the `transaction()` method on the\ndatabase.  You should pass it a function which will contain all\nthe code that will be run inside the transaction.  The function\nwill be passed three parameters: a reference to the database, a\ncommit function and a rollback function.\n\n```js\nawait db.transaction(\n  async (tdb, commit, rollback) => {\n    await tdb.run('...some query...');\n    await tdb.run('...another query...');\n\n    if (...all is goood...) {\n      await commit();\n    }\n    else {\n      await rollback();\n    }\n  }\n)\n```\n\nYou **MUST** use the database reference provided to the function for\nall database operations (shown as `tbd` in these examples).  Call\nthe `commit()` function to commit the changes made in the transaction,\nor `rollback()` to roll them back.\n\nYou can only call `commit()` or `rollback()`, not both, and you must\ncall at least one of them.  If your code throws an error then the\ntransaction will automatically be rolled back, as long as you haven't\nalready called `commit()` or `rollback()`.\n\nYou can also call the `tdb.commit()` or `tdb.rollback()` methods if you\nprefer.\n\n```js\nawait db.transaction(\n  async tdb => {\n    await tdb.run('...some query...');\n    await tdb.run('...another query...');\n\n    if (...all is good...) {\n      await tdb.commit();\n    }\n    else {\n      await tdb.rollback();\n    }\n  }\n)\n```\n\nYou can pass an object containing configuration options as a second\nargument to the `transaction()` method.  This can contain the `autoCommit`\nor `autoRollback` options which will causes the transaction to be automatically\ncommitted or rolled back, respectively.  This will only happen if you don't\nmanually call either `commit()` or `rollback()` within your transaction code.\nIf an error is thrown then the transaction will always be rolled back,\nregardless of these settings.\n\n```js\nawait db.transaction(\n  async tdb => {\n    await tdb.run('...some query...');\n    await tdb.run('...another query...');\n\n    if (...something bad happened...) {\n      await tdb.rollback();\n    }\n    // else transaction will automatically be committed\n  },\n  { autoCommit: true }\n)\n```\n\n```js\nawait db.transaction(\n  async tdb => {\n    await tdb.run('...some query...');\n    await tdb.run('...another query...');\n\n    if (...all is good...) {\n      await tdb.commit();\n    }\n    // else transaction will automatically be rolled back\n  },\n  { autoRollback: true }\n)\n```\n\nYou can also add the `debug` option to generating debugging messages\nfor the transaction.\n\n```js\nawait db.transaction(\n  async tdb => {\n    // your transaction code\n  },\n  { debug: true }\n)\n```\n\nYou can use all of the database methods inside the transaction,\nincluding [named queries](manual/named_queries.html) and the\n[query builder](manual/query_builder.html).\n\nYou can also load tables and call their methods, but you **MUST**\nfetch the table using the database reference passed to the transaction\ncode.\n\n```js\nawait db.transaction(\n  async tdb => {\n    const users = await tdb.table('users');\n    await users.insert({\n      name: 'Brian Badger',\n      email: 'brian@badgerpower.com',\n    });\n    await tdb.commit();\n  }\n)\n```\n\nYou **MUST NOT** use any database or table references from outside\nof the transaction code.  All references must be accessed through\nthe database reference passed to your code.\n\n```js\nconst users = await db.table('users');\n\nawait db.transaction(\n  async tdb => {\n    // DO NOT DO THIS! - the existing users reference will not\n    // execute queries in the context of the transaction\n    await users.insert({\n      name: 'Brian Badger',\n      email: 'brian@badgerpower.com',\n    });\n    await tdb.commit();\n  }\n)\n```\n\nYou can also use records within a transaction, but they **MUST**\nbe fetched from tables accessed through the database reference passed\nto your transaction function.\n\n```js\nawait db.transaction(\n  async tdb => {\n    const users = await tdb.table('users');\n    const brian = await users.fetchRecord({\n      email: 'brian@badgerpower.com',\n    });\n    await brian.update({\n      name: 'Brian the Badger'\n    })\n    await tdb.commit();\n  }\n)\n```\n\nYou can also use the [model](manual/model.html) and [waiter](manual/waiter.html)\nutilities, but once again, you **MUST** access them via the database reference\npassed to the function.\n\n```js\nawait db.transaction(\n  async tdb => {\n    await tdb.waiter.model.users\n      .fetchRecord({ email: 'brian@badgerpower.com' })\n      .update({ name: 'Brian the Badger' })\n    await tdb.commit();\n  }\n)\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/model.md",
    "name": "./manual/model.md",
    "content": "# Model\n\nThe database `model` property provides a short-hand way to access tables\nin the database model.\n\nGiven a database connection like this:\n\n```js\n// connect to the database\nconst musicdb = connect({\n  database: 'sqlite:memory',\n  tables: {\n    artists: {\n      columns: 'id name'\n    },\n    // ...etc...\n  }\n});\n```\n\nWe can fetch the `artists` table by calling the `table()` method:\n\n```js\nconst artists = await musicdb.table('artists');\n```\n\nThe database `model` is a proxy that allows you to use the shorthand form.\n\n```js\nconst artists = await musicdb.model.artists;\n```\n\nAdmittedly it doesn't save you much typing, but I find it slightly\neasier to read (and marginally easier to type).",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/waiter.md",
    "name": "./manual/waiter.md",
    "content": "# Waiter\n\nWhen you're at a restaurant it would be a bit tedious if you asked the waiter\nto bring you a steak (or vegetarian/vegan alternative if that's your thing),\nand then when he delivered it to your table, you asked him for some potatoes,\nand then when those came you asked him for some green beans, then some bread,\nbutter, a bottle of wine, and so on.  Each time you wait for one item to arrive\nbefore you order the next.\n\nThe better approach, of course, would be to place your entire order at once\nand then wait for the waiter to bring it.\n\nWriting asynchronous Javascript code can feel a bit like the first scenario\nsometimes.  For example, suppose we've got a music database and we want to load\nthe artist record for \"The Pink Floyd\" (as they were sometimes know in the early\ndays) and change the name to just \"Pink Floyd\".\n\nThe code might look something like this:\n\n```js\n// connect to the database\nconst musicdb = connect({\n  database: 'sqlite:memory',\n  tables: {\n    artists: {\n      columns: 'id name'\n    },\n    // ...etc...\n  }\n});\n\n// wait for the artists table\nconst artists = await musicdb.model.artists;\n\n// wait to fetch a record\nconst artist = await artists.oneRecord({\n  name: 'The Pink Floyd'\n});\n\n// wait to update the record\nawait artist.update({\n  name: 'Pink Floyd'\n});\n\n// fetch the new artist name\nconst name = artist.name;\n\n// check we got the expected value\nconsole.log(name);    // Pink Floyd\n```\n\nThe database object that is returned from the `connect()` method includes a `waiter`\nproperty that allows you to \"place your entire order at once\" and then wait for the result.\n\n```js\nconst musicdb = connect({\n  // as before\n});\nconst name = await musicdb.\n  .waiter       // waiter, please can you fetch...\n  .model        // ...the database model...\n  .artists      // ...which has an artists table...\n  .oneRecord({  // ...containing a record...\n    name: 'The Pink Floyd'\n  })\n  .update({     // ...that we want to update...\n    name: 'Pink Floyd'\n  })\n  .name;        // ...then tell me the new name...\n\nconsole.log(name);   //Pink Floyd\n```\n\nThat's all there is to it.  The `waiter` property contains a\n[proxymise](https://github.com/kozhevnikov/proxymise) wrapper\naround the database.  This allows you to chain together asynchronous\nmethod calls and access data properties in a convenient short-hand\nform.  You just need to `await` the final result.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/debugging.md",
    "name": "./manual/debugging.md",
    "content": "# Debugging\n\nTo enable debugging messages for the database library add the `debug` flag to the\n`connect()` configuration, set to `true`.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  debug: true\n})\n```\n\nTo enable debugging for individual tables, add the `debug` flag to the table\nconfiguration.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      columns: 'id name email',\n      debug: true,\n    }\n  }\n})\n```\n\nTo enable debugging for a record object associated with a table, set the `recordConfig`\nfor the table to include the `debug` flag.\n\n```js\nconst db = connect({\n  database: 'sqlite:memory',\n  tables: {\n    users: {\n      columns: 'id name email',\n      recordConfig: {\n        debug: true\n      }\n    }\n  }\n})\n```\n\nTo enable debugging on a global level (for example, to enable it for all tables,\nrecords, etc.), use the `setDebug` function.  You can set any of the following\nflags to `true` to enable debugging for that component.\n\n```js\nimport { connect, setDebug } from '../src/Utils/Debug.js';\n\nsetDebug({\n  database: true,   // general database queries\n  engine:   true,   // lower level functionality\n  builder:  true,   // query builder\n  tables:   true,   // table provider\n  table:    true,   // table methods\n  record:   true,   // record methods\n})\n```\n\nDebugging messages are formatted with a colored prefix to help you identify\nwhere the error came from.\n\n<img src=\"./images/screenshots/debugging.png\" width=\"100%\"/>\n\nYou can change the debug message prefix for different components and the color\nthat it is rendered in.\n\n```js\nsetDebug({\n  engine: {\n    debug:  true,\n    prefix: 'Snake!',\n    color:  'red'\n  }\n})\n```\n\nThe available colors are: `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`,\n`grey` and `white`.  You can also prefix any of them with `bright` or `dark`, e.g.\n`dark red`, `bright yellow`, etc.\n\nYou can specify the `color` as an object containing `fg` to set the foreground\ncolor and `bg` to set the background color independently.  Note that the `bright` and\n`dark` prefixes might not work as you expect, e.g. both foreground and background will\nend up bright or dark, even if you only add the modified to one or the other.\n\n```js\nsetDebug({\n  engine: {\n    debug:  true,\n    prefix: 'Snake!',\n    color:  { fg: 'yellow', bg: 'blue' }\n  }\n})\n```\n\nInside a custom table or record module you can print debugging messages to the console\nusing the `debug()` method.  If debugging is enabled for the module then it will be\nprinted to the console.  Otherwise it will be ignored.\n\n```js\nexport class User extends Record {\n  helloWorld() {\n    this.debug(\"helloWorld()\");\n    // ...your code goes here...\n  }\n}\n```\n\nYou can use the `debugData()` method to generate debugging messages to display\nthe contents of data items.  This is a useful way to inspect the parameters\npassed to a method.  Again, it will only generate output if debugging is enabled\nfor that module so you can safely add these lines to your code and enabled them\nby setting the `debug` option when you need to.\n\n```js\nexport class User extends Record {\n  helloWorld(message, options) {\n    this.debugData(\"helloWorld()\", { message, options });\n    // ...your code goes here...\n  }\n}\n```\n\n## SQL Parse Errors\n\nIn an ideal world every SQL query you write would be syntactically correct,\nrun first time, return the correct results and be efficient to boot.\nUnfortunately we don't live in an ideal world.  I've been writing SQL in a\nprofessional capacity for longer than I care to remember (3 decades or so)\nand I *very rarely* get a complex query right first time.\n\nThis is one reason why I'm not a fan of using ORMs or query builders for more\ncomplex queries.  I *nearly always* write, test and debug a complex query in SQL\nfirst.  When it's finally working as expecting I don't want to then have to\ntranslate it into a format that the ORM or query builder will understand and\nhope that it generates the same SQL that I've written.  Your experience may\nbe different, of course, but it's the principle that has guided me in the\ndesign and implementation of this library.\n\nDatabases aren't well known for producing friendly error messages when\nsomething goes wrong (I'm looking at *all* of you, Sqlite, Mysql and Postgres).\nThe database engine modules that handle the specifics of different databases\ntry to make the process of debugging SQL queries a little less painful.  If\nthere is a parse error in a SQL query then they will throw a `SQLParseError`\nand do their best to standardise the response.\n\nMost importantly, the error will contain a copy of the SQL query that failed\nso that you don't have to go digging around to find it (this is particularly\nuseful when the query has been generated programmatically by a query builder).\n\nHere's a trivial example showing an invalid SQL query.\n\n```js\nasync function main() {\n  const db = connect({\n    database: 'sqlite:memory',\n  })\n  await db.run(\n    `SELECT FROM badger mushroom`\n  ).catch(\n    e => console.log(e)\n  )\n  db.disconnect();\n}\nmain()\n```\n\nSqlite is perhaps the database that provides the least friendly error messages.\nIt will look something like this:\n\n```js\nSQLParseError: near \"FROM\": syntax error\n    at Database.prepare (...blah...)\n    at SqliteEngine.prepare (...blah...)\n    at SqliteEngine.execute (...blah...)\n    at async main (...blah...) {\n  name: 'SQLParseError',\n  query: 'SELECT FROM badger mushroom',\n  type: 'SQLITE_ERROR',\n  code: undefined,\n  position: undefined\n}\n```\n\nHere's an example of the same error when using Postgres:\n\n```js\nSQLParseError: relation \"badger\" does not exist\n    at PostgresEngine.parseError (...blah...)\n    at ...blah...\n    at processTicksAndRejections (...blah...)\n    at async PostgresEngine.execute (...blah...)\n    at async main (...blah...) {\n  query: 'SELECT FROM badger mushroom',\n  type: 'ERROR',\n  code: '42P01',\n  position: '13'\n}\n```\n\nAnd here it is for Mysql:\n\n```js\nSQLParseError: You have an error in your SQL syntax; check the manual that corresponds to\nyour MySQL server version for the right syntax to use near 'FROM badger mushroom' at line 1\n    at PromiseConnection.prepare (...blah...)\n    at MysqlEngine.prepare (...blah...)\n    at MysqlEngine.execute (...blah...)\n    at processTicksAndRejections (...blah...)\n    at async main (...blah...) {\n  query: 'SELECT FROM badger mushroom',\n  type: 'ER_PARSE_ERROR',\n  code: 1064,\n  position: undefined\n}\n```",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/implementation.md",
    "name": "./manual/implementation.md",
    "content": "# Implementation Details\n\nThis section talks about how the library is implemented.  It's aimed at\npeople who are looking to maintain or extend the library, find and fix\nbugs, or are looking to use it in a project and want to convince themselves\nthat it's suffiently well written and easy to reason about, should they\never need to maintain or extend it themselves.\n\n## Total Cost of Ownership\n\nFree and Open Source software is fantastic. If you have a problem you need\nto solve then you can spend days, weeks or months writing your own solution,\nor you can download and use an Open Source library with a single command.\nNot only is it free to use, but also has a greater chance of being well\ndocumented and reliable.  It has (hopefully) been well tested by the author\nand is widely used in the community, increasing the chances that any bugs in\nit have already been found and fixed.  Software quality isn't something that\nhappens overnight.\n\nHowever, it's important to understand that there are hidden costs in using\nany piece of software.  Even if you don't have to pay any money to install\nand use it, you still have to consider the ongoing costs associated with\nmaintenance.  If at some time in the future you find a bug or want to add a\nnew feature, you may find that the original author has stopped maintaining\nthe code, isn't interested in fixing the bug that you've found, doesn't want\nto add your new feature, has retired and gone to live in a llama colony in\nOuter Mongolia, or has simply disappeared off the face of the Earth.  At\nthis point, you're potentially on your own.\n\nBefore building your next big dotcom enterprise around any this library, or\nindeed any key piece of technology, you should invest at least some of the\ntime you would have otherwise spent writing it yourself in getting to know\nit.  Not only understanding how to use it, but also getting a feel for how\nit works, evaluating the quality of the codebase, and considering how easy\nit would be for you, or your future colleagues to maintain it, should you\never need to.\n\nGiven that this is a new library as of 2022 (albeit one that is based on\na similar library written in Perl that's been used in production for nearly\n20 years) that at the time of writing has a user base measured in single figures,\nyou should be especially cautious about adopting it without performing due\ndiligence.\n\nThis document provides a high-level overview of how `badger-database` works\nto help you with that process.\n\n## Key Components\n\nThe [Database](https://github.com/abw/badger-database-js/blob/master/src/Database.js)\nmodule is the main interface to the library.  This is what gets returned\nby the [connect()](manual/connecting.html) function (defined down at the bottom\nof the [Database.js](https://github.com/abw/badger-database-js/blob/master/src/Database.js)\nfile).\n\nThe [Database](https://github.com/abw/badger-database-js/blob/master/src/Database.js) module\nis a subclass of the [Queryable](https://github.com/abw/badger-database-js/blob/master/src/Queryable.js)\nmodule.  This is the base class that implements the\nbasic [run()](manual/basic_queries.html#run-query--values--options-),\n[one()](manual/basic_queries.html#one-query--values--options-),\n[any()](manual/basic_queries.html#any-query--values--options-)\nand [all()](manual/basic_queries.html#all-query--values--options-) methods.\n\nThe [Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js)\nmodule is also a subclass of\n[Queryable](https://github.com/abw/badger-database-js/blob/master/src/Queryable.js)\nso that it also inherits those same basic query methods.\n\nThe [Engine](https://github.com/abw/badger-database-js/blob/master/src/Engine.js)\nmodule is used by the\n[Queryable](https://github.com/abw/badger-database-js/blob/master/src/Queryable.js)\nclasses as a lower-level interface to the database.  It handles communicating with the\nunderlying database driver and provides methods for accessing the connection pool,\npreparing and executing queries, and formatting SQL fragments, e.g. quoting columns\nand table names, generating  placeholders, etc.\n\nThere are three subclasses of the\n[Engine](https://github.com/abw/badger-database-js/blob/master/src/Engine.js) module\nwhich are specialised for the different databases supported:\n[Sqlite](https://github.com/abw/badger-database-js/blob/master/src/Engine/Sqlite.js),\n[Mysql](https://github.com/abw/badger-database-js/blob/master/src/Engine/Mysql.js) and\n[Postgres](https://github.com/abw/badger-database-js/blob/master/src/Engine/Postgres.js).\n\nThe [Engines](https://github.com/abw/badger-database-js/blob/master/src/Engines.js)\nmodule is an [Engine](https://github.com/abw/badger-database-js/blob/master/src/Engine.js)\nprovider.  It implements the functionality to allow engines to\nbe registered and then used by specifying a driver protocol (e.g. `sqlite`, `mysql`,\n`mariadb`, `postgres` or `postgresql`).\n\nThe [Database](https://github.com/abw/badger-database-js/blob/master/src/Database.js)\nmodule implements the [table()](manual/table.html) method for\ncreate new [Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js)\nobjects.  It uses the [Tables](https://github.com/abw/badger-database-js/blob/master/src/Tables.js)\nmodule as a \"provider\".  This module is ridiculously simply, but it exists\nas an extension point so that you can implement your own\n[Tables](https://github.com/abw/badger-database-js/blob/master/src/Tables.js) provider\nif you want to change the way that table configurations details are defined\n(for example, I have a number of projects where the table definitions are in\nYAML files that get loaded when the table is first used).\n\nThe [Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js)\nmodule is also intended to be an extension point.  It implements\na number of methods providing the basic CRUD functions (Create, Read, Update,\nDelete) in various flavours (one, any, all, returning rows or records) that\nshould cover most basic row-based operations.  When you need to add custom\nqueries, business logic or other functionality relating to a particular table\nthen you can create your own subclass of the\n[Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js)\nmodule and hook it in.\n\nVarious [Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js) methods have an option to return rows as [records](manual/records.html).\nThe base class [Record](https://github.com/abw/badger-database-js/blob/master/src/Record.js)\nmodule provides some basic methods for updating the record, deleting it or\nfetching related records.  The more important role is as another extension point.\nYou can subclass it to create your own record modules where you can add data\nvalidation, business logic or other functionality relating to individual entities.\n\nThe [Table](https://github.com/abw/badger-database-js/blob/master/src/Table.js) methods that return records don't return a [Record](https://github.com/abw/badger-database-js/blob/master/src/Record.js)\nobject directly, but instead return a\n[Record Proxy](https://github.com/abw/badger-database-js/blob/master/src/Proxy/Record.js)\nwrapper around the record.  This proxy allows you to access the `record.row` components\nwithout having to specify the `.row` part (e.g. `record.id` is short for `record.row.id`)\nand also provide access to record relations.\n\nThe [Relation](https://github.com/abw/badger-database-js/tree/master/src/Relation)\nmodules implement the queries to fetch related records for different relation\ntypes:\n[one](https://github.com/abw/badger-database-js/blob/master/src/Relation/one.js),\n[any](https://github.com/abw/badger-database-js/blob/master/src/Relation/any.js),\n[many](https://github.com/abw/badger-database-js/blob/master/src/Relation/many.js) and\n[map](https://github.com/abw/badger-database-js/blob/master/src/Relation/many.js).\nMost of them are very simple, being no more than 10 lines of code.\n\nThe [Builder](https://github.com/abw/badger-database-js/blob/master/src/Builder.js)\nmodule is the base class for components that are used to build SQL queries.\nThere are numerous subclasses, one for each builder method, e.g.\n[Select](https://github.com/abw/badger-database-js/blob/master/src/Builder/Select.js),\n[From](https://github.com/abw/badger-database-js/blob/master/src/Builder/From.js),\n[Where](https://github.com/abw/badger-database-js/blob/master/src/Builder/Where.js),\n[Insert](https://github.com/abw/badger-database-js/blob/master/src/Builder/Insert.js),\n[Into](https://github.com/abw/badger-database-js/blob/master/src/Builder/Into.js),\nand so on.\n\nThe [Builders](https://github.com/abw/badger-database-js/blob/master/src/Builders.js)\nmodule is the provider for `Builder` components, where they can be registered and used.\n\nThe [Builder Proxy](https://github.com/abw/badger-database-js/blob/master/src/Proxy/Builder.js)\nis a bit of magic sauce that allows one builder component to chain other builder components\nonto it.  When you call the `db.select(...)` method, for example, it creates a\n[Select](https://github.com/abw/badger-database-js/blob/master/src/Builder/Select.js)\nbuilder component and returns a builder proxy wrapper around it.  When you call the\n`from(...)` method on that, it creates a\n[From](https://github.com/abw/badger-database-js/blob/master/src/Builder/From.js) builder\ncomponents, passing it a reference to the \"parent\" component that it's attached to,\nand returns a builder proxy around that.  And so the process continues...\n\nWhen you want to run a query built this way, e.g. by calling `run()`, `one()`, `any()`\nor `all()`, these methods first call the `sql()` method to generate the query as SQL.\nThe final builder component in the chain asks its parent for everything it knows about\n(the builder context) and then adds its own information to it.  The parent does the\nsame thing - asking its parent for a context and then adding its own information to it.\nSo the context requests bubble up the chain, and the context information is then passed\nback down.  At each step, a new context object is created so that builder components\ndon't affect any previous components in the chain.  Once all the context information\nhas been collected, it's then a relatively simple process of generating the SQL for\neach component type (by calling the `generateSQL()` static class method) and then\ncombining the fragments together in the right order.\n\nWhen a SQL query has been built using the [query builder](manual/query_builder.html),\nor if you're running a [named query](manual/named_queries.html) or a raw SQL query,\nit is wrapped up as a [Query](https://github.com/abw/badger-database-js/blob/master/src/Query.js)\nobject before being passed to the [Engine](https://github.com/abw/badger-database-js/blob/master/src/Engine.js) to execute.  This provides a level of\nabstraction so that the higher levels don't have to worry about the difference between\nrunning a raw SQL query or a query built using the query builder - the\n[Query](https://github.com/abw/badger-database-js/blob/master/src/Query.js) object\ntakes care of that.  It also deals with combining placeholder values from the query\nbuilder and any that you pass to the query execution methods `run()`, `one()`, `any()`\nand `all()`.\n\nThe [Transaction](https://github.com/abw/badger-database-js/blob/master/src/Transaction.js)\nmodule is used to run transactions.  It implements methods to handle the `commit()` and\n`rollback()` and maintains the state so that it can tell if one or the other has been\ncalled.  It also acquires a dedicated database connection from the\n[Engine](https://github.com/abw/badger-database-js/blob/master/src/Engine.js) to ensure\nthat all queries run within the scope of the transaction use the same connection.\n\n## Conclusion\n\nThat's just about all there is to it.  At the time of writing it's a little less than\n3,000 lines of code.  That's an order of magnitude less than some of the other\npopular Javascript ORMs and SQL query builders out there, and around 30 times less\ncode than one of the more comprehensive \"next generation\" ORMs. It is perhaps not a\nfair comparison as other libraries may do a lot more than `badger-database`, but the\npoint is to illustrate that this is one of the *simpler* and *less intrusive* solutions\nthat exists for adding database functionality to your project.\n\nIt doesn't aim to be a library that you can use as an *alternative* to using SQL\n(although that may be true for some simpler projects), but rather to give you tools\nthat *help* you work with SQL.  In particular, the focus is on automating some of\nthe simple, boring tasks that are an inherent part of using a database so that you\nhave time to focus on the more complicated things that are harder to automate.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/extending.md",
    "name": "./manual/extending.md",
    "content": "# Extending\n\nIn this section we'll look at how you can customise and extend the\nlibrary.\n\n* [Custom Tables Class](#custom-tables-class)\n* [Custom Tables Object](#custom-tables-object)\n* [Adding Query Builder Methods](#adding-query-builder-methods)\n* [Adding a New Database Engine](#adding-a-new-database-engine)\n* [Using a Different Engine Driver](#using-a-different-engine-driver)\n\n## Custom Tables Class\n\nYou can provide your own implementation of the `Tables` class which\nreturns the configuration options for a table.  For example, you might\nwant to define your tables in JSON or YAML files that are loaded on\ndemand.\n\nThe `table(name)` method is called to fetch the configuration options\nfor a table.  Any pre-defined tables will be stored in `this.tables`.\nYou can return the data from there or implement some other way to\nfetch the configuration options for the table.\n\n```js\nimport { connect, Tables } from '@abw/badger-database'\n\nclass YourTables extends Tables {\n  table(name) {\n    // any pre-defined tables data will be stored in this.tables\n    // or you can fetch it some other way...\n    return this.tables[name] ||= this.yourCustomTableLoader(name);\n  }\n  yourCustomTableLoader(name) {\n    // your code here to load the table definition for the `name` table\n    // return undefined if the table doesn't exist\n    return {\n        // columns, etc.\n    }\n  }\n}\n\nasync function main() {\n  const db = connect({\n    // ...database, etc...\n    tablesClass: YourTables,\n    tables: {\n      // these tables will be defined in `this.tables` for YourTables\n      users: {\n        columns: 'id name email'\n      }\n    }\n  });\n  const users = await db.table('users');      // returns users defined above\n  const another = await db.table('another');  // calls yourCustomTableLoader('another')\n}\n\nmain();\n```\n\n## Custom Tables Object\n\nYou can instantiate your own `Tables` object and define it as the `tablesObject`\nconfiguration item.  If you have any pre-defined `tables` that you want it to\nmanage then you should pass them as constructor parameters.\n\n```js\nconst db = connect({\n  // ...database, etc...\n  tablesObject: new YourTables({\n    tables: {\n      // these tables will be defined in `this.table` for YourTables\n      users: {\n        columns: 'id name email'\n      }\n    },\n    // any other configuration options for YourTable\n  })\n});\n```\n\n## Adding Query Builder Methods\n\nYou can write your own modules which can be linked into the query builder chain.\nSee [09_custom_builder](https://github.com/abw/badger-database-js/tree/master/examples/09_custom_builder)\nfor a working example of this.\n\nYou will probably also want to browse the source code of the existing\n[builder modules](https://github.com/abw/badger-database-js/tree/master/src/Builder) for\ninspiration and enlightenment.  You should also familiarise yourself with how the\n[base class Builder](https://github.com/abw/badger-database-js/tree/master/src/Builder.js)\nworks.\n\nYou should create your module as a subclass of the `Builder` module.\n\n\n```js\nexport class Hello extends Builder {\n  static buildMethod = 'hello'\n  static buildOrder  = 0\n  static validFor    = 'SELECT INSERT UPDATE DELETE'\n  static keyword     = '# GREETINGS: '\n  static joint       = ', '\n\n  resolveLinkString(arg) {\n    return arg;\n  }\n}\n```\n\nIt should define the static `buildMethod` property which is the name of the method\nthat will be callable in a query builder chain.  The `buildOrder` property is a\nnumber from `0` to `100` which determines where in the generated SQL query it will\nappear (e.g. `0` is at the start, `10` is where `WITH` is placed, `20` for `SELECT`,\n`30` for `FROM`, etc.).  The `validFor` property is a list of the keywords for the\ndifferent core query types (`SELECT`, `INSERT`, `UPDATE` and `DELETE`) that your\nmethod is compatible with.  The `keyword` is the SQL keyword that the generated SQL\nwill start with and `joint` is a string used to combine multiple values.\n\nThe `resolveLinkString()` method is called when your method is called with a string\nargument.  In this example we simply return the string.  You can also implement\n`resolveLinkArray()` and `resolveLinkObject()` methods to handle array and object\narguments, respectively.  Each of these methods should return a SQL query fragment.\nGenerally speaking these don't include the SQL keyword.  For example, the `from()`\nbuilder component returns a quoted table name or names, but not the `FROM` keyword.\n\nYour module will inherit the static `generateSQL()` which is called to generate a\ncomplete SQL fragment from the parts returned by the above method.  This is\nwhere the SQL `keyword` (e.g. `FROM`) is added and the parts are combined with the\n`joint` string (e.g. `[\"table1\", \"table2\"]` generates `FROM table1, table2`).\nYou can redefine this method if you want to implement a different behaviour.\n\nYou register your module using the `registerBuilder()` function.\n\n```js\nimport { registerBuilder } from '@abw/badger-database'\n\nregisterBuilder(Hello);\n```\n\nIt should then be callable as a link in a query builder chain.  You can call\nit anywhere in the chain.  The `buildOrder` determines where it will appear\nin the generated query.\n\n```js\ndb.select('id name')\n  .from('users')\n  .hello('Hello World!')\n// -> # GREETINGS: Hello World!\n//      SELECT \"id\", \"name\"\n//      FROM \"users\"\n```\n\nYou can call the method multiple times, or pass multiple arguments to it.\n\n```js\ndb.select('id name')\n  .hello('Hello World!')\n  .from('users')\n  .hello('I like badgers!')\n// -> # GREETINGS: Hello World!, I like badgers!\n//      SELECT \"id\", \"name\"\n//      FROM \"users\"\n```\n\n## Adding a New Database Engine\n\nIf you want to add support for a new database engine then you can.\nThere currently isn't any documentation about how the engines work but\nyou can browse the existing\n[Engine](https://github.com/abw/badger-database-js/tree/master/src/Engine)\nmodules to get an idea.  They're all less than 100 lines long so there\nisn't much to it.\n\nYour engine module should be a subclass of the `Engine` base class.\n\n```js\nimport { Engine } from '@abw/badger-database'\n\nexport class BadgerEngine extends Engine {\n  static protocol = 'badger'\n  static alias    = 'mushroom'\n\n  configure(config) {\n    // any custom configuration option handling\n    console.log('got BadgerEngine config:', config);\n    return config;\n  }\n  async connect() {\n    // your code to connect to the database\n  }\n  async disconnect(db) {\n    // your code to disconnect from the database\n  }\n  async execute(sql, params=[], options) {\n    // acquire a connection from the pool\n    const client = await this.acquire();\n\n    try {\n      const result = await\n        //...database specific code goes here\n        .catch( e => this.parseError(sql, e) );\n\n      return options.sanitizeResult\n        ? this.sanitizeResult(result, options)\n        : result;\n    }\n    finally {\n      // release the connection back to the pool\n      this.release(client);\n    }\n  }\n  sanitizeResult(result, options={}) {\n    // your code to sanitize the response, e.g. changes, inserted ID\n  }\n  parseErrorArgs(e) {\n    // your code to sanitize a parse error, e.g. message, code, position\n  }\n}\n```\n\nIt should define the static `protocol` property which is used to identify\nit.  If you have another name (or names) that you want it to be known\nby (e.g. `postgres` is also known as `postgresql`) then you can define\nthat as the `alias` property.  Multiple aliases can be defined as an\narray (e.g. `static alias = ['mushroom', 'snake']`) or using the short\nhand syntax of a single whitespace delimited string\n(e.g. `static alias = 'mushroom snake'`).\n\nDepending on how the database that you're connecting to works, you may\nhave to implement other methods as well.\n\nYou should then register it using the `registerEngine()` function.\n\n```js\nimport { registerEngine } from '@abw/badger-database'\n\nregisterEngine(BadgerEngine);\n```\n\nYou can then connect to it using the `badger` protocol (or one of the\nalias protocols):\n\n```js\nimport { connect } from '@abw/badger-database'\n\nconst db = connect({\n  database: 'badger://username:password@host:port/database'\n});\n```\n\nThe `configure()` method will received the expanded connection parameters.\nYou can specify them as an object yourself if you prefer:\n\n```js\nimport { connect } from '@abw/badger-database'\n\nconst db = connect({\n  database: {\n    engine:    'badger',   // or 'mushroom', 'snake'\n    user:      'username',\n    password:  'password',\n    host:      'host',\n    port:      'port',\n    database:  'database'\n});\n```\n\nIf you implement support for a database engine that we don't currently\nsupport then please consider raising a pull request so we can add it\nfor other people to use.  Or if you prefer you can release it as a\nstand-alone module.  End users would still need to call the\n`registerEngine()` module to plug it in, but that's only a line of\ncode, so not too much trouble.\n\n## Using a Different Engine Driver\n\nIf you want to use one of the existing engines with a different underlying\ndriver module then it's quite simple, as long as the module implements the\nsame API.  For example, if you want to use Sqlite with the `sqlite3` module\ninstead of `better-sqlite3` then you can subclass the `SqliteEngine` module\nand redefine the static `driver` property.  Of course, you will need to ensure\nthat you've installed `sqlite` as a dependency for your project.\n\n```js\nimport { SqliteEngine, registerEngine } from '@abw/badger-database'\n\nexport class MySqliteEngine extends SqliteEngine {\n  static driver = 'sqlite3'\n}\n\nregisterEngine(MySqliteEngine);\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/limitations.md",
    "name": "./manual/limitations.md",
    "content": "# Limitations\n\nThe scope of the library is, quite deliberately, limited.\n\nThe [query builder](manual/query_builder.html) allows you to\nconstruct *many* of the simpler select queries that you might need,\nbut certainly not *every* SQL query that you could imagine.\n\nThere's no built-in support for subqueries, for example, but you\ncan still define them using raw SQL fragments if you want to.\nThat said, for more complex queries you might be better off writing\nthem entirely in SQL and saving them as\n[named queries](manual/named_queries.html).\n\nThat gives you the benefit of having a \"pure\" SQL query that\nyou can write, test, inspect and amend, without having to translate\nit back and forth between the query builder methods.  Making it a\nnamed query allows it to be hidden away somewhere in a library file\nso that your application code can remain simple and treat it like a\nblack box.\n\nThe support for [relations](manual/relations.html) has some\nshortcomings.  For example, you can't define many-to-many relations that\nuse intermediate link tables. However, you can define your own load method\nwith a custom SQL query when you need to.\n\nThese are all deliberate design decision.  Supporting everything that\nis possible in SQL would require a full-blown ORM or SQL query generator\nwith all the problems that they bring.\n\nThe library aims to hit the 90/10 sweet spot, where it handles 90% of\ntrivial tasks that can easily be automated, leaving the remaining 10%\n(which would take 90% of the effort to implement) up to you.\n\nInstead, the library makes it easy for you to define named queries and\ncustom table or record methods so that you can use the full power of SQL\nbehind the scenes, without having to embed SQL directly into your\napplication code.\n\nThis approach also makes it easier for the SQL expert in your team (if\nyou have one), to take responsibility for building and maintaining your\ndatabase abstraction layer, allowing other developers to treat it more\nlike a black box, accessing the complex functionality hidden behind the\nscenes through simple method calls.  Even if you don't have an SQL expert,\nthe fact that the library supports and encourages the use of SQL queries\nmakes it easier to cut and paste examples from Stack Overflow without\nhaving to first translate the SQL into the right calls to a query generator.\n(NOTE: please don't use queries from Stack Overflow without first reading\nthrough them, understanding how they work, adapting them as necessary\nand then testing them thoroughly on a sacrifical copy of your production\ndatabase).\n\nSQL is powerful.  SQL is portable.  SQL is (nearly always) the solution\nif the library doesn't already do what you want.\n\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/abw/js/badger-database-js/manual/examples.md",
    "name": "./manual/examples.md",
    "content": "# Examples\n\nThe [github repository](https://github.com/abw/badger-database-js) contains\na number of [examples](https://github.com/abw/badger-database-js/tree/master/examples)\nbased on those shown in these manual pages.\n\n* [01_basic_queries](https://github.com/abw/badger-database-js/tree/master/examples/01_basic_queries/example.js)\nConnecting to a database and running some basic SQL queries.\n\n* [02_named_queries](https://github.com/abw/badger-database-js/tree/master/examples/02_named_queries/example.js)\nUsing named queries for reusability and to simplify your application code.\n\n* [03_query_fragments](https://github.com/abw/badger-database-js/tree/master/examples/03_query_fragments/example.js)\nDefining reusable query fragments that can be embedded into other queries.\n\n* [04_tables](https://github.com/abw/badger-database-js/tree/master/examples/04_tables/example.js)\nDefining tables to get automatically generated insert, update, fetch and delete queries.\n\n* [05_table_class](https://github.com/abw/badger-database-js/tree/master/examples/05_table_class/example.js)\nDefining a custom table class with additional application-specific methods.\n\n* [06_records](https://github.com/abw/badger-database-js/tree/master/examples/06_records/example.js)\nUsing records and defining a custom record class with additional application-specific methods.\n\n* [07_musicdb](https://github.com/abw/badger-database-js/tree/master/examples/07_musicdb/example.js).\nA more complete example of a music database demonstrating custom table and records classes, and the\nuse of relations.\n\n* [08_products](https://github.com/abw/badger-database-js/tree/master/examples/08_products/example.js).\nAn example of a database with customers, products and orders.\n\n* [09_debugging](https://github.com/abw/badger-database-js/tree/master/examples/09_debugging/example.js)\nEnabling debugging to see what's going on behind the scenes.\n\n* [10_custom_builder](https://github.com/abw/badger-database-js/tree/master/examples/10_custom_builder/example.js)\nAdding a custom query builder component\n",
    "static": true,
    "access": "public"
  }
]