import{_ as e,o as t,c as a,a2 as i}from"./chunks/framework.mZNJGiH_.js";const y=JSON.parse('{"title":"Limitations","description":"","frontmatter":{},"headers":[],"relativePath":"limitations.md","filePath":"limitations.md"}'),o={name:"limitations.md"},r=i('<h1 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">â€‹</a></h1><p>The scope of the library is, quite deliberately, limited.</p><p>The <a href="./query-builder.html">query builder</a> allows you to construct <em>many</em> of the simpler select queries that you might need, but certainly not <em>every</em> SQL query that you could imagine.</p><p>There&#39;s no built-in support for subqueries, for example, but you can still define them using raw SQL fragments if you want to. That said, for more complex queries you might be better off writing them entirely in SQL and saving them as <a href="./named-queries.html">named queries</a>.</p><p>That gives you the benefit of having a &quot;pure&quot; SQL query that you can write, test, inspect and amend, without having to translate it back and forth between the query builder methods. Making it a named query allows it to be hidden away somewhere in a library file so that your application code can remain simple and treat it like a black box.</p><p>The support for <a href="./relations.html">relations</a> has some shortcomings. For example, you can&#39;t define many-to-many relations that use intermediate link tables. However, you can define your own load method with a custom SQL query when you need to.</p><p>These are all deliberate design decision. Supporting everything that is possible in SQL would require a full-blown ORM or SQL query generator with all the problems that they bring.</p><p>The library aims to hit the 90/10 sweet spot, where it handles 90% of trivial tasks that can easily be automated, leaving the remaining 10% (which would take 90% of the effort to implement) up to you.</p><p>Instead, the library makes it easy for you to define named queries and custom table or record methods so that you can use the full power of SQL behind the scenes, without having to embed SQL directly into your application code.</p><p>This approach also makes it easier for the SQL expert in your team (if you have one), to take responsibility for building and maintaining your database abstraction layer, allowing other developers to treat it more like a black box, accessing the complex functionality hidden behind the scenes through simple method calls. Even if you don&#39;t have an SQL expert, the fact that the library supports and encourages the use of SQL queries makes it easier to cut and paste examples from Stack Overflow without having to first translate the SQL into the right calls to a query generator. (NOTE: please don&#39;t use queries from Stack Overflow without first reading through them, understanding how they work, adapting them as necessary and then testing them thoroughly on a sacrifical copy of your production database).</p><p>SQL is powerful. SQL is portable. SQL is (nearly always) the solution if the library doesn&#39;t already do what you want.</p>',11),n=[r];function s(l,h,u,d,m,p){return t(),a("div",null,n)}const f=e(o,[["render",s]]);export{y as __pageData,f as default};
