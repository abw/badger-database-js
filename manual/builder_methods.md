# Query Builder Methods

This page describes all the query builder methods.

They all work in a similar way with respect to the arguments
they accept.  The short form is to pass a string which may have
some additional processing applied to it (typically splitting
a whitespace delimited string into multiple tokens).  Where there
are two, three or four possible arguments, an array can be passed.
Or an object can be passed with explicit properties for the different
parameters.

All the methods can generate raw SQL.  This can be specified by
passing an object with a single `sql` property:

```js
db
  .select({ sql: 'COUNT(id) AS n' })
```

Or using the `sql` function to create a tagged template literal:

```js
import { sql } from '@abw/badger-database'

db
  .select(sql`COUNT(id) AS n`)
```

All of the methods can be called multiple time, or passed multiple
arguments.  They both have the same effect.  Generally speaking,
you can call the methods in any order and the query builder will
generate the SQL query with them in the correct order.

For the sake of brevity these examples assume that you've already
connected to a database and stored the connection in the `db` variable.

```js
import connect from '@abw/badger-database'

async function main() {
  const db = connect({ database: 'sqlite:memory' });

  // ...examples would go here
}
```

The examples show the SQL generated by the fragment.  In many cases they're
not complete queries and we've omitted the final `.sql()` method call
which is called internally to generate the SQL.

In these example we're assuming that the database is Sqlite which
quotes table and columns names using double quotes, e.g. `"user"."id"`.
For Mysql the names will be quoted using backticks.  Examples that
show placeholders also assume Sqlite (and Mysql) which uses question
marks, e.g. `?`.  For Postgress the placeholders are of the form `$1`,
`$2`, `$3`, etc.

## select(columns)

This method is used to specify one or more columns that you want to
select.

```js
db.select('id');
// -> SELECT "id"
```

You can specify multiple columns using the shorthand syntax as a
string of whitespace delimited table names.

```js
db.select('id email');
// -> SELECT "id", "email"
```

Commas (with optional whitespace following) can also be used to
delimit column names.

```js
db.select('id, email');
// -> SELECT "id", "email"
```

Columns can have the table name included in them.  Both the table
and columns names will be automatically quoted.

```js
db.select('user.id user.email');
// -> SELECT "user"."id", "user"."email"
```

You can specify `*` to select all columns.  This will not be quoted.

```js
db.select('*');
// -> SELECT *
```

You can also use `*` to select all columns from a table.  The table name
will be automatically quoted but the asterisk will not.

```js
db.select('users.*');
// -> SELECT "users".*
```

You can pass an object to the method containing the `columns` property.
The format for the value is either a single column name or multiple columns
delimited with whitespace or commas/whitespace, as shown in the previous
examples.

```js
db.select({ columns: 'id email company.*' });
// -> SELECT "id", "email", "company".*
```

You can also define the `table` as a property to have the table name automatically
added to the column names.

```js
db.select({ table: 'users', columns: 'id email' });
// -> SELECT "users"."id", "users"."email"
```

The `prefix` property can be used to automatically create aliases for the columns.
The prefix will be attached to the front of each column name.

```js
db.select({ columns: 'id email', prefix: 'user_' });
// -> SELECT "id" AS "user_id", "email" AS "user_email"
```

This also works in conjunction with the `table` property.

```js
db.select({ table: 'users', columns: 'id email', prefix: 'user_' });
// -> SELECT "users"."id" AS "user_id", "users"."email" AS "user_email"
```

An object can also contain a `column` item.  In this case it is assumed to
be a single column name is not split into separate columns.  The optional
`as` property can be provided to create an alias for the column.

```js
db.select({ column: 'email', as: 'email_address' });
// -> SELECT "email" AS "email_address"
```

The `table` property can also be provided in this case.

```js
db.select({ table: 'users', column: 'email', as: 'email_address' });
// -> SELECT "users"."email" AS "email_address"
```

Or you can include the table name in the column.

```js
db.select({ column: 'users.email', as: 'email_address' });
// -> SELECT "users"."email" AS "email_address"
```

The shorthand format for creating a column alias is to pass an Array of
either two elements (the column name and alias) or three (the table name,
column name and alias).

```js
db.select(['email', 'email_address' });
// -> SELECT "email" AS "email_address"
```

```js
db.select(['users', 'email', 'email_address' });
// -> SELECT "users"."email" AS "email_address"
```

You can use raw SQL to define the table columns.  The explicit way is to
pass an object with a `sql` property.

```js
db.select({ sql: '"email" AS "email_address"' });
// -> SELECT "email" AS "email_address"
```

Or you can use the `sql` function to create a tagged template literal.

```js
import { sql } from '@abw/badger-database'
db.select(sql`"email" AS "email_address"`);
// -> SELECT "email" AS "email_address"
```

You can call the method multiple times.  The column names will all be
collected after the `SELECT` keyword.

```js
db.select('id email').select({ table: 'companies', column: 'name', as: 'company_name' });
// -> SELECT "id", "email", "companies"."name" AS "company_name"
```

Or you can pass multiple arguments to a single method call.  Each argument
can be any of the values described above.

```js
db.select('id email', { table: 'companies', column: 'name', as: 'company_name' });
// -> SELECT "id", "email", "companies"."name" AS "company_name"
```

## from(table)

This method is used to specify one or more tables that you want to
select from.

```js
db.from('users');
// -> FROM "users"
```

You can specify multiple tables using the shorthand syntax as a
string of whitespace delimited table names.

```js
db.from('users companies');
// -> FROM "users", "companies"
```

Commas (with optional whitespace following) can also be used to
delimit table names.

```js
db.from('users, companies');
// -> FROM "users", "companies"
```

You can pass an object to the method containing the `tables` property.
The format for the value is either a single table name or multiple tables
delimited with either whitespace or commas, as shown in the previous
examples.

```js
db.from({ tables: 'users, companies' });
// -> FROM "users", "companies"
```

An object can also contain a `table` item.  In this case it is assumed to
be a single table name is not split into separate table names.  The optional
`as` property can be provided to create an alias for the table.

```js
db.from({ table: 'users', as: 'people' });
// -> FROM "users" AS "people"
```

The shorthand format for creating a table alias is to pass an Array of two
elements: the table name and alias.

```js
db.from(['users', 'people']);
// -> FROM "users" AS "people"
```

You can use raw SQL to define the table name.  The explicit way is to
pass an object with a `sql` property.

```js
db.from({ sql: '"users" AS "people"' });
// -> FROM "users" AS "people"
```

Or you can use the `sql` function to create a tagged template literal.

```js
import { sql } from '@abw/badger-database'
db.from(sql`"users" AS "people"`);
// -> FROM "users" AS "people"
```

You can call the method multiple times.  The tables names will all be
collected after the `FROM` keyword.

```js
db.from(['users', 'people']).from('companies').from({ table: 'employees' })
// -> FROM "users" AS "people", "companies", "employees"
```

Or you can pass multiple arguments to a single method call.  Each argument
can be any of the values described above.

```js
db.from(['users', 'people'], 'companies', { table: 'employees' })
// -> FROM "users" AS "people", "companies", "employees"
```

## where(criteria)

This method can be used to specify the criteria for matching rows.
You can specify one or more columns that you want to match against.

```js
db
  .select('name email')
  .from('users')
  .where('id')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "id"=?
```

The query will be constructed with placeholders matching the specified
column or columns.

Values for placeholders should be passed as an array to the
[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.

```js
const row = await db
  .select('name email')
  .from('users')
  .where('id')
  .one([12345])
```

You can specify multiple columns using the shorthand syntax as a
string of whitespace delimited table names.

```js
db
  .select('name email')
  .from('users')
  .where('id name')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "id"=? AND "name"=?
```

Commas (with optional whitespace following) can also be used to
delimit column names.

```js
db
  .select('name email')
  .from('users')
  .where('id, name')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "id"=? AND "name"=?
```

Columns can have the table name included in them.  Both the table
and columns names will be automatically quoted.

```js
db
  .select('name email')
  .from('users')
  .where('users.id')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "users"."id"=?
```

You can pass an object to the method mapping column names to their respective values.

```js
const row = await db
  .select('id name email')
  .from('users')
  .where({ id: 12345 })
  .one()
```

The query will still be constructed with placeholder values but all the values
will be collected and automatically provided to the
[one()](#one-values-), [any()](#any-values-) or [all()](#all-values-) methods.

You can pass additional values to those method to provide any additional values.
Be warned that they will always be added *after* values specified in the query.

This will work as intended:

```js
const row = await db
  .select('id name email')
  .from('users')
  .where({ id: 12345 })     // placeholder for id
  .where('name')            // placeholder for name
  .one(['Bobby Badger'])    // values are [12345, 'Bobby Badger']
```

But this won't:

```js
// DON'T DO THIS!
const row = await db
  .select('id name email')
  .from('users')
  .where('name')            // placeholder for name
  .where({ id: 12345 })     // placeholder for id
  .one(['Bobby Badger'])    // ERROR! values are [12345, 'Bobby Badger']
```

You can also provide values as an array of `[column, value]`.

```js
const row = await db
  .select('id name email')
  .from('users')
  .where(['id', '12345'])
  .one()
```

By default the comparison operator is `=`.  You can provide an array of three
values to set a different comparison operator: `[column, operator, value]`.

```js
db
  .select('id name email')
  .from('users')
  .where(['id', '>', '12345'])
// -> SELECT "id", "name", "email"
//    FROM "users"
//    WHERE "id">?
```

You can also set a comparison operator using an object by setting the value
to a two element array: `[operator, value]`.

```js
db
  .select('id name email')
  .from('users')
  .where({ id: ['>', '12345']})
// -> SELECT "id", "name", "email"
//    FROM "users"
//    WHERE "id">?
```

Or if you want to provide the value later then use a single element array: `[operator]`.

```js
db
  .select('id name email')
  .from('users')
  .where({ id: ['>']})
// -> SELECT "id", "name", "email"
//    FROM "users"
//    WHERE "id">?
```

You can use raw SQL to define the criteria columns.  The explicit way is to
pass an object with a `sql` property.

```js
db
  .select('id name email')
  .from('users')
  .where({ sql: 'id > ?' })
// -> SELECT "id", "name", "email"
//    FROM "users"
//    WHERE id > ?
```

Or you can use the `sql` function to create a tagged template literal.

```js
db
  .select('id name email')
  .from('users')
  .where(sql`id > ?`)
// -> SELECT "id", "name", "email"
//    FROM "users"
//    WHERE id > ?
```

You can call the method multiple times.  The criteria will all be
collected after the `WHERE` keyword and combined with `AND`.

```js
db
  .select('name email')
  .from('users')
  .where(['id', '>', 12345])
  .where('name')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "id">? AND "name"=?
```

Or you can pass multiple arguments to a single method call.  Each argument
can be any of the values described above.

```js
db
  .select('name email')
  .from('users')
  .where(['id', '>', 12345], 'name')
// -> SELECT "name", "email"
//    FROM "users"
//    WHERE "id">? AND "name"=?
```

## join(table)

This method can be used to join tables.  A string can be passed as
a shorthand syntax of the form `from=table.to`, where `from` is the
column you're joining from, `table` is the table you're joining onto
and `to` is the column in the joined table that should match the value
in the `from` column.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join('user.company_id=companies.id')
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN "companies" ON "user"."company_id" = "companies"."id"
```

You can pass an array to the method containing 2, 3, or 4 elements.
When using two elements, the first should be the table column you're
joining from and the second should be the table column you're joining to.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join(['user.company_id', 'companies.id'])
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN "companies" ON "user"."company_id" = "companies"."id"
```

The three element version has the destination table and column separated.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join(['user.company_id', 'companies', 'id'])
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN "companies" ON "user"."company_id" = "companies"."id"
```

The four element version allows you to specify the join type at the
beginning.  Valid types are `left`, `right`, `inner` and `full`.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join(['left', 'user.company_id', 'companies', 'id'])
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    LEFT JOIN "companies" ON "user"."company_id" = "companies"."id"
```

You can pass an object to the method containing the `from`, `table`
and `to` properties, and optionally the `type`.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join({ type: 'left', from: 'user.company_id', table: 'companies', to: 'id' })
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    LEFT JOIN "companies" ON "user"."company_id" = "companies"."id"
```

Or you can combine the table name and column in the `to` property.

```js
db
  .from('users')
  .select('name email')
  .select(['companies.name', 'company_name'])
  .join({ type: 'left', from: 'user.company_id', to: 'companies.id' })
// -> SELECT "name", "email", "companies"."name" AS "company_name"
//    FROM "users"
//    LEFT JOIN "companies" ON "user"."company_id" = "companies"."id"
```

You know the drill, right?  If the method doesn't do what you need then you
can use raw SQL to define the joins, either with an object containing a
`sql` property:

```js
db
  .from('users')
  .select('name email employee.job_title')
  .select(['companies.name', 'company_name'])
  .join({ sql: 'JOIN employees ON user.id=employees.user_id' })
// -> SELECT "name", "email", "employee"."job_title", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN employees ON user.id=employees.user_id
```

Or using the `sql` function to create a tagged template literal.

```js
db
  .from('users')
  .select('name email employee.job_title')
  .select(['companies.name', 'company_name'])
  .join(sql`JOIN employees ON user.id=employees.user_id`)
// -> SELECT "name", "email", "employee"."job_title", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN employees ON user.id=employees.user_id
```

And just like the other methods, you can call the method multiple times.

```js
db
  .from('users')
  .select('name email employee.job_title')
  .select(['companies.name', 'company_name'])
  .join('user.id=employees.user_id')
  .join('employees.company_id=companies.id')
// -> SELECT "name", "email", "employee"."job_title", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN "employees" ON "user"."id" = "employees"."user_id"
//    JOIN "companies" ON "employees"."company_id" = "companies"."id"
```

Or you can pass multiple arguments to a single method call.  Each argument
can be any of the values described above.

```js
db
  .from('users')
  .select('name email employee.job_title')
  .select(['companies.name', 'company_name'])
  .join('user.id=employees.user_id', 'employees.company_id=companies.id')
// -> SELECT "name", "email", "employee"."job_title", "companies"."name" AS "company_name"
//    FROM "users"
//    JOIN "employees" ON "user"."id" = "employees"."user_id"
//    JOIN "companies" ON "employees"."company_id" = "companies"."id"
```

## order(columns)

This method can be used to create an `ORDER BY` clause.  There's also an
`orderBy()` alias for the method if you prefer something a little closer
in name to the SQL it generates.

A string can be passed containing one or more columns.

```js
db
  .select('*')
  .from('users')
  .order('name')
// -> SELECT *
//    FROM "users"
//    ORDER BY "name"
```

Columns can be delimited by whitespace or commas, as usual.

```js
db
  .select('*')
  .from('users')
  .order('name, email')
// -> SELECT *
//    FROM "users"
//    ORDER BY "name", "email"
```

Columns can include the table name for disambiguation.

```js
db
  .select('*')
  .from('users')
  .order('users.name users.email')
// -> SELECT *
//    FROM "users"
//    ORDER BY "users"."name", "users"."email"
```

The default order is `ASC` for "ascending".  To set a different sort
order (e.g. `DESC` for "descending"), pass a two element array with the
columns as the first element and `DESC` as the second.

```js
db
  .select('*')
  .from('users')
  .order(['name email', 'DESC'])
// -> SELECT *
//    FROM "users"
//    ORDER BY "name", "email" DESC
```

You can also pass an objecting containing the `column` or `columns` property.
The `column` is assumed to be a single column whereas `columns` can contain
multiple columns separated by whitespace or commas in the usual way.  In addition
you can specify either `asc` or `desc` as a boolean flag to set the sort direction
to be ascending or descending, respectively.

```js
db
  .select('*')
  .from('users')
  .order({ columns: 'name email', desc: true })
// -> SELECT *
//    FROM "users"
//    ORDER BY "name", "email" DESC
```

Or use `direction` (or `dir` for short) set to either `ASC` or `DESC` if you prefer.

```js
db
  .select('*')
  .from('users')
  .order({ columns: 'name email', dir: 'DESC' })
// -> SELECT *
//    FROM "users"
//    ORDER BY "name", "email" DESC
```

Of course it also supports raw SQL, either using a `sql` property in an object.

```js
db
  .select('*')
  .from('users')
  .order({ sql: 'name DESC, email' })
// -> SELECT *
//    FROM "users"
//    ORDER BY name DESC, email
```

Or using a tagged template literal.

```js
db
  .select('*')
  .from('users')
  .order(sql`name DESC, email`)
// -> SELECT *
//    FROM "users"
//    ORDER BY name DESC, email
```

You can call the method multiple times or pass multiple arguments to it.

```js
db
  .select('*')
  .from('users')
  .order(['name', 'DESC'], 'email')
// -> SELECT *
//    FROM "users"
//    ORDER BY "name" DESC, "email"
```

## group(columns)

This method can be used to create a `GROUP BY` clause.  There's also a
`groupBy()` alias for it.

A string can be passed containing one or more columns.

```js
db
  .select(sql`company_id, COUNT(id) AS employees`)
  .from('users')
  .group('company_id')
// -> SELECT company_id, COUNT(id) AS employees
//    FROM "users"
//    GROUP BY "company_id"
```

Multiple columns can be delimited by whitespace or commas and can contain
a table name.

```js
db
  .select('*')
  .from('users')
  .group('users.company_id, users.start_year')
// -> SELECT *
//    FROM "users"
//    GROUP BY "users"."company_id", "users"."start_year"
```

You can also pass an objecting containing the `column` or `columns` property.
The `column` is assumed to be a single column whereas `columns` can contain
multiple columns separated by whitespace or commas in the usual way.

```js
db
  .select('*')
  .from('users')
  .group({ columns: 'company_id, year' })
// -> SELECT *
//    FROM "users"
//    GROUP BY "company_id", "year"
```

As you might expect it also supports raw SQL, either using a `sql` property in an object.

```js
db
  .select('*')
  .from('users')
  .group({ sql: 'company_id' })
// -> SELECT *
//    FROM "users"
//    GROUP BY company_id
```

Or using a tagged template literal.

```js
db
  .select('*')
  .from('users')
  .group(sql`company_id`)
// -> SELECT *
//    FROM "users"
//    GROUP BY company_id
```

You can call the method multiple times or pass multiple arguments to it.

```js
db
  .select('*')
  .from('users')
  .order('company_id', 'start_year')
// -> SELECT *
//    FROM "users"
//    GROUP BY "company_id", "start_year"
```

## limit(n)

This method can be used to set a `LIMIT` for the number of rows returned.

An integer should be passed to it.

```js
db
  .select('id name')
  .from('users')
  .limit(10)
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 10
```

If you call the method multiple times the previously set value will be overwritten.

```js
db
  .select('id name')
  .from('users')
  .limit(10)
  .limit(20)
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 20
```

## offset(n)

This method can be used to set an `OFFSET` for the number of rows returned.

An integer should be passed to it.

```js
db
  .select('id name')
  .from('users')
  .offset(10)
// -> SELECT "id", "name"
//    FROM "users"
//    OFFSET 10
```

If you call the method multiple times the previously set value will be overwritten.

```js
db
  .select('id name')
  .from('users')
  .offset(10)
  .offset(20)
// -> SELECT "id", "name"
//    FROM "users"
//    OFFSET 20
```

## range(from, to)

This method allows you to set both the `LIMIT` and `OFFSET` at once.

It expects two integers representing the first row you want returned and
the last row.  Note that the numbers start at 0 and the range is *inclusive*.

```js
db
  .select('id name')
  .from('users')
  .range(50, 59)
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 10
//    OFFSET 50
```

If you pass one integer then it is assumed to be the first row you want returned
and there will be no `LIMIT` to the number of rows returned.

```js
db
  .select('id name')
  .from('users')
  .range(50)
// -> SELECT "id", "name"
//    FROM "users"
//    OFFSET 50
```

You can also provide an object containing `from` and/or `to`.

```js
db
  .select('id name')
  .from('users')
  .range({ from: 50, to: 59 })
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 10
//    OFFSET 50
```

```js
db
  .select('id name')
  .from('users')
  .range({ from: 50 })
// -> SELECT "id", "name"
//    FROM "users"
//    OFFSET 50
```

```js
db
  .select('id name')
  .from('users')
  .range({ to: 49 })
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 50
```

You can also use it to explicitly set the `limit` and/or `offset`.

```js
db
  .select('id name')
  .from('users')
  .range({ limit: 10, offset: 50 })
// -> SELECT "id", "name"
//    FROM "users"
//    LIMIT 10
//    OFFSET: 50
```

```js
db
  .select('id name')
  .from('users')
  .range({ offset: 50 })
// -> SELECT "id", "name"
//    FROM "users"
//    OFFSET 50
```


## columns(columns)

This is just like [select()](#select-columns-) with one important
distinction.  If you don't explicitly specify a table name then it
will automatically attach the column names to the most recently
specified table.

```js
const query = db
  .from('users')
  .columns('id email');
// -> SELECT "users"."id", "users"."email"
//    FROM "users"
```

You can interleave it with multiple calls to [from()](#from-table-)
to access columns from different tables.

```js
const query = db
  .from('users')
  .columns('id email');
  .from('companies')
  .columns('name');
// -> SELECT "users"."id", "users"."email", "companies"."name"
//    FROM "users"
```

If you specify multiple table names in [from()](#from-table-) then the
last one will be used.

```js
const query = db
  .from('companies users')
  .columns('id name');
// -> SELECT "users"."id", "users"."name"
//    FROM "companies", "users"
```

If you specify a table with an alias then the alias will be used.

```js
const query = db
  .from({ table: "users", as: "people" })
  .columns('id name');
// -> SELECT "people"."id", "people"."name"
//    FROM "users" AS "people"
```

## table(name)

This can be used in conjuction with [columns()](#columns-columns-) to select
a table to attach columns to.  The table should previously have been specified
using [from()](#from-table-).

```js
const query = db
  .from('users companies')
  .table('users').columns('id name')
  .table('companies').columns(['name', 'company_name'])
// -> SELECT "users"."id", "users"."name", "companies"."name" AS "company_name"
//    FROM "users", "companies"
```

## prefix(prefix)

This can be used in conjuction with [columns()](#columns-columns-) to define
a prefix for subsequent columns.

```js
const query = db
  .from('users companies')
  .table('users').prefix('user_').columns('id name')
  .table('companies').prefix('company_').columns('name')
// -> SELECT "users"."id" AS "user_id", "users"."name" AS "user_name", "companies"."name" AS "company_name"
//    FROM "users", "companies"
```

You can clear the current prefix by calling `prefix()` without any arguments.


## one(values)

TODO

## any(values)

TODO

## all(values)

TODO