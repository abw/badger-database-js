# Table Methods

The table object provides a number of methods for generating and running
queries on table row.

As per the previous examples, we'll assume the table definition looks
something like this:

```js
// define the users table and the columns it contains
const db = await connect({
  database: 'sqlite:test.db',
  tables: {
    users: {
      columns: 'id name:required email:required'
    }
  }
});

// fetch the users table
const users = await db.table('users');
```

## insert(data, options)

The `insert()` method will construct and run an `INSERT` SQL query to insert a
row from the column data that you provide.

```js
const result = await users.insert({
  name:  'Brian Badger',
  email: 'brian@badgerpower.com'
});
console.log('Rows changed:', result.changes);
console.log('Generated id:', result.id);
```

The SQL query generated will look like this for Sqlite and Mysql:

```sql
INSERT INTO users (name, email)
VALUES (?, ?)
```

Note the use of value placeholders `?` to prevent SQL injection attacks.

The format for placeholders in Postgres is slightly different but has the
exact same effect:

```sql
INSERT INTO users (name, email)
VALUES ($1, $2)
```

The result returned from the `insert()` method is an object containing the
number of rows affected as `changes` and the generated id, where applicable in
`id`.  If you have defined a different id field (e.g. `user_id`) then this will
be returned instead.  Other data returned by the database engine may also be
defined.

You can insert multiple rows by passing an array of objects to the method.

```js
const results = await users.insert([
  {
    name:  'Bobby Badger',
    email: 'bobby@badgerpower.com'
  },
  {
    name:  'Brian Badger',
    email: 'brian@badgerpower.com'
  }
]);
console.log('Generated id #1:', results[0].id )
console.log('Generated id #2:', results[1].id )
```

The return value will be an array of results the same as those returned by
calling the method to insert a single row.

In some cases you may want to immediately fetch the inserted row back out of the
database.  This can be the case when you have columns with default values that
will be generated by the database (e.g. a `created` timestamp) that you want to
inspect.

You could easily do it yourself - the `insert()` method will return a result containing
the generated `id` (or other id field) which you can then use to fetch the record.
Or even easier, pass a second argument to the method as an object containing the
`reload` option set to a true value.

After inserting a row the table `insert()` method will immediately reload it from the
database and return the data for the row.

```js
const frank = await users.insert(
  {
    name:  'Frank Ferret',
    email: 'frank@ferrets-r-us.com'
  },
  { reload: true }
);
console.log(frank.id);      // e.g. 3
console.log(frank.name);    // Frank Ferret
console.log(frank.email);   // frank@ferrets-r-us.com
```

The same thing happens if you insert multiple rows and specify the `reload` options.
The only difference is that the return value will be an array of rows.

```js
const users = await users.insert(
  [
    {
      name:  'Frank Ferret',
      email: 'frank@ferrets-r-us.com'
    },
    {
      name:  'Simon Stoat',
      email: 'simon@stoats-r-superb.com'
    },
  ],
  { reload: true }
);
console.log(users.length);        // 2
console.log(users[0].id);         // e.g. 4
console.log(users[0].name);       // Frank Ferret
console.log(users[0].email);      // frank@ferrets-r-us.com
console.log(users[1].id);         // e.g. 5
console.log(users[1].name);       // Simon Stoat
console.log(users[1].email);      // simon@stoats-r-superb.com
```

The other option that is supported by the insert methods is `record`.
This will reload the row from the database (as per the `reload` option)
and return it as a record object.  We'll be talking more about
[records](manual/records.html) shortly but for now you should know that
it exists.

```js
const frank = await users.insert(
  {
    name:  'Frank Ferret',
    email: 'frank@ferrets-r-us.com'
  },
  { record: true }
);
// frank is a record object but it still behaves like a row
console.log(frank.id);      // e.g. 3
console.log(frank.name);    // Frank Ferret
console.log(frank.email);   // frank@ferrets-r-us.com
```

## insertOneRow(data, options)

Internally, the [insert()](#insert-data--options-) method calls either
`insertAllRows()`, if the value passed is an array, or `insertOneRow()`
if it's a single data object. You can call these methods directly if you prefer.

```js
const result = await users.insertOneRow({
  name:  'Brian Badger',
  email: 'brian@badgerpower.com'
});
```

## insertAllRows(array, options)

Here's an example explicitly calling the `insertAllRows()` method.  It's exactly the
same as calling [insert()](#insert-data--options-) with an array of rows to insert.

```js
const results = await users.insertAllRows([
  {
    name:  'Frank Ferret',
    email: 'frank@badgerpower.com'
  }
  {
    name:  'Simon Stoat',
    email: 'simon@badgerpower.com'
  }
]);
```

## insertOneRecord(data, options)

This is a wrapper around the [insertOneRow()](insertonerow-data-options-)
which automatically sets the `record` option for you.  The result returned
will be a record object instead of a result object.

```js
const record = await users.insertOneRecord({
  name:  'Brian Badger',
  email: 'brian@badgerpower.com'
});
// a record object still behaves like a row
console.log(record.name);   // Brian Badger
console.log(record.email);  // brian@badgerpower.com
```

## insertAllRecords(array, options)

This is a wrapper around the [insertAllRow()](insertallrows-array-options-)
which automatically sets the `record` option for you.  The result returned
will be an array of record objects instead of an array of results.

```js
const records = await users.insertAllRecords([
  {
    name:  'Bobby Badger',
    email: 'bobby@badgerpower.com'
  },
  {
    name:  'Brian Badger',
    email: 'brian@badgerpower.com'
  }
]);
// array of records returned, but they behave like rows
console.log(records.length); // 2
console.log(records[0].name);    // Bobby Badger
console.log(records[0].email);   // bobby@badgerpower.com
console.log(records[1].name);    // Brian Badger
console.log(records[1].email);   // brian@badgerpower.com
```

## update(set, where, options)

The `update()` method, as the name suggests, allows you to update rows.

```js
await users.update(
  { name: 'Brian "The Brains" Badger' },
  { email: 'brian@badgerpower.com' }
);
```

The first argument is an object containing the changes you want to make.
The second optional argument is the `WHERE` clause identifying the rows
you want to update.  You can omit the second argument if you want to update
all rows.

The SQL generated for the method call shown above will look something like this:

```sql
UPDATE users
SET    name=?
WHERE  email=?
```

Again, the format for Postgres is slightly different, using `$1` and `$2` for
placeholders instead of `?`, but works exactly the same.

## updateAllRows(set, where, options)

The [update()](#update-set--where--options-) method is internally a wrapper
around `updateAllRows()`.  If you want additional checks to be performed to
ensure that you're only updating one row, or if you want to automatically
reload a row after an update then you can use the
[updateOneRow()](#updateonerow-set--where--options-) or
[updateAnyRow()](#updateanyrow-set--where--options-) methods.

## updateOneRow(set, where, options)

This is a variant of the [update()](#update-set--where--options-) /
[updateAllRows()](#updateallrows-set--where--options-) method that has an
additional assertion check that exactly one row is updated.  If zero or more
rows are updated then an `UnexpectedRowCount` error will be thrown with a
message of the form `N rows were updated when one was expected`.

This method also supports the `reload` option.  When set, the method will
automatically reload the row from the database after performing the update.
This can be useful if you've got a column which is automatically set when the
record is updated, e.g. a `modified` column, which you want to inspect.

```js
const row = await users.updateOneRow(
  { name: 'Brian "The Brains" Badger' },
  { email: 'brian@badgerpower.com' },
  { reload: true }
);
console.log('updated record:', row);
```

One thing to note: this uses the modification and selection criteria specified
to reload the data.  If, for example, you change the email address of a row
then it will correctly reload the record using the new email address.

```js
const row = await users.updateOneRow(
  { email: 'brian-badger@badgerpower.com' },
  { email: 'brian@badgerpower.com' },
  { reload: true }
);
console.log('new email address:', row.email); // brian-badger@badgerpower.com
```

However, there are edge cases where it's not possible to reload the same row that
was modified, based on the criteria provided.  Consider this somewhat contrived
example: if the users table has a `friends` column and there is exactly one record
where the `friends` count is set to `0`.  You feel sorry for the poor user and
decide to modify their `friends` count to be `1`.  You'll be their friend, right?

```js
await users.updateOneRow(
  { friends: 1 },
  { friends: 0 },
  { reload: true }
);
```

While there may have been exactly one user with `friends` set to `0` *before*
the update, once the update has been applied there may be multiple rows which have
the `friends` count set to `1`.  The reload will fail with an `UnexpectedRowCount`
error.  In these cases you should always provide some other unique attribute to ensure
that the correct row can be identified and reloaded:

```js
await users.updateOneRow(
  { friends: 1 },
  { email: 'bobby@badger.com' },
  { reload: true }
);
```

## updateAnyRow(set, where, options)

This is a variant of the [update()](#update-set--where--options-) /
[updateAllRows()](#updateallrows-set--where--options-) method that has an
additional assertion check that no more than one row is updated.  If more
than one rows are updated then an `UnexpectedRowCount` error will be thrown
with a message of the form `N rows were updated when one was expected`.

This also supports the `reload` option.  If a row is updated then the complete
row data will be returned.  Otherwise it will return `undefined`.

```js
const row = await users.updateAnyRow(
  { name: 'Brian "The Brains" Badger' },
  { email: 'brian@badgerpower.com' },
  { reload: true }
);
if (row) {
  console.log("updated row:", row);
}
else {
  console.log("could not update row - Brian not found!")
}
```

## delete()

You can probably guess what the `delete()` method does.

```js
await users.delete({
  email: 'brian@badgerpower.com'
});
```

The object passed as the only argument identifies the rows that you want to delete.

The SQL generated will look something like this:

```sql
DELETE FROM users
WHERE email=?
```

You can omit the selection criteria if you want to delete all rows in the table.

```js
await users.delete()
```

Naturally, you should use this method with caution.

## oneRow()

There are three different methods for fetching rows from the table using
selection criteria.  The `oneRow()` method will return a single row.
If the row isn't found or multiple rows match the criteria then an
`UnexpectedRowCount` error will be thrown with a message of
the form `N rows were returned when one was expected`.

```js
// returns a single row or throws an error
const brian = await users.oneRow({
  email: 'brian@badgerpower.com'
});
console.log('Brian:', brian);
```

You can pass a second argument which can contain various options to modify
the selection.  For example, the `columns` option can be used to specify
the columns that you want to select.  They can be specified as a string
containing the columns names separated by whitespace:

```js
const brian = await users.oneRow(
  { email: 'brian@badgerpower.com' },
  { columns: 'id name' }
);
```

Or as an array:

```js
const brian = await users.oneRow(
  { email: 'brian@badgerpower.com' },
  { columns: ['id', 'name'] }
);
```

The generated SQL for this method (and also `anyRow()` and `allRows()`)
will look something like this:

```sql
SELECT "users"."id", "users"."name" FROM users
WHERE email=?
```

## anyRow()

The `anyRow()` method will return a single row if it exists or `undefined` if it doesn't.

```js
// returns a single row or undefined
const brian = await users.anyRow({
  email: 'brian@badgerpower.com'
});
if (brian) {
  console.log('Brian:', brian);
}
else {
  console.log('Brian Badger was not found');
}
```

## allRows()

The `allRows()` method will return an array of all matching rows.

```js
// returns an array of all rows (possibly empty)
const bobbies = await users.allRows({
  { name: 'Bobby Badger' }
);
if (bobbies.length) {
  console.log("Fetched %s users called 'Bobby Badger':", bobbies.length);
}
else {
  console.log("There aren't any users called 'Bobby Badger'");
}
```

If you want to return all matching rows then you can omit the criteria or
specify an empty object.

```js
const allUsers = await users.fetchAll();
```

```js
const allUsers = await users.fetchAll({ });
```

## oneRecord()

This method is a wrapper around `oneRow()` which returns the row as
a record object.

Read more about records [here](manual/records.html).

## anyRecord()

This method is a wrapper around `anyRow()` which returns the row as
a record object.

## allRecords()

This method is a wrapper around `allRows()` which returns the rows as
an array of record objects.

## run()

This is a low-level method for running any arbitrary SQL query where
you're not expecting to fetch any rows.  It's just like the `run()`
method on the database object.  The only difference is that there are
some table-specific fragments pre-defined: `table` contains the table
name and `columns` contains a comma separated list of all column names.
Any other `fragments` that you've specified in your table definition
will also be available.

The columns have the table name prepended and are property quoted for
the database.  For example, a `users` table having columns defined as
`id name email` will expand the `columns` SQL fragment as
`"users"."id", "users"."name", "users"."email"` for Sqlite and Postgres.
For Mysql the backtick character is used instead of double quotes.

As a trivial example, you can embed the `table` name in a query like so:

```js
users.run('DROP TABLE &lt;table&gt;')
```

## one()

This is another low-level method for running an SQL query where you're
expecting to get exactly one row returned.  It's just like the
corresponding `one()` database method, with the additional table-specific
SQL fragments available, as per `run()`.

```js
const bobby = users.one(
  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE name=?',
  ['Bobby Badger']
)
```

## any()

This is yet another low-level method for running an SQL query, but where
you're expecting to get one row returned which may or may not exist.
It's just like the corresponding `any()` database method, with the additional
table-specific SQL fragments available, as per `run()`.

```js
const bobby = users.any(
  'SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE name=?',
  ['Bobby Badger']
)
```

## all()

The final low-level method for running an SQL query where you're expecting to
get multiple rows.  It's just like the corresponding `all()` database method,
with the additional table-specific SQL fragments available, as per `run()`.

```js
const rows = users.all(
  'SELECT &lt;columns&gt; FROM &lt;table&gt;',
)
```
